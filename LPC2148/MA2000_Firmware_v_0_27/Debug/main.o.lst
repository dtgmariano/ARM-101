   1              		.cpu arm7tdmi
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"main.c"
  21              	.Ltext0:
  22              		.file 1 "../main.c"
 2721              		.align	2
 2724              	size:
 2725 0000 00000000 		.space	4
 2726              		.global	data
 2727              		.align	2
 2730              	data:
 2731 0004 00000000 		.space	60
 2731      00000000 
 2731      00000000 
 2731      00000000 
 2731      00000000 
 2732              		.global	buffer
 2733              		.align	2
 2736              	buffer:
 2737 0040 00000000 		.space	100
 2737      00000000 
 2737      00000000 
 2737      00000000 
 2737      00000000 
 2738              		.global	adc
 2739              		.align	2
 2742              	adc:
 2743 00a4 00000000 		.space	12
 2743      00000000 
 2743      00000000 
 2744              		.global	pos
 2745              		.align	2
 2748              	pos:
 2749 00b0 00000000 		.space	12
 2749      00000000 
 2749      00000000 
 2750              		.global	kp
 2751              		.align	2
 2754              	kp:
 2755 00bc 00000000 		.space	12
 2755      00000000 
 2755      00000000 
 2756              		.global	ki
 2757              		.align	2
 2760              	ki:
 2761 00c8 00000000 		.space	12
 2761      00000000 
 2761      00000000 
 2762              		.global	kd
 2763              		.align	2
 2766              	kd:
 2767 00d4 00000000 		.space	12
 2767      00000000 
 2767      00000000 
 2768              		.global	ort
 2769              		.align	2
 2772              	ort:
 2773 00e0 00000000 		.space	12
 2773      00000000 
 2773      00000000 
 2774              		.comm	e,12,4
 2775              		.text
 2776              		.align	2
 2777              		.global	PWM_InterruptControl
 2779              	PWM_InterruptControl:
 2780              	.LFB0:
   1:../main.c     **** /*------------------------------------------------------------------------------------*/
   2:../main.c     **** /*                                       HEADER                                       */
   3:../main.c     **** /*------------------------------------------------------------------------------------*/
   4:../main.c     **** /***************************************************************************************
   5:../main.c     ****  *Project Name: MA2000 Firmware
   6:../main.c     ****  *	   Version: 0.24
   7:../main.c     ****  *   File Name: main.c
   8:../main.c     ****  *  Created on: 19/03/2013
   9:../main.c     ****  *      Author: Daniel Teodoro G. Mariano
  10:../main.c     ****  *       Email: dtgm@uol.com.br
  11:../main.c     ****  * Description: Firmware for LPC2148, to control the MA2000 robot, a mechanical arm
  12:../main.c     ****  * 				with 6 degrees of freedom.
  13:../main.c     ****  *
  14:../main.c     ****  * 				The first three DOF's (1-Waist, 2-Shoulder, 3-Elbow) are controlled each
  15:../main.c     ****  * 				one by a DC Motor with the following configurations: A PWM at 20000 Hz with
  16:../main.c     ****  * 				variable Duty Cycle is assigned to the variable DOF_PWM_DC, according with
  17:../main.c     ****  * 				the proportional control and two GPIO for controlling the inputs of the
  18:../main.c     ****  * 				LPC6203 Full Bridge Driver.
  19:../main.c     ****  *
  20:../main.c     ****  * 				Each motor has a potentiometer connected to the motor shaft by a toothed
  21:../main.c     ****  * 				belt, and this potentiometer provides a voltage signal proportional to the
  22:../main.c     ****  * 				angular position of the motor. This signal is capture by an ADC channel
  23:../main.c     ****  * 				and is assigned to the variable DOF_ADC_POT
  24:../main.c     ****  *
  25:../main.c     ****  * 				The proportional control is effected by the relationship of the variables
  26:../main.c     ****  * 				DOF_ADC_POT and the setpoint position established by the user assigned to
  27:../main.c     ****  * 				the variable DOF_SETPOINT.
  28:../main.c     ****  *
  29:../main.c     ****  * 				The others three DOF's (4-Pitch, 5-Yaw, 6-Roll) are controlled each one
  30:../main.c     ****  * 				by a Servomotor with the following configurations: A PWM at 50 Hz with
  31:../main.c     ****  * 				variable Duty Cycle (5%-10%) to control the servo.
  32:../main.c     **** ***************************************************************************************/
  33:../main.c     **** 
  34:../main.c     **** /*------------------------------------------------------------------------------------*/
  35:../main.c     **** /*                                PINS CONFIGURATION                                  */
  36:../main.c     **** /*------------------------------------------------------------------------------------*/
  37:../main.c     **** /***************************************************************************************
  38:../main.c     **** * Pins		Function	  	LPC2148 	Connector
  39:../main.c     **** * P0.7		PWM 2 (31)      EXT1-8		EXT1 20
  40:../main.c     **** * P0.8		PWM 4 (31)      			EXT1 17
  41:../main.c     **** * P0.21		PWM 5 (31)           		EXT1 9
  42:../main.c     **** * P0.18		P0.18 (53)      EXT1-19		EXT1 7
  43:../main.c     **** * P0.19		P0.19 (54)      EXT1-20		EXT1 8
  44:../main.c     **** * P0.28		AD0.1 (13)      EXT2-1		EXT2 25
  45:../main.c     **** * P0.29		AD0.2 (14)      EXT2-2		EXT2 26
  46:../main.c     **** * P0.30		AD0.3 ()
  47:../main.c     **** * P0.25		AD0.4
  48:../main.c     **** *
  49:../main.c     **** * 				  			+3.3V   	EXT2-4
  50:../main.c     **** * 			      			GND     	EXT2-1 e EXT1-2
  51:../main.c     **** ***************************************************************************************/
  52:../main.c     **** 
  53:../main.c     **** /*------------------------------------------------------------------------------------*/
  54:../main.c     **** /*                                 	   INCLUDES                                       */
  55:../main.c     **** /*------------------------------------------------------------------------------------*/
  56:../main.c     **** #include <string.h>
  57:../main.c     **** #include "LPC214x.h"
  58:../main.c     **** #include "Modules/adc.h"
  59:../main.c     **** #include "Modules/pwm.h"
  60:../main.c     **** #include "Modules/gpio.h"
  61:../main.c     **** #include "Modules/uart.h"
  62:../main.c     **** #include "Modules/iprintf.h"
  63:../main.c     **** #include "Modules/timer.h"
  64:../main.c     **** 
  65:../main.c     **** /*------------------------------------------------------------------------------------*/
  66:../main.c     **** /*                                 	   DEFINES                                        */
  67:../main.c     **** /*------------------------------------------------------------------------------------*/
  68:../main.c     **** #define PWMSERVO_COUNT 4290
  69:../main.c     **** 
  70:../main.c     **** 
  71:../main.c     **** /*------------------------------------------------------------------------------------*/
  72:../main.c     **** /*                         	   VARIABLES DECLARATION                                  */
  73:../main.c     **** /*------------------------------------------------------------------------------------*/
  74:../main.c     **** typedef enum {IDLE, RECEIVING_DATA, SENDING_DATA, CONTROLLER} STATE;
  75:../main.c     **** int size = 0;
  76:../main.c     **** int data[15] = {0};
  77:../main.c     **** uint8_t buffer[100] = {0};
  78:../main.c     **** uint32_t adc[3] = {0}, pos[3] = {0}, kp[3] = {0}, ki[3] = {0}, kd[3] = {0}, ort[3] = {0}, e[3];
  79:../main.c     **** 
  80:../main.c     **** 
  81:../main.c     **** 
  82:../main.c     **** /*------------------------------------------------------------------------------------*/
  83:../main.c     **** /*                                     PROTOTYPES                                     */
  84:../main.c     **** /*------------------------------------------------------------------------------------*/
  85:../main.c     **** 
  86:../main.c     **** 
  87:../main.c     **** 
  88:../main.c     **** /*------------------------------------------------------------------------------------*/
  89:../main.c     **** /*                            INTERRUPTIONS  IMPLEMENTATION                           */
  90:../main.c     **** /*------------------------------------------------------------------------------------*/
  91:../main.c     **** 
  92:../main.c     **** /***************************************************************************************
  93:../main.c     ****  * Function Name: PWM_InterruptControl(void)
  94:../main.c     ****  * 		 	Type: Void
  95:../main.c     ****  *	  Parameters:
  96:../main.c     ****  * 	 	 Returns: Void
  97:../main.c     ****  * 	 Description: Function called by a timer interruption to control PWM 4, 5 and 6
  98:../main.c     **** ***************************************************************************************/
  99:../main.c     **** void PWM_InterruptControl(void)
 100:../main.c     **** {
 2781              		.loc 1 100 0
 2782              		.cfi_startproc
 2783              		@ Function supports interworking.
 2784              		@ args = 0, pretend = 0, frame = 0
 2785              		@ frame_needed = 1, uses_anonymous_args = 0
 2786              		@ link register save eliminated.
 2787 0000 04B02DE5 		str	fp, [sp, #-4]!
 2788              	.LCFI0:
 2789              		.cfi_def_cfa_offset 4
 2790 0004 00B08DE2 		add	fp, sp, #0
 2791              		.cfi_offset 11, -4
 2792              	.LCFI1:
 2793              		.cfi_def_cfa_register 11
 101:../main.c     **** //	if(iCountTimer0 >= ort[0])
 102:../main.c     **** //		IOCLR1 = (1<<x);
 103:../main.c     **** //	if(iCountTimer0 >= ort[1])
 104:../main.c     **** //		IOCLR1 = (1<<x);
 105:../main.c     **** //	if(iCountTimer0 >= ort[2])
 106:../main.c     **** //		IOCLR1 = (1<<x);
 107:../main.c     **** //	if(iCountTimer0 >= PWMSERVO_COUNT)
 108:../main.c     **** //	{
 109:../main.c     **** //		IOSET1 = (1<<x);
 110:../main.c     **** // 		IOSET1 = (1<<x);
 111:../main.c     **** //		IOSET1 = (1<<x);
 112:../main.c     **** //		iCountTimer0 = 0;
 113:../main.c     **** //	}
 114:../main.c     **** //	iCountTimer0++;
 115:../main.c     **** }
 2794              		.loc 1 115 0
 2795 0008 00D08BE2 		add	sp, fp, #0
 2796 000c 0008BDE8 		ldmfd	sp!, {fp}
 2797 0010 1EFF2FE1 		bx	lr
 2798              		.cfi_endproc
 2799              	.LFE0:
 2801              		.align	2
 2803              	feed:
 2804              	.LFB1:
 116:../main.c     **** 
 117:../main.c     **** 
 118:../main.c     **** /*------------------------------------------------------------------------------------*/
 119:../main.c     **** /*                               FUNCTIONS  IMPLEMENTATION                            */
 120:../main.c     **** /*------------------------------------------------------------------------------------*/
 121:../main.c     **** 
 122:../main.c     **** #define PLOCK 0x400
 123:../main.c     **** 
 124:../main.c     **** static void feed(void)
 125:../main.c     **** {
 2805              		.loc 1 125 0
 2806              		.cfi_startproc
 2807              		@ Function supports interworking.
 2808              		@ args = 0, pretend = 0, frame = 0
 2809              		@ frame_needed = 1, uses_anonymous_args = 0
 2810              		@ link register save eliminated.
 2811 0014 04B02DE5 		str	fp, [sp, #-4]!
 2812              	.LCFI2:
 2813              		.cfi_def_cfa_offset 4
 2814 0018 00B08DE2 		add	fp, sp, #0
 2815              		.cfi_offset 11, -4
 2816              	.LCFI3:
 2817              		.cfi_def_cfa_register 11
 126:../main.c     ****   PLLFEED = 0xAA;
 2818              		.loc 1 126 0
 2819 001c 0E32A0E3 		mov	r3, #-536870912
 2820 0020 7F3983E2 		add	r3, r3, #2080768
 2821 0024 8C3083E2 		add	r3, r3, #140
 2822 0028 AA20A0E3 		mov	r2, #170
 2823 002c 002083E5 		str	r2, [r3, #0]
 127:../main.c     ****   PLLFEED = 0x55;
 2824              		.loc 1 127 0
 2825 0030 0E32A0E3 		mov	r3, #-536870912
 2826 0034 7F3983E2 		add	r3, r3, #2080768
 2827 0038 8C3083E2 		add	r3, r3, #140
 2828 003c 5520A0E3 		mov	r2, #85
 2829 0040 002083E5 		str	r2, [r3, #0]
 128:../main.c     **** }
 2830              		.loc 1 128 0
 2831 0044 00D08BE2 		add	sp, fp, #0
 2832 0048 0008BDE8 		ldmfd	sp!, {fp}
 2833 004c 1EFF2FE1 		bx	lr
 2834              		.cfi_endproc
 2835              	.LFE1:
 2837              		.align	2
 2838              		.global	delay
 2840              	delay:
 2841              	.LFB2:
 129:../main.c     **** 
 130:../main.c     **** /***************************************************************************************
 131:../main.c     ****  * Function Name: Modules_Init(void)
 132:../main.c     ****  * 		 	Type: Void
 133:../main.c     ****  *	  Parameters:
 134:../main.c     ****  * 		 Returns: Void
 135:../main.c     ****  * 	 Description: Initiates CPU configurations,
 136:../main.c     ****  * 				  Configure Timer, PWM, ADC, UART Modules,
 137:../main.c     ****  * 				  Sets GPIO Pins.
 138:../main.c     **** ***************************************************************************************/
 139:../main.c     **** void delay()
 140:../main.c     **** {
 2842              		.loc 1 140 0
 2843              		.cfi_startproc
 2844              		@ Function supports interworking.
 2845              		@ args = 0, pretend = 0, frame = 8
 2846              		@ frame_needed = 1, uses_anonymous_args = 0
 2847              		@ link register save eliminated.
 2848 0050 04B02DE5 		str	fp, [sp, #-4]!
 2849              	.LCFI4:
 2850              		.cfi_def_cfa_offset 4
 2851 0054 00B08DE2 		add	fp, sp, #0
 2852              		.cfi_offset 11, -4
 2853              	.LCFI5:
 2854              		.cfi_def_cfa_register 11
 2855 0058 0CD04DE2 		sub	sp, sp, #12
 2856              	.LBB2:
 141:../main.c     ****   for(int i = 0; i < 1000000; i++)
 2857              		.loc 1 141 0
 2858 005c 0030A0E3 		mov	r3, #0
 2859 0060 08300BE5 		str	r3, [fp, #-8]
 2860 0064 090000EA 		b	.L4
 2861              	.L5:
 142:../main.c     ****   {
 143:../main.c     ****     asm volatile ("NOP");
 2862              		.loc 1 143 0 discriminator 2
 2863              	@ 143 "../main.c" 1
 2864 0068 0000A0E1 		NOP
 2865              	@ 0 "" 2
 144:../main.c     ****     asm volatile ("NOP");
 2866              		.loc 1 144 0 discriminator 2
 2867              	@ 144 "../main.c" 1
 2868 006c 0000A0E1 		NOP
 2869              	@ 0 "" 2
 145:../main.c     ****     asm volatile ("NOP");
 2870              		.loc 1 145 0 discriminator 2
 2871              	@ 145 "../main.c" 1
 2872 0070 0000A0E1 		NOP
 2873              	@ 0 "" 2
 146:../main.c     ****     asm volatile ("NOP");
 2874              		.loc 1 146 0 discriminator 2
 2875              	@ 146 "../main.c" 1
 2876 0074 0000A0E1 		NOP
 2877              	@ 0 "" 2
 147:../main.c     ****     asm volatile ("NOP");
 2878              		.loc 1 147 0 discriminator 2
 2879              	@ 147 "../main.c" 1
 2880 0078 0000A0E1 		NOP
 2881              	@ 0 "" 2
 148:../main.c     ****     asm volatile ("NOP");
 2882              		.loc 1 148 0 discriminator 2
 2883              	@ 148 "../main.c" 1
 2884 007c 0000A0E1 		NOP
 2885              	@ 0 "" 2
 149:../main.c     ****     asm volatile ("NOP");
 2886              		.loc 1 149 0 discriminator 2
 2887              	@ 149 "../main.c" 1
 2888 0080 0000A0E1 		NOP
 2889              	@ 0 "" 2
 141:../main.c     ****   for(int i = 0; i < 1000000; i++)
 2890              		.loc 1 141 0 discriminator 2
 2891 0084 08301BE5 		ldr	r3, [fp, #-8]
 2892 0088 013083E2 		add	r3, r3, #1
 2893 008c 08300BE5 		str	r3, [fp, #-8]
 2894              	.L4:
 141:../main.c     ****   for(int i = 0; i < 1000000; i++)
 2895              		.loc 1 141 0 is_stmt 0 discriminator 1
 2896 0090 08201BE5 		ldr	r2, [fp, #-8]
 2897 0094 3D39A0E3 		mov	r3, #999424
 2898 0098 8F3F83E2 		add	r3, r3, #572
 2899 009c 033083E2 		add	r3, r3, #3
 2900 00a0 030052E1 		cmp	r2, r3
 2901 00a4 EFFFFFDA 		ble	.L5
 2902              	.LBE2:
 150:../main.c     ****   }
 151:../main.c     **** }
 2903              		.loc 1 151 0 is_stmt 1
 2904 00a8 00D08BE2 		add	sp, fp, #0
 2905 00ac 0008BDE8 		ldmfd	sp!, {fp}
 2906 00b0 1EFF2FE1 		bx	lr
 2907              		.cfi_endproc
 2908              	.LFE2:
 2910              		.align	2
 2911              		.global	Initialize
 2913              	Initialize:
 2914              	.LFB3:
 152:../main.c     **** void Initialize(void)
 153:../main.c     **** {
 2915              		.loc 1 153 0
 2916              		.cfi_startproc
 2917              		@ Function supports interworking.
 2918              		@ args = 0, pretend = 0, frame = 0
 2919              		@ frame_needed = 1, uses_anonymous_args = 0
 2920 00b4 00482DE9 		stmfd	sp!, {fp, lr}
 2921              	.LCFI6:
 2922              		.cfi_def_cfa_offset 8
 2923 00b8 04B08DE2 		add	fp, sp, #4
 2924              		.cfi_offset 14, -4
 2925              		.cfi_offset 11, -8
 2926              	.LCFI7:
 2927              		.cfi_def_cfa 11, 4
 154:../main.c     **** 	PLLCFG = 0x24; //Configura o multiplicador PLL para 4 e o divisor para 2
 2928              		.loc 1 154 0
 2929 00bc 0E32A0E3 		mov	r3, #-536870912
 2930 00c0 7F3983E2 		add	r3, r3, #2080768
 2931 00c4 843083E2 		add	r3, r3, #132
 2932 00c8 2420A0E3 		mov	r2, #36
 2933 00cc 002083E5 		str	r2, [r3, #0]
 155:../main.c     ****              	   //Assim com o cristal de 12MHz temos um CCLK = 48MHz e um FCCO = 192MHz
 156:../main.c     ****     feed();
 2934              		.loc 1 156 0
 2935 00d0 CFFFFFEB 		bl	feed
 157:../main.c     **** 
 158:../main.c     ****     PLLCON = 0x01; //Habilita o bloco PLL
 2936              		.loc 1 158 0
 2937 00d4 0E32A0E3 		mov	r3, #-536870912
 2938 00d8 7F3983E2 		add	r3, r3, #2080768
 2939 00dc 803083E2 		add	r3, r3, #128
 2940 00e0 0120A0E3 		mov	r2, #1
 2941 00e4 002083E5 		str	r2, [r3, #0]
 159:../main.c     ****     feed();      //Para que as alterações anteriores tenham efeito
 2942              		.loc 1 159 0
 2943 00e8 C9FFFFEB 		bl	feed
 160:../main.c     **** 
 161:../main.c     ****     while(!(PLLSTAT & PLOCK)) ; //Garante que a alteração anterior teve efeito uma vez que quando
 2944              		.loc 1 161 0
 2945 00ec 0000A0E1 		mov	r0, r0	@ nop
 2946              	.L7:
 2947              		.loc 1 161 0 is_stmt 0 discriminator 1
 2948 00f0 0E32A0E3 		mov	r3, #-536870912
 2949 00f4 7F3983E2 		add	r3, r3, #2080768
 2950 00f8 883083E2 		add	r3, r3, #136
 2951 00fc 003093E5 		ldr	r3, [r3, #0]
 2952 0100 013B03E2 		and	r3, r3, #1024
 2953 0104 000053E3 		cmp	r3, #0
 2954 0108 F8FFFF0A 		beq	.L7
 162:../main.c     ****                     //o bit PLOCK do reg. PLLSTAT vale zero ouve um bloqueio no PLL que
 163:../main.c     ****                     //ocorre logo após a modificação dos registradores
 164:../main.c     **** 
 165:../main.c     ****     PLLCON = 0x03; //Depois de habilitado resta conectá-lo a fonte de clock para que comece o traba
 2955              		.loc 1 165 0 is_stmt 1
 2956 010c 0E32A0E3 		mov	r3, #-536870912
 2957 0110 7F3983E2 		add	r3, r3, #2080768
 2958 0114 803083E2 		add	r3, r3, #128
 2959 0118 0320A0E3 		mov	r2, #3
 2960 011c 002083E5 		str	r2, [r3, #0]
 166:../main.c     ****     feed();        //Necessário para que as alterações anteriores tenham efeito
 2961              		.loc 1 166 0
 2962 0120 BBFFFFEB 		bl	feed
 167:../main.c     **** 
 168:../main.c     ****     MAMCR = 0x02;  //Habilita todas as funções do Módulo acelerador de memória
 2963              		.loc 1 168 0
 2964 0124 0E32A0E3 		mov	r3, #-536870912
 2965 0128 7F3983E2 		add	r3, r3, #2080768
 2966 012c 0220A0E3 		mov	r2, #2
 2967 0130 002083E5 		str	r2, [r3, #0]
 169:../main.c     ****     MAMTIM = 0x04;  //O ciclo de busca do MAM tem duração de 4 ciclos
 2968              		.loc 1 169 0
 2969 0134 4E32A0E3 		mov	r3, #-536870908
 2970 0138 7F3983E2 		add	r3, r3, #2080768
 2971 013c 0420A0E3 		mov	r2, #4
 2972 0140 002083E5 		str	r2, [r3, #0]
 170:../main.c     ****     VPBDIV = 0x01;  //Clock dos periféricos igual ao clock do Sistema
 2973              		.loc 1 170 0
 2974 0144 0E32A0E3 		mov	r3, #-536870912
 2975 0148 7F3983E2 		add	r3, r3, #2080768
 2976 014c 013C83E2 		add	r3, r3, #256
 2977 0150 0120A0E3 		mov	r2, #1
 2978 0154 002083E5 		str	r2, [r3, #0]
 171:../main.c     **** }
 2979              		.loc 1 171 0
 2980 0158 04D04BE2 		sub	sp, fp, #4
 2981 015c 0048BDE8 		ldmfd	sp!, {fp, lr}
 2982 0160 1EFF2FE1 		bx	lr
 2983              		.cfi_endproc
 2984              	.LFE3:
 2986              		.align	2
 2987              		.global	Modules_Init
 2989              	Modules_Init:
 2990              	.LFB4:
 172:../main.c     **** 
 173:../main.c     **** /***************************************************************************************
 174:../main.c     ****  * Function Name: Modules_Init(void)
 175:../main.c     ****  * 		 	Type: Void
 176:../main.c     ****  *	  Parameters:
 177:../main.c     ****  * 		 Returns: Void
 178:../main.c     ****  * 	 Description: Initiates CPU configurations,
 179:../main.c     ****  * 				  Configure Timer, PWM, ADC, UART Modules,
 180:../main.c     ****  * 				  Sets GPIO Pins.
 181:../main.c     **** ***************************************************************************************/
 182:../main.c     **** void Modules_Init(void)
 183:../main.c     **** {
 2991              		.loc 1 183 0
 2992              		.cfi_startproc
 2993              		@ Function supports interworking.
 2994              		@ args = 0, pretend = 0, frame = 0
 2995              		@ frame_needed = 1, uses_anonymous_args = 0
 2996 0164 00482DE9 		stmfd	sp!, {fp, lr}
 2997              	.LCFI8:
 2998              		.cfi_def_cfa_offset 8
 2999 0168 04B08DE2 		add	fp, sp, #4
 3000              		.cfi_offset 14, -4
 3001              		.cfi_offset 11, -8
 3002              	.LCFI9:
 3003              		.cfi_def_cfa 11, 4
 184:../main.c     **** 	Initialize();
 3004              		.loc 1 184 0
 3005 016c FEFFFFEB 		bl	Initialize
 185:../main.c     **** 	ADC_Init(ADC_CLK);
 3006              		.loc 1 185 0
 3007 0170 3D09A0E3 		mov	r0, #999424
 3008 0174 090D80E2 		add	r0, r0, #576
 3009 0178 FEFFFFEB 		bl	ADC_Init
 186:../main.c     **** 	UART_Init(0,9600);
 3010              		.loc 1 186 0
 3011 017c 0000A0E3 		mov	r0, #0
 3012 0180 961DA0E3 		mov	r1, #9600
 3013 0184 FEFFFFEB 		bl	UART_Init
 187:../main.c     **** 	PWM_Init();
 3014              		.loc 1 187 0
 3015 0188 FEFFFFEB 		bl	PWM_Init
 188:../main.c     **** 	GPIO_Init();
 3016              		.loc 1 188 0
 3017 018c FEFFFFEB 		bl	GPIO_Init
 189:../main.c     **** //	Timer_Init();
 190:../main.c     **** //	Timer_RegisterCallback(PWM_InterruptControl);
 191:../main.c     **** //	Timer_Enable();
 192:../main.c     **** }
 3018              		.loc 1 192 0
 3019 0190 04D04BE2 		sub	sp, fp, #4
 3020 0194 0048BDE8 		ldmfd	sp!, {fp, lr}
 3021 0198 1EFF2FE1 		bx	lr
 3022              		.cfi_endproc
 3023              	.LFE4:
 3025              		.align	2
 3026              		.global	IdleState
 3028              	IdleState:
 3029              	.LFB5:
 193:../main.c     **** 
 194:../main.c     **** /***************************************************************************************
 195:../main.c     ****  * Function Name: IdleState(void)
 196:../main.c     ****  * 		 	Type: STATE
 197:../main.c     ****  *	  Parameters:
 198:../main.c     ****  * 		 Returns:
 199:../main.c     ****  * 	 Description:
 200:../main.c     **** ***************************************************************************************/
 201:../main.c     **** STATE IdleState(void)
 202:../main.c     **** {
 3030              		.loc 1 202 0
 3031              		.cfi_startproc
 3032              		@ Function supports interworking.
 3033              		@ args = 0, pretend = 0, frame = 0
 3034              		@ frame_needed = 1, uses_anonymous_args = 0
 3035              		@ link register save eliminated.
 3036 019c 04B02DE5 		str	fp, [sp, #-4]!
 3037              	.LCFI10:
 3038              		.cfi_def_cfa_offset 4
 3039 01a0 00B08DE2 		add	fp, sp, #0
 3040              		.cfi_offset 11, -4
 3041              	.LCFI11:
 3042              		.cfi_def_cfa_register 11
 203:../main.c     **** 	return RECEIVING_DATA;
 3043              		.loc 1 203 0
 3044 01a4 0130A0E3 		mov	r3, #1
 204:../main.c     **** }
 3045              		.loc 1 204 0
 3046 01a8 0300A0E1 		mov	r0, r3
 3047 01ac 00D08BE2 		add	sp, fp, #0
 3048 01b0 0008BDE8 		ldmfd	sp!, {fp}
 3049 01b4 1EFF2FE1 		bx	lr
 3050              		.cfi_endproc
 3051              	.LFE5:
 3053              		.align	2
 3054              		.global	ReceivingDataState
 3056              	ReceivingDataState:
 3057              	.LFB6:
 205:../main.c     **** 
 206:../main.c     **** /***************************************************************************************
 207:../main.c     ****  * Function Name: ReceivingDataState(void)
 208:../main.c     ****  * 		 	Type: STATE
 209:../main.c     ****   *	  Parameters:
 210:../main.c     ****  * 		 Returns:
 211:../main.c     ****  * 	 Description:
 212:../main.c     **** ***************************************************************************************/
 213:../main.c     **** STATE ReceivingDataState(void)
 214:../main.c     **** {
 3058              		.loc 1 214 0
 3059              		.cfi_startproc
 3060              		@ Function supports interworking.
 3061              		@ args = 0, pretend = 0, frame = 0
 3062              		@ frame_needed = 1, uses_anonymous_args = 0
 3063 01b8 00482DE9 		stmfd	sp!, {fp, lr}
 3064              	.LCFI12:
 3065              		.cfi_def_cfa_offset 8
 3066 01bc 04B08DE2 		add	fp, sp, #4
 3067              		.cfi_offset 14, -4
 3068              		.cfi_offset 11, -8
 3069              	.LCFI13:
 3070              		.cfi_def_cfa 11, 4
 215:../main.c     **** 	size = UART_GetNumberAvailableElements();
 3071              		.loc 1 215 0
 3072 01c0 FEFFFFEB 		bl	UART_GetNumberAvailableElements
 3073 01c4 0020A0E1 		mov	r2, r0
 3074 01c8 70319FE5 		ldr	r3, .L12
 3075 01cc 002083E5 		str	r2, [r3, #0]
 216:../main.c     **** 	if(size >= 60)
 3076              		.loc 1 216 0
 3077 01d0 68319FE5 		ldr	r3, .L12
 3078 01d4 003093E5 		ldr	r3, [r3, #0]
 3079 01d8 3B0053E3 		cmp	r3, #59
 3080 01dc 520000DA 		ble	.L11
 217:../main.c     **** 	{
 218:../main.c     **** 		UART_ReceiveBuffer(0,buffer,60);
 3081              		.loc 1 218 0
 3082 01e0 0000A0E3 		mov	r0, #0
 3083 01e4 58119FE5 		ldr	r1, .L12+4
 3084 01e8 3C20A0E3 		mov	r2, #60
 3085 01ec FEFFFFEB 		bl	UART_ReceiveBuffer
 219:../main.c     **** 	  	memcpy(data,buffer,sizeof(int)*15);
 3086              		.loc 1 219 0
 3087 01f0 50019FE5 		ldr	r0, .L12+8
 3088 01f4 48119FE5 		ldr	r1, .L12+4
 3089 01f8 3C20A0E3 		mov	r2, #60
 3090 01fc FEFFFFEB 		bl	memcpy
 220:../main.c     **** 	  	pos[0] = data[0];
 3091              		.loc 1 220 0
 3092 0200 40319FE5 		ldr	r3, .L12+8
 3093 0204 003093E5 		ldr	r3, [r3, #0]
 3094 0208 0320A0E1 		mov	r2, r3
 3095 020c 38319FE5 		ldr	r3, .L12+12
 3096 0210 002083E5 		str	r2, [r3, #0]
 221:../main.c     **** 	  	pos[1] = data[1];
 3097              		.loc 1 221 0
 3098 0214 2C319FE5 		ldr	r3, .L12+8
 3099 0218 043093E5 		ldr	r3, [r3, #4]
 3100 021c 0320A0E1 		mov	r2, r3
 3101 0220 24319FE5 		ldr	r3, .L12+12
 3102 0224 042083E5 		str	r2, [r3, #4]
 222:../main.c     **** 	  	pos[2] = data[2];
 3103              		.loc 1 222 0
 3104 0228 18319FE5 		ldr	r3, .L12+8
 3105 022c 083093E5 		ldr	r3, [r3, #8]
 3106 0230 0320A0E1 		mov	r2, r3
 3107 0234 10319FE5 		ldr	r3, .L12+12
 3108 0238 082083E5 		str	r2, [r3, #8]
 223:../main.c     **** 	  	ort[0] = data[3];
 3109              		.loc 1 223 0
 3110 023c 04319FE5 		ldr	r3, .L12+8
 3111 0240 0C3093E5 		ldr	r3, [r3, #12]
 3112 0244 0320A0E1 		mov	r2, r3
 3113 0248 00319FE5 		ldr	r3, .L12+16
 3114 024c 002083E5 		str	r2, [r3, #0]
 224:../main.c     **** 	  	ort[1] = data[4];
 3115              		.loc 1 224 0
 3116 0250 F0309FE5 		ldr	r3, .L12+8
 3117 0254 103093E5 		ldr	r3, [r3, #16]
 3118 0258 0320A0E1 		mov	r2, r3
 3119 025c EC309FE5 		ldr	r3, .L12+16
 3120 0260 042083E5 		str	r2, [r3, #4]
 225:../main.c     **** 	  	ort[2] = data[5];
 3121              		.loc 1 225 0
 3122 0264 DC309FE5 		ldr	r3, .L12+8
 3123 0268 143093E5 		ldr	r3, [r3, #20]
 3124 026c 0320A0E1 		mov	r2, r3
 3125 0270 D8309FE5 		ldr	r3, .L12+16
 3126 0274 082083E5 		str	r2, [r3, #8]
 226:../main.c     **** 	  	kp[0] = data[6];
 3127              		.loc 1 226 0
 3128 0278 C8309FE5 		ldr	r3, .L12+8
 3129 027c 183093E5 		ldr	r3, [r3, #24]
 3130 0280 0320A0E1 		mov	r2, r3
 3131 0284 C8309FE5 		ldr	r3, .L12+20
 3132 0288 002083E5 		str	r2, [r3, #0]
 227:../main.c     **** 	  	ki[0] = data[7];
 3133              		.loc 1 227 0
 3134 028c B4309FE5 		ldr	r3, .L12+8
 3135 0290 1C3093E5 		ldr	r3, [r3, #28]
 3136 0294 0320A0E1 		mov	r2, r3
 3137 0298 B8309FE5 		ldr	r3, .L12+24
 3138 029c 002083E5 		str	r2, [r3, #0]
 228:../main.c     **** 	  	kd[0] = data[8];
 3139              		.loc 1 228 0
 3140 02a0 A0309FE5 		ldr	r3, .L12+8
 3141 02a4 203093E5 		ldr	r3, [r3, #32]
 3142 02a8 0320A0E1 		mov	r2, r3
 3143 02ac A8309FE5 		ldr	r3, .L12+28
 3144 02b0 002083E5 		str	r2, [r3, #0]
 229:../main.c     **** 	  	kp[1] = data[9];
 3145              		.loc 1 229 0
 3146 02b4 8C309FE5 		ldr	r3, .L12+8
 3147 02b8 243093E5 		ldr	r3, [r3, #36]
 3148 02bc 0320A0E1 		mov	r2, r3
 3149 02c0 8C309FE5 		ldr	r3, .L12+20
 3150 02c4 042083E5 		str	r2, [r3, #4]
 230:../main.c     **** 	  	ki[1] = data[10];
 3151              		.loc 1 230 0
 3152 02c8 78309FE5 		ldr	r3, .L12+8
 3153 02cc 283093E5 		ldr	r3, [r3, #40]
 3154 02d0 0320A0E1 		mov	r2, r3
 3155 02d4 7C309FE5 		ldr	r3, .L12+24
 3156 02d8 042083E5 		str	r2, [r3, #4]
 231:../main.c     **** 	  	kd[1] = data[11];
 3157              		.loc 1 231 0
 3158 02dc 64309FE5 		ldr	r3, .L12+8
 3159 02e0 2C3093E5 		ldr	r3, [r3, #44]
 3160 02e4 0320A0E1 		mov	r2, r3
 3161 02e8 6C309FE5 		ldr	r3, .L12+28
 3162 02ec 042083E5 		str	r2, [r3, #4]
 232:../main.c     **** 	  	kp[2] = data[12];
 3163              		.loc 1 232 0
 3164 02f0 50309FE5 		ldr	r3, .L12+8
 3165 02f4 303093E5 		ldr	r3, [r3, #48]
 3166 02f8 0320A0E1 		mov	r2, r3
 3167 02fc 50309FE5 		ldr	r3, .L12+20
 3168 0300 082083E5 		str	r2, [r3, #8]
 233:../main.c     **** 	  	ki[2] = data[13];
 3169              		.loc 1 233 0
 3170 0304 3C309FE5 		ldr	r3, .L12+8
 3171 0308 343093E5 		ldr	r3, [r3, #52]
 3172 030c 0320A0E1 		mov	r2, r3
 3173 0310 40309FE5 		ldr	r3, .L12+24
 3174 0314 082083E5 		str	r2, [r3, #8]
 234:../main.c     **** 	  	kd[2] = data[14];
 3175              		.loc 1 234 0
 3176 0318 28309FE5 		ldr	r3, .L12+8
 3177 031c 383093E5 		ldr	r3, [r3, #56]
 3178 0320 0320A0E1 		mov	r2, r3
 3179 0324 30309FE5 		ldr	r3, .L12+28
 3180 0328 082083E5 		str	r2, [r3, #8]
 3181              	.L11:
 235:../main.c     **** 	}
 236:../main.c     **** 	return SENDING_DATA;
 3182              		.loc 1 236 0
 3183 032c 0230A0E3 		mov	r3, #2
 237:../main.c     **** }
 3184              		.loc 1 237 0
 3185 0330 0300A0E1 		mov	r0, r3
 3186 0334 04D04BE2 		sub	sp, fp, #4
 3187 0338 0048BDE8 		ldmfd	sp!, {fp, lr}
 3188 033c 1EFF2FE1 		bx	lr
 3189              	.L13:
 3190              		.align	2
 3191              	.L12:
 3192 0340 00000000 		.word	size
 3193 0344 00000000 		.word	buffer
 3194 0348 00000000 		.word	data
 3195 034c 00000000 		.word	pos
 3196 0350 00000000 		.word	ort
 3197 0354 00000000 		.word	kp
 3198 0358 00000000 		.word	ki
 3199 035c 00000000 		.word	kd
 3200              		.cfi_endproc
 3201              	.LFE6:
 3203              		.align	2
 3204              		.global	SendingDataState
 3206              	SendingDataState:
 3207              	.LFB7:
 238:../main.c     **** 
 239:../main.c     **** /***************************************************************************************
 240:../main.c     ****  * Function Name: SendingData(void)
 241:../main.c     ****  * 		 	Type: STATE
 242:../main.c     ****   *	  Parameters:
 243:../main.c     ****  * 		 Returns:
 244:../main.c     ****  * 	 Description:
 245:../main.c     **** ***************************************************************************************/
 246:../main.c     **** STATE SendingDataState(void)
 247:../main.c     **** {
 3208              		.loc 1 247 0
 3209              		.cfi_startproc
 3210              		@ Function supports interworking.
 3211              		@ args = 0, pretend = 0, frame = 0
 3212              		@ frame_needed = 1, uses_anonymous_args = 0
 3213              		@ link register save eliminated.
 3214 0360 04B02DE5 		str	fp, [sp, #-4]!
 3215              	.LCFI14:
 3216              		.cfi_def_cfa_offset 4
 3217 0364 00B08DE2 		add	fp, sp, #0
 3218              		.cfi_offset 11, -4
 3219              	.LCFI15:
 3220              		.cfi_def_cfa_register 11
 248:../main.c     **** //	static int count_sending_data = 0;
 249:../main.c     **** //
 250:../main.c     **** //	if(count_sending_data == 250000)
 251:../main.c     **** //	{
 252:../main.c     **** //		adc[0] = ADC0Read(3);
 253:../main.c     **** //		adc[1] = ADC0Read(1);
 254:../main.c     **** //		adc[2] = ADC0Read(2);
 255:../main.c     **** //		//UART_SendBuffer(0,adc,(sizeof(unsigned long))*3);
 256:../main.c     **** //		//iprintf("GDL2: %d %d %d \r\n",pos[1], adc[1], e[1]);
 257:../main.c     **** //		iprintf("GDL3: POS %d ADC %d ERRO %d \r\n",pos[2], adc[2], e[2]);
 258:../main.c     **** //		//iprintf("ADC: %d %d %d \r\n",adc[0], adc[1], adc[2]);
 259:../main.c     **** //		count_sending_data = 0;
 260:../main.c     **** //	}
 261:../main.c     **** //	count_sending_data++;
 262:../main.c     **** 	return CONTROLLER;
 3221              		.loc 1 262 0
 3222 0368 0330A0E3 		mov	r3, #3
 263:../main.c     **** }
 3223              		.loc 1 263 0
 3224 036c 0300A0E1 		mov	r0, r3
 3225 0370 00D08BE2 		add	sp, fp, #0
 3226 0374 0008BDE8 		ldmfd	sp!, {fp}
 3227 0378 1EFF2FE1 		bx	lr
 3228              		.cfi_endproc
 3229              	.LFE7:
 3231              		.align	2
 3232              		.global	Controller
 3234              	Controller:
 3235              	.LFB8:
 264:../main.c     **** /***************************************************************************************
 265:../main.c     ****  * Function Name: Controller(void)
 266:../main.c     ****  * 		 	Type: STATE
 267:../main.c     ****  *	  Parameters:
 268:../main.c     ****  * 		 Returns:
 269:../main.c     ****  * 	 Description:
 270:../main.c     **** ***************************************************************************************/
 271:../main.c     **** STATE Controller(void)
 272:../main.c     **** {
 3236              		.loc 1 272 0
 3237              		.cfi_startproc
 3238              		@ Function supports interworking.
 3239              		@ args = 0, pretend = 0, frame = 0
 3240              		@ frame_needed = 1, uses_anonymous_args = 0
 3241 037c 00482DE9 		stmfd	sp!, {fp, lr}
 3242              	.LCFI16:
 3243              		.cfi_def_cfa_offset 8
 3244 0380 04B08DE2 		add	fp, sp, #4
 3245              		.cfi_offset 14, -4
 3246              		.cfi_offset 11, -8
 3247              	.LCFI17:
 3248              		.cfi_def_cfa 11, 4
 273:../main.c     **** //	if((pos[0]>adc[0]) || adc[0] < 50)
 274:../main.c     **** //	{
 275:../main.c     **** //		IOCLR0 = (1<<22);
 276:../main.c     **** //		IOSET0 = (1<<23);
 277:../main.c     **** //		e[0] = pos[0] - adc[0];
 278:../main.c     **** //	}
 279:../main.c     **** //	if((pos[0]<adc[0]) || adc[0] > 970)
 280:../main.c     **** //	{
 281:../main.c     **** //		IOCLR0 = (1<<23);
 282:../main.c     **** //		IOSET0 = (1<<22);
 283:../main.c     **** //		e[0] = adc[0] - pos[0];
 284:../main.c     **** //	}
 285:../main.c     **** //	setDutyCycle(5,(unsigned int)1020);  //DOF 1
 286:../main.c     **** 
 287:../main.c     **** //	if((pos[1]>adc[1]) || adc[1] < 50)
 288:../main.c     **** //	{
 289:../main.c     **** //		IOCLR0 = (1<<17);
 290:../main.c     **** //		IOSET0 = (1<<19);
 291:../main.c     **** //		e[1] = pos[1] - adc[1];
 292:../main.c     **** //	}
 293:../main.c     **** //	if((pos[1]<adc[1]) || adc[1] > 970)
 294:../main.c     **** //	{
 295:../main.c     **** //		IOCLR0 = (1<<19);
 296:../main.c     **** //		IOSET0 = (1<<17);
 297:../main.c     **** //		e[1] = adc[1] - pos[1];
 298:../main.c     **** //	}
 299:../main.c     **** //	setDutyCycle(4,e[1]);  //DOF 2
 300:../main.c     **** 
 301:../main.c     **** 	if((pos[2]>adc[2]) || adc[2] < 50)
 3249              		.loc 1 301 0
 3250 0384 F0309FE5 		ldr	r3, .L20
 3251 0388 082093E5 		ldr	r2, [r3, #8]
 3252 038c EC309FE5 		ldr	r3, .L20+4
 3253 0390 083093E5 		ldr	r3, [r3, #8]
 3254 0394 030052E1 		cmp	r2, r3
 3255 0398 0300008A 		bhi	.L16
 3256              		.loc 1 301 0 is_stmt 0 discriminator 1
 3257 039c DC309FE5 		ldr	r3, .L20+4
 3258 03a0 083093E5 		ldr	r3, [r3, #8]
 3259 03a4 310053E3 		cmp	r3, #49
 3260 03a8 0E00008A 		bhi	.L17
 3261              	.L16:
 302:../main.c     **** 	{
 303:../main.c     **** 		IOCLR0 = (1<<6);
 3262              		.loc 1 303 0 is_stmt 1
 3263 03ac CE32A0E3 		mov	r3, #-536870900
 3264 03b0 0A3983E2 		add	r3, r3, #163840
 3265 03b4 4020A0E3 		mov	r2, #64
 3266 03b8 002083E5 		str	r2, [r3, #0]
 304:../main.c     **** 		IOSET0 = (1<<9);
 3267              		.loc 1 304 0
 3268 03bc 4E32A0E3 		mov	r3, #-536870908
 3269 03c0 0A3983E2 		add	r3, r3, #163840
 3270 03c4 022CA0E3 		mov	r2, #512
 3271 03c8 002083E5 		str	r2, [r3, #0]
 305:../main.c     **** 		e[2] = pos[2] - adc[2];
 3272              		.loc 1 305 0
 3273 03cc A8309FE5 		ldr	r3, .L20
 3274 03d0 082093E5 		ldr	r2, [r3, #8]
 3275 03d4 A4309FE5 		ldr	r3, .L20+4
 3276 03d8 083093E5 		ldr	r3, [r3, #8]
 3277 03dc 022063E0 		rsb	r2, r3, r2
 3278 03e0 9C309FE5 		ldr	r3, .L20+8
 3279 03e4 082083E5 		str	r2, [r3, #8]
 3280              	.L17:
 306:../main.c     **** 	}
 307:../main.c     **** 	if((pos[2]<adc[2]) || adc[2] > 970)
 3281              		.loc 1 307 0
 3282 03e8 8C309FE5 		ldr	r3, .L20
 3283 03ec 082093E5 		ldr	r2, [r3, #8]
 3284 03f0 88309FE5 		ldr	r3, .L20+4
 3285 03f4 083093E5 		ldr	r3, [r3, #8]
 3286 03f8 030052E1 		cmp	r2, r3
 3287 03fc 0500003A 		bcc	.L18
 3288              		.loc 1 307 0 is_stmt 0 discriminator 1
 3289 0400 78309FE5 		ldr	r3, .L20+4
 3290 0404 082093E5 		ldr	r2, [r3, #8]
 3291 0408 F23FA0E3 		mov	r3, #968
 3292 040c 023083E2 		add	r3, r3, #2
 3293 0410 030052E1 		cmp	r2, r3
 3294 0414 0E00009A 		bls	.L19
 3295              	.L18:
 308:../main.c     **** 	{
 309:../main.c     **** 		IOCLR0 = (1<<9);
 3296              		.loc 1 309 0 is_stmt 1
 3297 0418 CE32A0E3 		mov	r3, #-536870900
 3298 041c 0A3983E2 		add	r3, r3, #163840
 3299 0420 022CA0E3 		mov	r2, #512
 3300 0424 002083E5 		str	r2, [r3, #0]
 310:../main.c     **** 		IOSET0 = (1<<6);
 3301              		.loc 1 310 0
 3302 0428 4E32A0E3 		mov	r3, #-536870908
 3303 042c 0A3983E2 		add	r3, r3, #163840
 3304 0430 4020A0E3 		mov	r2, #64
 3305 0434 002083E5 		str	r2, [r3, #0]
 311:../main.c     **** 		e[2] = adc[2] - pos[2];
 3306              		.loc 1 311 0
 3307 0438 40309FE5 		ldr	r3, .L20+4
 3308 043c 082093E5 		ldr	r2, [r3, #8]
 3309 0440 34309FE5 		ldr	r3, .L20
 3310 0444 083093E5 		ldr	r3, [r3, #8]
 3311 0448 022063E0 		rsb	r2, r3, r2
 3312 044c 30309FE5 		ldr	r3, .L20+8
 3313 0450 082083E5 		str	r2, [r3, #8]
 3314              	.L19:
 312:../main.c     **** 	}
 313:../main.c     **** 
 314:../main.c     **** 	setDutyCycle(2,e[2]);  //DOF 3
 3315              		.loc 1 314 0
 3316 0454 28309FE5 		ldr	r3, .L20+8
 3317 0458 083093E5 		ldr	r3, [r3, #8]
 3318 045c 0200A0E3 		mov	r0, #2
 3319 0460 0310A0E1 		mov	r1, r3
 3320 0464 FEFFFFEB 		bl	setDutyCycle
 315:../main.c     **** 
 316:../main.c     **** 	return IDLE;
 3321              		.loc 1 316 0
 3322 0468 0030A0E3 		mov	r3, #0
 317:../main.c     **** }
 3323              		.loc 1 317 0
 3324 046c 0300A0E1 		mov	r0, r3
 3325 0470 04D04BE2 		sub	sp, fp, #4
 3326 0474 0048BDE8 		ldmfd	sp!, {fp, lr}
 3327 0478 1EFF2FE1 		bx	lr
 3328              	.L21:
 3329              		.align	2
 3330              	.L20:
 3331 047c 00000000 		.word	pos
 3332 0480 00000000 		.word	adc
 3333 0484 00000000 		.word	e
 3334              		.cfi_endproc
 3335              	.LFE8:
 3337              		.align	2
 3338              		.global	main
 3340              	main:
 3341              	.LFB9:
 318:../main.c     **** 
 319:../main.c     **** /***************************************************************************************
 320:../main.c     ****  * Function Name: main(void)
 321:../main.c     ****  * 		 	Type: Integer
 322:../main.c     ****  *	  Parameters:
 323:../main.c     ****  * 		 Returns: 0
 324:../main.c     ****  * 	 Description: Main function for firmware
 325:../main.c     **** ***************************************************************************************/
 326:../main.c     **** int main (void)
 327:../main.c     **** {
 3342              		.loc 1 327 0
 3343              		.cfi_startproc
 3344              		@ Function supports interworking.
 3345              		@ args = 0, pretend = 0, frame = 8
 3346              		@ frame_needed = 1, uses_anonymous_args = 0
 3347 0488 00482DE9 		stmfd	sp!, {fp, lr}
 3348              	.LCFI18:
 3349              		.cfi_def_cfa_offset 8
 3350 048c 04B08DE2 		add	fp, sp, #4
 3351              		.cfi_offset 14, -4
 3352              		.cfi_offset 11, -8
 3353              	.LCFI19:
 3354              		.cfi_def_cfa 11, 4
 3355 0490 08D04DE2 		sub	sp, sp, #8
 328:../main.c     **** 	STATE nextState = IDLE; //Creates a variable of STATE type, and attributes its initial value
 3356              		.loc 1 328 0
 3357 0494 0030A0E3 		mov	r3, #0
 3358 0498 05304BE5 		strb	r3, [fp, #-5]
 329:../main.c     **** 	Modules_Init(); //Calls function Modules_Init()
 3359              		.loc 1 329 0
 3360 049c FEFFFFEB 		bl	Modules_Init
 3361 04a0 000000EA 		b	.L29
 3362              	.L30:
 330:../main.c     **** 
 331:../main.c     **** 	while (1)
 332:../main.c     **** 	{
 333:../main.c     **** 		switch(nextState)
 334:../main.c     **** 		{
 335:../main.c     **** 			case IDLE:
 336:../main.c     **** 				nextState = IdleState();
 337:../main.c     **** 			case RECEIVING_DATA:
 338:../main.c     **** 				nextState = ReceivingDataState();
 339:../main.c     **** 			case SENDING_DATA:
 340:../main.c     **** 				nextState = SendingDataState();
 341:../main.c     **** 			case CONTROLLER:
 342:../main.c     **** 				nextState = Controller();
 343:../main.c     **** 		}
 344:../main.c     **** 	}
 3363              		.loc 1 344 0
 3364 04a4 0000A0E1 		mov	r0, r0	@ nop
 3365              	.L29:
 333:../main.c     **** 		switch(nextState)
 3366              		.loc 1 333 0
 3367 04a8 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 3368 04ac 030053E3 		cmp	r3, #3
 3369 04b0 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 3370 04b4 FAFFFFEA 		b	.L30
 3371              	.L28:
 3372 04b8 C8040000 		.word	.L24
 3373 04bc D4040000 		.word	.L25
 3374 04c0 E0040000 		.word	.L26
 3375 04c4 EC040000 		.word	.L27
 3376              	.L24:
 336:../main.c     **** 				nextState = IdleState();
 3377              		.loc 1 336 0
 3378 04c8 FEFFFFEB 		bl	IdleState
 3379 04cc 0030A0E1 		mov	r3, r0
 3380 04d0 05304BE5 		strb	r3, [fp, #-5]
 3381              	.L25:
 338:../main.c     **** 				nextState = ReceivingDataState();
 3382              		.loc 1 338 0
 3383 04d4 FEFFFFEB 		bl	ReceivingDataState
 3384 04d8 0030A0E1 		mov	r3, r0
 3385 04dc 05304BE5 		strb	r3, [fp, #-5]
 3386              	.L26:
 340:../main.c     **** 				nextState = SendingDataState();
 3387              		.loc 1 340 0
 3388 04e0 FEFFFFEB 		bl	SendingDataState
 3389 04e4 0030A0E1 		mov	r3, r0
 3390 04e8 05304BE5 		strb	r3, [fp, #-5]
 3391              	.L27:
 342:../main.c     **** 				nextState = Controller();
 3392              		.loc 1 342 0
 3393 04ec FEFFFFEB 		bl	Controller
 3394 04f0 0030A0E1 		mov	r3, r0
 3395 04f4 05304BE5 		strb	r3, [fp, #-5]
 3396              		.loc 1 344 0
 3397 04f8 EAFFFFEA 		b	.L29
 3398              		.cfi_endproc
 3399              	.LFE9:
 3401              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:2724   .bss:00000000 size
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:2721   .bss:00000000 $d
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:2730   .bss:00000004 data
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:2736   .bss:00000040 buffer
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:2742   .bss:000000a4 adc
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:2748   .bss:000000b0 pos
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:2754   .bss:000000bc kp
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:2760   .bss:000000c8 ki
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:2766   .bss:000000d4 kd
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:2772   .bss:000000e0 ort
                            *COM*:0000000c e
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:2776   .text:00000000 $a
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:2779   .text:00000000 PWM_InterruptControl
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:2803   .text:00000014 feed
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:2840   .text:00000050 delay
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:2913   .text:000000b4 Initialize
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:2989   .text:00000164 Modules_Init
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:3028   .text:0000019c IdleState
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:3056   .text:000001b8 ReceivingDataState
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:3192   .text:00000340 $d
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:3203   .text:00000360 $a
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:3206   .text:00000360 SendingDataState
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:3234   .text:0000037c Controller
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:3331   .text:0000047c $d
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:3337   .text:00000488 $a
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:3340   .text:00000488 main
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:3372   .text:000004b8 $d
C:\Users\Daniel\AppData\Local\Temp\ccVdfykj.s:3378   .text:000004c8 $a
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
ADC_Init
UART_Init
PWM_Init
GPIO_Init
UART_GetNumberAvailableElements
UART_ReceiveBuffer
memcpy
setDutyCycle
