
LPC214x_USB.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000033c8  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  40000200  000033c8  00010200  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000d4  40000208  000033d0  00010208  2**2
                  ALLOC
  3 .ARM.attributes 00000030  00000000  00000000  00010208  2**0
                  CONTENTS, READONLY
  4 .comment      0000002a  00000000  00000000  00010238  2**0
                  CONTENTS, READONLY
  5 .debug_line   00000e82  00000000  00000000  00010262  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000194b  00000000  00000000  000110e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000967  00000000  00000000  00012a2f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 00000160  00000000  00000000  00013398  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_macinfo 00028d23  00000000  00000000  000134f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000b38  00000000  00000000  0003c21b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_pubnames 000003ea  00000000  00000000  0003cd53  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000007f9  00000000  00000000  0003d13d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00000910  00000000  00000000  0003d938  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_pubtypes 000001ed  00000000  00000000  0003e248  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_startup>:

_startup:

# Exception Vectors

_vectors:       ldr     PC, Reset_Addr
       0:	e59ff018 	ldr	pc, [pc, #24]	; 20 <Reset_Addr>
                ldr     PC, Undef_Addr
       4:	e59ff018 	ldr	pc, [pc, #24]	; 24 <Undef_Addr>
                ldr     PC, SWI_Addr
       8:	e59ff018 	ldr	pc, [pc, #24]	; 28 <SWI_Addr>
                ldr     PC, PAbt_Addr
       c:	e59ff018 	ldr	pc, [pc, #24]	; 2c <PAbt_Addr>
                ldr     PC, DAbt_Addr
      10:	e59ff018 	ldr	pc, [pc, #24]	; 30 <DAbt_Addr>
                nop							/* Reserved Vector (holds Philips ISP checksum) */
      14:	e1a00000 	nop			; (mov r0, r0)
                ldr     PC, [PC,#-0xFF0]	/* see page 71 of "Insiders Guide to the Philips ARM7-Based Microcontrollers" by Trevor Martin  */
      18:	e51ffff0 	ldr	pc, [pc, #-4080]	; fffff030 <_stack_end+0xbfff7154>
                ldr     PC, FIQ_Addr
      1c:	e59ff014 	ldr	pc, [pc, #20]	; 38 <FIQ_Addr>

00000020 <Reset_Addr>:
      20:	00000040 	.word	0x00000040

00000024 <Undef_Addr>:
      24:	00000ed4 	.word	0x00000ed4

00000028 <SWI_Addr>:
      28:	00000ec8 	.word	0x00000ec8

0000002c <PAbt_Addr>:
      2c:	00000ed4 	.word	0x00000ed4

00000030 <DAbt_Addr>:
      30:	00000ed4 	.word	0x00000ed4

00000034 <IRQ_Addr>:
      34:	00000eb4 	.word	0x00000eb4

00000038 <FIQ_Addr>:
      38:	00000ec0 	.word	0x00000ec0
      3c:	00000000 	.word	0x00000000

00000040 <Reset_Handler>:
Reset_Handler:

				/* Setup a stack for each mode - note that this only sets up a usable stack
				for User mode.   Also each mode is setup with interrupts initially disabled. */

    			ldr   r0, =_stack_end
      40:	e59f0078 	ldr	r0, [pc, #120]	; c0 <I_BIT+0x40>
    			msr   CPSR_c, #MODE_UND|I_BIT|F_BIT 	/* Undefined Instruction Mode  */
      44:	e321f0db 	msr	CPSR_c, #219	; 0xdb
    			mov   sp, r0
      48:	e1a0d000 	mov	sp, r0
    			sub   r0, r0, #UND_STACK_SIZE
      4c:	e2400040 	sub	r0, r0, #64	; 0x40
    			msr   CPSR_c, #MODE_ABT|I_BIT|F_BIT 	/* Abort Mode */
      50:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
    			mov   sp, r0
      54:	e1a0d000 	mov	sp, r0
    			sub   r0, r0, #ABT_STACK_SIZE
      58:	e2400040 	sub	r0, r0, #64	; 0x40
    			msr   CPSR_c, #MODE_FIQ|I_BIT|F_BIT 	/* FIQ Mode */
      5c:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
    			mov   sp, r0
      60:	e1a0d000 	mov	sp, r0
   				sub   r0, r0, #FIQ_STACK_SIZE
      64:	e2400040 	sub	r0, r0, #64	; 0x40
    			msr   CPSR_c, #MODE_IRQ|I_BIT|F_BIT 	/* IRQ Mode */
      68:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
    			mov   sp, r0
      6c:	e1a0d000 	mov	sp, r0
    			sub   r0, r0, #IRQ_STACK_SIZE
      70:	e2400c01 	sub	r0, r0, #256	; 0x100
    			msr   CPSR_c, #MODE_SVC|I_BIT|F_BIT 	/* Supervisor Mode */
      74:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
    			mov   sp, r0
      78:	e1a0d000 	mov	sp, r0
    			sub   r0, r0, #SVC_STACK_SIZE
      7c:	e2400b01 	sub	r0, r0, #1024	; 0x400
    			msr   CPSR_c, #MODE_SYS|I_BIT|F_BIT 	/* User Mode */
      80:	e321f0df 	msr	CPSR_c, #223	; 0xdf
    			mov   sp, r0
      84:	e1a0d000 	mov	sp, r0

				/* copy .data section (Copy from ROM to RAM) */
                ldr     R1, =_etext
      88:	e59f1034 	ldr	r1, [pc, #52]	; c4 <I_BIT+0x44>
                ldr     R2, =_data
      8c:	e59f2034 	ldr	r2, [pc, #52]	; c8 <I_BIT+0x48>
                ldr     R3, =_edata
      90:	e59f3034 	ldr	r3, [pc, #52]	; cc <I_BIT+0x4c>
1:        		cmp     R2, R3
      94:	e1520003 	cmp	r2, r3
                ldrlo   R0, [R1], #4
      98:	34910004 	ldrcc	r0, [r1], #4
                strlo   R0, [R2], #4
      9c:	34820004 	strcc	r0, [r2], #4
                blo     1b
      a0:	3afffffb 	bcc	94 <I_BIT+0x14>

				/* Clear .bss section (Zero init)  */
                mov     R0, #0
      a4:	e3a00000 	mov	r0, #0
                ldr     R1, =_bss_start
      a8:	e59f1020 	ldr	r1, [pc, #32]	; d0 <I_BIT+0x50>
                ldr     R2, =_bss_end
      ac:	e59f2020 	ldr	r2, [pc, #32]	; d4 <I_BIT+0x54>
2:				cmp     R1, R2
      b0:	e1510002 	cmp	r1, r2
                strlo   R0, [R1], #4
      b4:	34810004 	strcc	r0, [r1], #4
                blo     2b
      b8:	3afffffc 	bcc	b0 <I_BIT+0x30>

				/* Enter the C code  */
                b       main
      bc:	ea000339 	b	da8 <main>
      c0:	40007edc 	.word	0x40007edc
      c4:	000033c8 	.word	0x000033c8
      c8:	40000200 	.word	0x40000200
      cc:	40000208 	.word	0x40000208
      d0:	40000208 	.word	0x40000208
      d4:	400002dc 	.word	0x400002dc

000000d8 <delay_ms>:
 *      Author: Fábio
 */

//---------------------------------------------------------------------
void delay_ms(int x)
{
      d8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
      dc:	e28db000 	add	fp, sp, #0
      e0:	e24dd014 	sub	sp, sp, #20
      e4:	e50b0010 	str	r0, [fp, #-16]
	int a,b;
	for(a=0;a<x;a++){
      e8:	e3a03000 	mov	r3, #0
      ec:	e50b3008 	str	r3, [fp, #-8]
      f0:	ea00000c 	b	128 <IRQ_STACK_SIZE+0x28>
		for(b=0;b<3500;b++);
      f4:	e3a03000 	mov	r3, #0
      f8:	e50b300c 	str	r3, [fp, #-12]
      fc:	ea000002 	b	10c <IRQ_STACK_SIZE+0xc>
     100:	e51b300c 	ldr	r3, [fp, #-12]
     104:	e2833001 	add	r3, r3, #1
     108:	e50b300c 	str	r3, [fp, #-12]
     10c:	e51b200c 	ldr	r2, [fp, #-12]
     110:	e59f302c 	ldr	r3, [pc, #44]	; 144 <IRQ_STACK_SIZE+0x44>
     114:	e1520003 	cmp	r2, r3
     118:	dafffff8 	ble	100 <IRQ_STACK_SIZE>

//---------------------------------------------------------------------
void delay_ms(int x)
{
	int a,b;
	for(a=0;a<x;a++){
     11c:	e51b3008 	ldr	r3, [fp, #-8]
     120:	e2833001 	add	r3, r3, #1
     124:	e50b3008 	str	r3, [fp, #-8]
     128:	e51b2008 	ldr	r2, [fp, #-8]
     12c:	e51b3010 	ldr	r3, [fp, #-16]
     130:	e1520003 	cmp	r2, r3
     134:	baffffee 	blt	f4 <delay_ms+0x1c>
		for(b=0;b<3500;b++);
	}
}
     138:	e28bd000 	add	sp, fp, #0
     13c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
     140:	e12fff1e 	bx	lr
     144:	00000dab 	.word	0x00000dab

00000148 <delay_us>:
//---------------------------------------------------------------------
void delay_us(int x)
{
     148:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
     14c:	e28db000 	add	fp, sp, #0
     150:	e24dd014 	sub	sp, sp, #20
     154:	e50b0010 	str	r0, [fp, #-16]
	int a,b;
	for(a=0;a<x;a++){
     158:	e3a03000 	mov	r3, #0
     15c:	e50b3008 	str	r3, [fp, #-8]
     160:	ea00000b 	b	194 <delay_us+0x4c>
		for(b=0;b<4;b++);
     164:	e3a03000 	mov	r3, #0
     168:	e50b300c 	str	r3, [fp, #-12]
     16c:	ea000002 	b	17c <delay_us+0x34>
     170:	e51b300c 	ldr	r3, [fp, #-12]
     174:	e2833001 	add	r3, r3, #1
     178:	e50b300c 	str	r3, [fp, #-12]
     17c:	e51b300c 	ldr	r3, [fp, #-12]
     180:	e3530003 	cmp	r3, #3
     184:	dafffff9 	ble	170 <delay_us+0x28>
}
//---------------------------------------------------------------------
void delay_us(int x)
{
	int a,b;
	for(a=0;a<x;a++){
     188:	e51b3008 	ldr	r3, [fp, #-8]
     18c:	e2833001 	add	r3, r3, #1
     190:	e50b3008 	str	r3, [fp, #-8]
     194:	e51b2008 	ldr	r2, [fp, #-8]
     198:	e51b3010 	ldr	r3, [fp, #-16]
     19c:	e1520003 	cmp	r2, r3
     1a0:	baffffef 	blt	164 <delay_us+0x1c>
		for(b=0;b<4;b++);
}
}
     1a4:	e28bd000 	add	sp, fp, #0
     1a8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
     1ac:	e12fff1e 	bx	lr

000001b0 <printchar>:

int iprintf(const char *format, ...);
int isprintf(char *out, const char *format, ...);

static void printchar(char **str, int c)
{
     1b0:	e92d4800 	push	{fp, lr}
     1b4:	e28db004 	add	fp, sp, #4
     1b8:	e24dd008 	sub	sp, sp, #8
     1bc:	e50b0008 	str	r0, [fp, #-8]
     1c0:	e50b100c 	str	r1, [fp, #-12]
	if (str) {
     1c4:	e51b3008 	ldr	r3, [fp, #-8]
     1c8:	e3530000 	cmp	r3, #0
     1cc:	0a00000a 	beq	1fc <printchar+0x4c>
		**str = c;
     1d0:	e51b3008 	ldr	r3, [fp, #-8]
     1d4:	e5933000 	ldr	r3, [r3]
     1d8:	e51b200c 	ldr	r2, [fp, #-12]
     1dc:	e20220ff 	and	r2, r2, #255	; 0xff
     1e0:	e5c32000 	strb	r2, [r3]
		++(*str);
     1e4:	e51b3008 	ldr	r3, [fp, #-8]
     1e8:	e5933000 	ldr	r3, [r3]
     1ec:	e2832001 	add	r2, r3, #1
     1f0:	e51b3008 	ldr	r3, [fp, #-8]
     1f4:	e5832000 	str	r2, [r3]
     1f8:	ea000003 	b	20c <printchar+0x5c>
	}
	else {
//	  WriteChar_USART0(c);
//		lcd_char(c);
	  UART_putc(c);
     1fc:	e51b300c 	ldr	r3, [fp, #-12]
     200:	e20330ff 	and	r3, r3, #255	; 0xff
     204:	e1a00003 	mov	r0, r3
     208:	eb0003c0 	bl	1110 <UART_putc>
	}
}
     20c:	e24bd004 	sub	sp, fp, #4
     210:	e8bd4800 	pop	{fp, lr}
     214:	e12fff1e 	bx	lr

00000218 <prints>:

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
     218:	e92d48f0 	push	{r4, r5, r6, r7, fp, lr}
     21c:	e28db014 	add	fp, sp, #20
     220:	e24dd010 	sub	sp, sp, #16
     224:	e50b0018 	str	r0, [fp, #-24]	; 0xffffffe8
     228:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
     22c:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
     230:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
	register int pc = 0, padchar = ' ';
     234:	e3a04000 	mov	r4, #0
     238:	e3a06020 	mov	r6, #32

	if (width > 0) {
     23c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
     240:	e3530000 	cmp	r3, #0
     244:	da000015 	ble	2a0 <prints+0x88>
		register int len = 0;
     248:	e3a05000 	mov	r5, #0
		register const char *ptr;
		for (ptr = string; *ptr; ++ptr) ++len;
     24c:	e51b701c 	ldr	r7, [fp, #-28]	; 0xffffffe4
     250:	ea000001 	b	25c <prints+0x44>
     254:	e2855001 	add	r5, r5, #1
     258:	e2877001 	add	r7, r7, #1
     25c:	e5d73000 	ldrb	r3, [r7]
     260:	e3530000 	cmp	r3, #0
     264:	1afffffa 	bne	254 <prints+0x3c>
		if (len >= width) width = 0;
     268:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
     26c:	e1550003 	cmp	r5, r3
     270:	ba000002 	blt	280 <prints+0x68>
     274:	e3a03000 	mov	r3, #0
     278:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
     27c:	ea000002 	b	28c <prints+0x74>
		else width -= len;
     280:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
     284:	e0653003 	rsb	r3, r5, r3
     288:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
		if (pad & PAD_ZERO) padchar = '0';
     28c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     290:	e2033002 	and	r3, r3, #2
     294:	e3530000 	cmp	r3, #0
     298:	0a000000 	beq	2a0 <prints+0x88>
     29c:	e3a06030 	mov	r6, #48	; 0x30
	}
	if (!(pad & PAD_RIGHT)) {
     2a0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     2a4:	e2033001 	and	r3, r3, #1
     2a8:	e3530000 	cmp	r3, #0
     2ac:	1a000015 	bne	308 <prints+0xf0>
		for ( ; width > 0; --width) {
     2b0:	ea000006 	b	2d0 <prints+0xb8>
			printchar (out, padchar);
     2b4:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
     2b8:	e1a01006 	mov	r1, r6
     2bc:	ebffffbb 	bl	1b0 <printchar>
			++pc;
     2c0:	e2844001 	add	r4, r4, #1
		if (len >= width) width = 0;
		else width -= len;
		if (pad & PAD_ZERO) padchar = '0';
	}
	if (!(pad & PAD_RIGHT)) {
		for ( ; width > 0; --width) {
     2c4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
     2c8:	e2433001 	sub	r3, r3, #1
     2cc:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
     2d0:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
     2d4:	e3530000 	cmp	r3, #0
     2d8:	cafffff5 	bgt	2b4 <prints+0x9c>
			printchar (out, padchar);
			++pc;
		}
	}
	for ( ; *string ; ++string) {
     2dc:	ea00000a 	b	30c <prints+0xf4>
		printchar (out, *string);
     2e0:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
     2e4:	e5d33000 	ldrb	r3, [r3]
     2e8:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
     2ec:	e1a01003 	mov	r1, r3
     2f0:	ebffffae 	bl	1b0 <printchar>
		++pc;
     2f4:	e2844001 	add	r4, r4, #1
		for ( ; width > 0; --width) {
			printchar (out, padchar);
			++pc;
		}
	}
	for ( ; *string ; ++string) {
     2f8:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
     2fc:	e2833001 	add	r3, r3, #1
     300:	e50b301c 	str	r3, [fp, #-28]	; 0xffffffe4
     304:	ea000000 	b	30c <prints+0xf4>
     308:	e1a00000 	nop			; (mov r0, r0)
     30c:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
     310:	e5d33000 	ldrb	r3, [r3]
     314:	e3530000 	cmp	r3, #0
     318:	1afffff0 	bne	2e0 <prints+0xc8>
		printchar (out, *string);
		++pc;
	}
	for ( ; width > 0; --width) {
     31c:	ea000006 	b	33c <prints+0x124>
		printchar (out, padchar);
     320:	e51b0018 	ldr	r0, [fp, #-24]	; 0xffffffe8
     324:	e1a01006 	mov	r1, r6
     328:	ebffffa0 	bl	1b0 <printchar>
		++pc;
     32c:	e2844001 	add	r4, r4, #1
	}
	for ( ; *string ; ++string) {
		printchar (out, *string);
		++pc;
	}
	for ( ; width > 0; --width) {
     330:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
     334:	e2433001 	sub	r3, r3, #1
     338:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
     33c:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
     340:	e3530000 	cmp	r3, #0
     344:	cafffff5 	bgt	320 <prints+0x108>
		printchar (out, padchar);
		++pc;
	}

	return pc;
     348:	e1a03004 	mov	r3, r4
}
     34c:	e1a00003 	mov	r0, r3
     350:	e24bd014 	sub	sp, fp, #20
     354:	e8bd48f0 	pop	{r4, r5, r6, r7, fp, lr}
     358:	e12fff1e 	bx	lr

0000035c <printi>:

/* the following should be enough for 32 bit int */
#define PRINT_BUF_LEN 12

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
     35c:	e92d49f0 	push	{r4, r5, r6, r7, r8, fp, lr}
     360:	e28db018 	add	fp, sp, #24
     364:	e24dd024 	sub	sp, sp, #36	; 0x24
     368:	e50b0030 	str	r0, [fp, #-48]	; 0xffffffd0
     36c:	e50b1034 	str	r1, [fp, #-52]	; 0xffffffcc
     370:	e50b2038 	str	r2, [fp, #-56]	; 0xffffffc8
     374:	e50b303c 	str	r3, [fp, #-60]	; 0xffffffc4
	char print_buf[PRINT_BUF_LEN];
	register char *s;
	register int t, neg = 0, pc = 0;
     378:	e3a08000 	mov	r8, #0
     37c:	e3a07000 	mov	r7, #0
	register unsigned int u = i;
     380:	e51b5034 	ldr	r5, [fp, #-52]	; 0xffffffcc

	if (i == 0) {
     384:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
     388:	e3530000 	cmp	r3, #0
     38c:	1a00000b 	bne	3c0 <printi+0x64>
		print_buf[0] = '0';
     390:	e3a03030 	mov	r3, #48	; 0x30
     394:	e54b3028 	strb	r3, [fp, #-40]	; 0xffffffd8
		print_buf[1] = '\0';
     398:	e3a03000 	mov	r3, #0
     39c:	e54b3027 	strb	r3, [fp, #-39]	; 0xffffffd9
		return prints (out, print_buf, width, pad);
     3a0:	e24b3028 	sub	r3, fp, #40	; 0x28
     3a4:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
     3a8:	e1a01003 	mov	r1, r3
     3ac:	e59b2004 	ldr	r2, [fp, #4]
     3b0:	e59b3008 	ldr	r3, [fp, #8]
     3b4:	ebffff97 	bl	218 <prints>
     3b8:	e1a03000 	mov	r3, r0
     3bc:	ea000044 	b	4d4 <SVC_STACK_SIZE+0xd4>
	}

	if (sg && b == 10 && i < 0) {
     3c0:	e51b303c 	ldr	r3, [fp, #-60]	; 0xffffffc4
     3c4:	e3530000 	cmp	r3, #0
     3c8:	0a000009 	beq	3f4 <printi+0x98>
     3cc:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
     3d0:	e353000a 	cmp	r3, #10
     3d4:	1a000006 	bne	3f4 <printi+0x98>
     3d8:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
     3dc:	e3530000 	cmp	r3, #0
     3e0:	aa000003 	bge	3f4 <printi+0x98>
		neg = 1;
     3e4:	e3a08001 	mov	r8, #1
		u = -i;
     3e8:	e51b3034 	ldr	r3, [fp, #-52]	; 0xffffffcc
     3ec:	e2633000 	rsb	r3, r3, #0
     3f0:	e1a05003 	mov	r5, r3
	}

	s = print_buf + PRINT_BUF_LEN-1;
     3f4:	e24b3028 	sub	r3, fp, #40	; 0x28
     3f8:	e283400b 	add	r4, r3, #11
	*s = '\0';
     3fc:	e3a03000 	mov	r3, #0
     400:	e5c43000 	strb	r3, [r4]

	while (u) {
     404:	ea000015 	b	460 <SVC_STACK_SIZE+0x60>
		t = u % b;
     408:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
     40c:	e1a00005 	mov	r0, r5
     410:	e1a01003 	mov	r1, r3
     414:	eb000a59 	bl	2d80 <__aeabi_uidivmod>
     418:	e1a03001 	mov	r3, r1
     41c:	e1a06003 	mov	r6, r3
		if( t >= 10 )
     420:	e3560009 	cmp	r6, #9
     424:	da000002 	ble	434 <SVC_STACK_SIZE+0x34>
			t += letbase - '0' - 10;
     428:	e59b300c 	ldr	r3, [fp, #12]
     42c:	e243303a 	sub	r3, r3, #58	; 0x3a
     430:	e0866003 	add	r6, r6, r3
		*--s = t + '0';
     434:	e2444001 	sub	r4, r4, #1
     438:	e20630ff 	and	r3, r6, #255	; 0xff
     43c:	e2833030 	add	r3, r3, #48	; 0x30
     440:	e20330ff 	and	r3, r3, #255	; 0xff
     444:	e5c43000 	strb	r3, [r4]
		u /= b;
     448:	e51b3038 	ldr	r3, [fp, #-56]	; 0xffffffc8
     44c:	e1a00005 	mov	r0, r5
     450:	e1a01003 	mov	r1, r3
     454:	eb000a0c 	bl	2c8c <__aeabi_uidiv>
     458:	e1a03000 	mov	r3, r0
     45c:	e1a05003 	mov	r5, r3
	}

	s = print_buf + PRINT_BUF_LEN-1;
	*s = '\0';

	while (u) {
     460:	e3550000 	cmp	r5, #0
     464:	1affffe7 	bne	408 <SVC_STACK_SIZE+0x8>
			t += letbase - '0' - 10;
		*--s = t + '0';
		u /= b;
	}

	if (neg) {
     468:	e3580000 	cmp	r8, #0
     46c:	0a000011 	beq	4b8 <SVC_STACK_SIZE+0xb8>
		if( width && (pad & PAD_ZERO) ) {
     470:	e59b3004 	ldr	r3, [fp, #4]
     474:	e3530000 	cmp	r3, #0
     478:	0a00000b 	beq	4ac <SVC_STACK_SIZE+0xac>
     47c:	e59b3008 	ldr	r3, [fp, #8]
     480:	e2033002 	and	r3, r3, #2
     484:	e3530000 	cmp	r3, #0
     488:	0a000007 	beq	4ac <SVC_STACK_SIZE+0xac>
			printchar (out, '-');
     48c:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
     490:	e3a0102d 	mov	r1, #45	; 0x2d
     494:	ebffff45 	bl	1b0 <printchar>
			++pc;
     498:	e2877001 	add	r7, r7, #1
			--width;
     49c:	e59b3004 	ldr	r3, [fp, #4]
     4a0:	e2433001 	sub	r3, r3, #1
     4a4:	e58b3004 	str	r3, [fp, #4]
     4a8:	ea000002 	b	4b8 <SVC_STACK_SIZE+0xb8>
		}
		else {
			*--s = '-';
     4ac:	e2444001 	sub	r4, r4, #1
     4b0:	e3a0302d 	mov	r3, #45	; 0x2d
     4b4:	e5c43000 	strb	r3, [r4]
		}
	}

	return pc + prints (out, s, width, pad);
     4b8:	e51b0030 	ldr	r0, [fp, #-48]	; 0xffffffd0
     4bc:	e1a01004 	mov	r1, r4
     4c0:	e59b2004 	ldr	r2, [fp, #4]
     4c4:	e59b3008 	ldr	r3, [fp, #8]
     4c8:	ebffff52 	bl	218 <prints>
     4cc:	e1a03000 	mov	r3, r0
     4d0:	e0833007 	add	r3, r3, r7
}
     4d4:	e1a00003 	mov	r0, r3
     4d8:	e24bd018 	sub	sp, fp, #24
     4dc:	e8bd49f0 	pop	{r4, r5, r6, r7, r8, fp, lr}
     4e0:	e12fff1e 	bx	lr

000004e4 <print>:

static int print(char **out, const char *format, va_list args )
{
     4e4:	e92d48f0 	push	{r4, r5, r6, r7, fp, lr}
     4e8:	e28db014 	add	fp, sp, #20
     4ec:	e24dd028 	sub	sp, sp, #40	; 0x28
     4f0:	e50b0020 	str	r0, [fp, #-32]	; 0xffffffe0
     4f4:	e50b1024 	str	r1, [fp, #-36]	; 0xffffffdc
     4f8:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
	register int width, pad;
	register int pc = 0;
     4fc:	e3a04000 	mov	r4, #0
	char scr[2];

	for (; *format != 0; ++format) {
     500:	ea0000bd 	b	7fc <print+0x318>
		if (*format == '%') {
     504:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     508:	e5d33000 	ldrb	r3, [r3]
     50c:	e3530025 	cmp	r3, #37	; 0x25
     510:	1a0000b0 	bne	7d8 <print+0x2f4>
			++format;
     514:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     518:	e2833001 	add	r3, r3, #1
     51c:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
			width = pad = 0;
     520:	e3a06000 	mov	r6, #0
     524:	e1a05006 	mov	r5, r6
			if (*format == '\0') break;
     528:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     52c:	e5d33000 	ldrb	r3, [r3]
     530:	e3530000 	cmp	r3, #0
     534:	0a0000b5 	beq	810 <print+0x32c>
			if (*format == '%') goto out;
     538:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     53c:	e5d33000 	ldrb	r3, [r3]
     540:	e3530025 	cmp	r3, #37	; 0x25
     544:	0a0000a2 	beq	7d4 <print+0x2f0>
			if (*format == '-') {
     548:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     54c:	e5d33000 	ldrb	r3, [r3]
     550:	e353002d 	cmp	r3, #45	; 0x2d
     554:	1a000009 	bne	580 <print+0x9c>
				++format;
     558:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     55c:	e2833001 	add	r3, r3, #1
     560:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
				pad = PAD_RIGHT;
     564:	e3a06001 	mov	r6, #1
			}
			while (*format == '0') {
     568:	ea000005 	b	584 <print+0xa0>
				++format;
     56c:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     570:	e2833001 	add	r3, r3, #1
     574:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
				pad |= PAD_ZERO;
     578:	e3866002 	orr	r6, r6, #2
     57c:	ea000000 	b	584 <print+0xa0>
			if (*format == '%') goto out;
			if (*format == '-') {
				++format;
				pad = PAD_RIGHT;
			}
			while (*format == '0') {
     580:	e1a00000 	nop			; (mov r0, r0)
     584:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     588:	e5d33000 	ldrb	r3, [r3]
     58c:	e3530030 	cmp	r3, #48	; 0x30
     590:	0afffff5 	beq	56c <print+0x88>
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
     594:	ea00000b 	b	5c8 <print+0xe4>
				width *= 10;
     598:	e1a03005 	mov	r3, r5
     59c:	e1a03103 	lsl	r3, r3, #2
     5a0:	e0833005 	add	r3, r3, r5
     5a4:	e1a03083 	lsl	r3, r3, #1
     5a8:	e1a05003 	mov	r5, r3
				width += *format - '0';
     5ac:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     5b0:	e5d33000 	ldrb	r3, [r3]
     5b4:	e2433030 	sub	r3, r3, #48	; 0x30
     5b8:	e0855003 	add	r5, r5, r3
			}
			while (*format == '0') {
				++format;
				pad |= PAD_ZERO;
			}
			for ( ; *format >= '0' && *format <= '9'; ++format) {
     5bc:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     5c0:	e2833001 	add	r3, r3, #1
     5c4:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
     5c8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     5cc:	e5d33000 	ldrb	r3, [r3]
     5d0:	e353002f 	cmp	r3, #47	; 0x2f
     5d4:	9a000003 	bls	5e8 <print+0x104>
     5d8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     5dc:	e5d33000 	ldrb	r3, [r3]
     5e0:	e3530039 	cmp	r3, #57	; 0x39
     5e4:	9affffeb 	bls	598 <print+0xb4>
				width *= 10;
				width += *format - '0';
			}
			if( *format == 's' ) {
     5e8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     5ec:	e5d33000 	ldrb	r3, [r3]
     5f0:	e3530073 	cmp	r3, #115	; 0x73
     5f4:	1a000011 	bne	640 <print+0x15c>
				register char *s = (char *)va_arg( args, int );
     5f8:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
     5fc:	e2832004 	add	r2, r3, #4
     600:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
     604:	e5933000 	ldr	r3, [r3]
     608:	e1a07003 	mov	r7, r3
				pc += prints (out, s?s:"(null)", width, pad);
     60c:	e3570000 	cmp	r7, #0
     610:	0a000001 	beq	61c <print+0x138>
     614:	e1a03007 	mov	r3, r7
     618:	ea000000 	b	620 <print+0x13c>
     61c:	e59f3220 	ldr	r3, [pc, #544]	; 844 <print+0x360>
     620:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
     624:	e1a01003 	mov	r1, r3
     628:	e1a02005 	mov	r2, r5
     62c:	e1a03006 	mov	r3, r6
     630:	ebfffef8 	bl	218 <prints>
     634:	e1a03000 	mov	r3, r0
     638:	e0844003 	add	r4, r4, r3
				continue;
     63c:	ea00006b 	b	7f0 <print+0x30c>
			}
			if( *format == 'd' ) {
     640:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     644:	e5d33000 	ldrb	r3, [r3]
     648:	e3530064 	cmp	r3, #100	; 0x64
     64c:	1a00000f 	bne	690 <print+0x1ac>
				pc += printi (out, va_arg( args, int ), 10, 1, width, pad, 'a');
     650:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
     654:	e2832004 	add	r2, r3, #4
     658:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
     65c:	e5933000 	ldr	r3, [r3]
     660:	e58d5000 	str	r5, [sp]
     664:	e58d6004 	str	r6, [sp, #4]
     668:	e3a02061 	mov	r2, #97	; 0x61
     66c:	e58d2008 	str	r2, [sp, #8]
     670:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
     674:	e1a01003 	mov	r1, r3
     678:	e3a0200a 	mov	r2, #10
     67c:	e3a03001 	mov	r3, #1
     680:	ebffff35 	bl	35c <printi>
     684:	e1a03000 	mov	r3, r0
     688:	e0844003 	add	r4, r4, r3
				continue;
     68c:	ea000057 	b	7f0 <print+0x30c>
			}
			if( *format == 'x' ) {
     690:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     694:	e5d33000 	ldrb	r3, [r3]
     698:	e3530078 	cmp	r3, #120	; 0x78
     69c:	1a00000f 	bne	6e0 <print+0x1fc>
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'a');
     6a0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
     6a4:	e2832004 	add	r2, r3, #4
     6a8:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
     6ac:	e5933000 	ldr	r3, [r3]
     6b0:	e58d5000 	str	r5, [sp]
     6b4:	e58d6004 	str	r6, [sp, #4]
     6b8:	e3a02061 	mov	r2, #97	; 0x61
     6bc:	e58d2008 	str	r2, [sp, #8]
     6c0:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
     6c4:	e1a01003 	mov	r1, r3
     6c8:	e3a02010 	mov	r2, #16
     6cc:	e3a03000 	mov	r3, #0
     6d0:	ebffff21 	bl	35c <printi>
     6d4:	e1a03000 	mov	r3, r0
     6d8:	e0844003 	add	r4, r4, r3
				continue;
     6dc:	ea000043 	b	7f0 <print+0x30c>
			}
			if( *format == 'X' ) {
     6e0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     6e4:	e5d33000 	ldrb	r3, [r3]
     6e8:	e3530058 	cmp	r3, #88	; 0x58
     6ec:	1a00000f 	bne	730 <print+0x24c>
				pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'A');
     6f0:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
     6f4:	e2832004 	add	r2, r3, #4
     6f8:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
     6fc:	e5933000 	ldr	r3, [r3]
     700:	e58d5000 	str	r5, [sp]
     704:	e58d6004 	str	r6, [sp, #4]
     708:	e3a02041 	mov	r2, #65	; 0x41
     70c:	e58d2008 	str	r2, [sp, #8]
     710:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
     714:	e1a01003 	mov	r1, r3
     718:	e3a02010 	mov	r2, #16
     71c:	e3a03000 	mov	r3, #0
     720:	ebffff0d 	bl	35c <printi>
     724:	e1a03000 	mov	r3, r0
     728:	e0844003 	add	r4, r4, r3
				continue;
     72c:	ea00002f 	b	7f0 <print+0x30c>
			}
			if( *format == 'u' ) {
     730:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     734:	e5d33000 	ldrb	r3, [r3]
     738:	e3530075 	cmp	r3, #117	; 0x75
     73c:	1a00000f 	bne	780 <print+0x29c>
				pc += printi (out, va_arg( args, int ), 10, 0, width, pad, 'a');
     740:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
     744:	e2832004 	add	r2, r3, #4
     748:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
     74c:	e5933000 	ldr	r3, [r3]
     750:	e58d5000 	str	r5, [sp]
     754:	e58d6004 	str	r6, [sp, #4]
     758:	e3a02061 	mov	r2, #97	; 0x61
     75c:	e58d2008 	str	r2, [sp, #8]
     760:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
     764:	e1a01003 	mov	r1, r3
     768:	e3a0200a 	mov	r2, #10
     76c:	e3a03000 	mov	r3, #0
     770:	ebfffef9 	bl	35c <printi>
     774:	e1a03000 	mov	r3, r0
     778:	e0844003 	add	r4, r4, r3
				continue;
     77c:	ea00001b 	b	7f0 <print+0x30c>
			}
			if( *format == 'c' ) {
     780:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     784:	e5d33000 	ldrb	r3, [r3]
     788:	e3530063 	cmp	r3, #99	; 0x63
     78c:	1a000017 	bne	7f0 <print+0x30c>
				/* char are converted to int then pushed on the stack */
				scr[0] = (char)va_arg( args, int );
     790:	e51b3028 	ldr	r3, [fp, #-40]	; 0xffffffd8
     794:	e2832004 	add	r2, r3, #4
     798:	e50b2028 	str	r2, [fp, #-40]	; 0xffffffd8
     79c:	e5933000 	ldr	r3, [r3]
     7a0:	e20330ff 	and	r3, r3, #255	; 0xff
     7a4:	e54b3018 	strb	r3, [fp, #-24]	; 0xffffffe8
				scr[1] = '\0';
     7a8:	e3a03000 	mov	r3, #0
     7ac:	e54b3017 	strb	r3, [fp, #-23]	; 0xffffffe9
				pc += prints (out, scr, width, pad);
     7b0:	e24b3018 	sub	r3, fp, #24
     7b4:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
     7b8:	e1a01003 	mov	r1, r3
     7bc:	e1a02005 	mov	r2, r5
     7c0:	e1a03006 	mov	r3, r6
     7c4:	ebfffe93 	bl	218 <prints>
     7c8:	e1a03000 	mov	r3, r0
     7cc:	e0844003 	add	r4, r4, r3
				continue;
     7d0:	ea000006 	b	7f0 <print+0x30c>
	for (; *format != 0; ++format) {
		if (*format == '%') {
			++format;
			width = pad = 0;
			if (*format == '\0') break;
			if (*format == '%') goto out;
     7d4:	e1a00000 	nop			; (mov r0, r0)
				continue;
			}
		}
		else {
		out:
			printchar (out, *format);
     7d8:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     7dc:	e5d33000 	ldrb	r3, [r3]
     7e0:	e51b0020 	ldr	r0, [fp, #-32]	; 0xffffffe0
     7e4:	e1a01003 	mov	r1, r3
     7e8:	ebfffe70 	bl	1b0 <printchar>
			++pc;
     7ec:	e2844001 	add	r4, r4, #1
{
	register int width, pad;
	register int pc = 0;
	char scr[2];

	for (; *format != 0; ++format) {
     7f0:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     7f4:	e2833001 	add	r3, r3, #1
     7f8:	e50b3024 	str	r3, [fp, #-36]	; 0xffffffdc
     7fc:	e51b3024 	ldr	r3, [fp, #-36]	; 0xffffffdc
     800:	e5d33000 	ldrb	r3, [r3]
     804:	e3530000 	cmp	r3, #0
     808:	1affff3d 	bne	504 <print+0x20>
     80c:	ea000000 	b	814 <print+0x330>
		if (*format == '%') {
			++format;
			width = pad = 0;
			if (*format == '\0') break;
     810:	e1a00000 	nop			; (mov r0, r0)
		out:
			printchar (out, *format);
			++pc;
		}
	}
	if (out) **out = '\0';
     814:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
     818:	e3530000 	cmp	r3, #0
     81c:	0a000003 	beq	830 <print+0x34c>
     820:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
     824:	e5933000 	ldr	r3, [r3]
     828:	e3a02000 	mov	r2, #0
     82c:	e5c32000 	strb	r2, [r3]
	va_end( args );
	return pc;
     830:	e1a03004 	mov	r3, r4
}
     834:	e1a00003 	mov	r0, r3
     838:	e24bd014 	sub	sp, fp, #20
     83c:	e8bd48f0 	pop	{r4, r5, r6, r7, fp, lr}
     840:	e12fff1e 	bx	lr
     844:	00002eec 	.word	0x00002eec

00000848 <iprintf>:

int iprintf(const char *format, ...)
{
     848:	e92d000f 	push	{r0, r1, r2, r3}
     84c:	e92d4800 	push	{fp, lr}
     850:	e28db004 	add	fp, sp, #4
     854:	e24dd008 	sub	sp, sp, #8
        va_list args;

        va_start( args, format );
     858:	e28b3008 	add	r3, fp, #8
     85c:	e50b3008 	str	r3, [fp, #-8]
        return print( 0, format, args );
     860:	e3a00000 	mov	r0, #0
     864:	e59b1004 	ldr	r1, [fp, #4]
     868:	e51b2008 	ldr	r2, [fp, #-8]
     86c:	ebffff1c 	bl	4e4 <print>
     870:	e1a03000 	mov	r3, r0
}
     874:	e1a00003 	mov	r0, r3
     878:	e24bd004 	sub	sp, fp, #4
     87c:	e8bd4800 	pop	{fp, lr}
     880:	e28dd010 	add	sp, sp, #16
     884:	e12fff1e 	bx	lr

00000888 <isprintf>:

int isprintf(char *out, const char *format, ...)
{
     888:	e92d000e 	push	{r1, r2, r3}
     88c:	e92d4800 	push	{fp, lr}
     890:	e28db004 	add	fp, sp, #4
     894:	e24dd014 	sub	sp, sp, #20
     898:	e50b0014 	str	r0, [fp, #-20]	; 0xffffffec
        va_list args;

        va_start( args, format );
     89c:	e28b3008 	add	r3, fp, #8
     8a0:	e50b300c 	str	r3, [fp, #-12]
        return print( &out, format, args );
     8a4:	e24b3014 	sub	r3, fp, #20
     8a8:	e1a00003 	mov	r0, r3
     8ac:	e59b1004 	ldr	r1, [fp, #4]
     8b0:	e51b200c 	ldr	r2, [fp, #-12]
     8b4:	ebffff0a 	bl	4e4 <print>
     8b8:	e1a03000 	mov	r3, r0
}
     8bc:	e1a00003 	mov	r0, r3
     8c0:	e24bd004 	sub	sp, fp, #4
     8c4:	e8bd4800 	pop	{fp, lr}
     8c8:	e28dd00c 	add	sp, sp, #12
     8cc:	e12fff1e 	bx	lr

000008d0 <lcd_line1>:
/*------------------------------------------------------------------------------------*/
static void strobe_e(void);

//---------------------------------------------------------------------
void lcd_line1(void)
{
     8d0:	e92d4800 	push	{fp, lr}
     8d4:	e28db004 	add	fp, sp, #4
	lcd_cmd(0x80);
     8d8:	e3a00080 	mov	r0, #128	; 0x80
     8dc:	eb00001c 	bl	954 <lcd_cmd>
}
     8e0:	e24bd004 	sub	sp, fp, #4
     8e4:	e8bd4800 	pop	{fp, lr}
     8e8:	e12fff1e 	bx	lr

000008ec <lcd_string>:
/**
 * Writes a string to LCD
 * @param[in] senpoint a pointer to a null-terminated string
 */
void lcd_string(char *senpoint)
{
     8ec:	e92d4800 	push	{fp, lr}
     8f0:	e28db004 	add	fp, sp, #4
     8f4:	e24dd008 	sub	sp, sp, #8
     8f8:	e50b0008 	str	r0, [fp, #-8]
	while(*senpoint != '\0')
     8fc:	ea000006 	b	91c <lcd_string+0x30>
	{
		lcd_char(*senpoint);
     900:	e51b3008 	ldr	r3, [fp, #-8]
     904:	e5d33000 	ldrb	r3, [r3]
     908:	e1a00003 	mov	r0, r3
     90c:	eb00002a 	bl	9bc <lcd_char>
		senpoint++;
     910:	e51b3008 	ldr	r3, [fp, #-8]
     914:	e2833001 	add	r3, r3, #1
     918:	e50b3008 	str	r3, [fp, #-8]
 * Writes a string to LCD
 * @param[in] senpoint a pointer to a null-terminated string
 */
void lcd_string(char *senpoint)
{
	while(*senpoint != '\0')
     91c:	e51b3008 	ldr	r3, [fp, #-8]
     920:	e5d33000 	ldrb	r3, [r3]
     924:	e3530000 	cmp	r3, #0
     928:	1afffff4 	bne	900 <lcd_string+0x14>
	{
		lcd_char(*senpoint);
		senpoint++;
	}
}
     92c:	e24bd004 	sub	sp, fp, #4
     930:	e8bd4800 	pop	{fp, lr}
     934:	e12fff1e 	bx	lr

00000938 <lcd_line2>:

//---------------------------------------------------------------------
void lcd_line2(void)
{
     938:	e92d4800 	push	{fp, lr}
     93c:	e28db004 	add	fp, sp, #4
	lcd_cmd(0xc0);
     940:	e3a000c0 	mov	r0, #192	; 0xc0
     944:	eb000002 	bl	954 <lcd_cmd>
}
     948:	e24bd004 	sub	sp, fp, #4
     94c:	e8bd4800 	pop	{fp, lr}
     950:	e12fff1e 	bx	lr

00000954 <lcd_cmd>:

//---------------------------------------------------------------------
void lcd_cmd(unsigned char letter)
{
     954:	e92d4800 	push	{fp, lr}
     958:	e28db004 	add	fp, sp, #4
     95c:	e24dd010 	sub	sp, sp, #16
     960:	e1a03000 	mov	r3, r0
     964:	e54b300d 	strb	r3, [fp, #-13]
	unsigned char temp;
	temp=letter;
     968:	e55b300d 	ldrb	r3, [fp, #-13]
     96c:	e54b3005 	strb	r3, [fp, #-5]
	temp=temp>>4;
     970:	e55b3005 	ldrb	r3, [fp, #-5]
     974:	e1a03223 	lsr	r3, r3, #4
     978:	e54b3005 	strb	r3, [fp, #-5]
	lcd_nybble(temp,0);
     97c:	e55b3005 	ldrb	r3, [fp, #-5]
     980:	e1a00003 	mov	r0, r3
     984:	e3a01000 	mov	r1, #0
     988:	eb000025 	bl	a24 <lcd_nybble>
	temp=letter;
     98c:	e55b300d 	ldrb	r3, [fp, #-13]
     990:	e54b3005 	strb	r3, [fp, #-5]
	temp=temp&0x0f;
     994:	e55b3005 	ldrb	r3, [fp, #-5]
     998:	e203300f 	and	r3, r3, #15
     99c:	e54b3005 	strb	r3, [fp, #-5]
	lcd_nybble(temp,0);
     9a0:	e55b3005 	ldrb	r3, [fp, #-5]
     9a4:	e1a00003 	mov	r0, r3
     9a8:	e3a01000 	mov	r1, #0
     9ac:	eb00001c 	bl	a24 <lcd_nybble>
}
     9b0:	e24bd004 	sub	sp, fp, #4
     9b4:	e8bd4800 	pop	{fp, lr}
     9b8:	e12fff1e 	bx	lr

000009bc <lcd_char>:

//---------------------------------------------------------------------
void lcd_char(unsigned char letter)
{
     9bc:	e92d4800 	push	{fp, lr}
     9c0:	e28db004 	add	fp, sp, #4
     9c4:	e24dd010 	sub	sp, sp, #16
     9c8:	e1a03000 	mov	r3, r0
     9cc:	e54b300d 	strb	r3, [fp, #-13]
	unsigned char temp;
	temp=letter;
     9d0:	e55b300d 	ldrb	r3, [fp, #-13]
     9d4:	e54b3005 	strb	r3, [fp, #-5]
	temp=temp>>4;
     9d8:	e55b3005 	ldrb	r3, [fp, #-5]
     9dc:	e1a03223 	lsr	r3, r3, #4
     9e0:	e54b3005 	strb	r3, [fp, #-5]
	lcd_nybble(temp,1);
     9e4:	e55b3005 	ldrb	r3, [fp, #-5]
     9e8:	e1a00003 	mov	r0, r3
     9ec:	e3a01001 	mov	r1, #1
     9f0:	eb00000b 	bl	a24 <lcd_nybble>
	temp=letter;
     9f4:	e55b300d 	ldrb	r3, [fp, #-13]
     9f8:	e54b3005 	strb	r3, [fp, #-5]
	temp=temp&0x0f;
     9fc:	e55b3005 	ldrb	r3, [fp, #-5]
     a00:	e203300f 	and	r3, r3, #15
     a04:	e54b3005 	strb	r3, [fp, #-5]
	lcd_nybble(temp,1);
     a08:	e55b3005 	ldrb	r3, [fp, #-5]
     a0c:	e1a00003 	mov	r0, r3
     a10:	e3a01001 	mov	r1, #1
     a14:	eb000002 	bl	a24 <lcd_nybble>
}
     a18:	e24bd004 	sub	sp, fp, #4
     a1c:	e8bd4800 	pop	{fp, lr}
     a20:	e12fff1e 	bx	lr

00000a24 <lcd_nybble>:

//---------------------------------------------------------------------
void lcd_nybble(unsigned char nyb,unsigned char rs)
{
     a24:	e92d4800 	push	{fp, lr}
     a28:	e28db004 	add	fp, sp, #4
     a2c:	e24dd010 	sub	sp, sp, #16
     a30:	e1a02000 	mov	r2, r0
     a34:	e1a03001 	mov	r3, r1
     a38:	e54b200d 	strb	r2, [fp, #-13]
     a3c:	e54b300e 	strb	r3, [fp, #-14]
	int dat;
	if(rs)
     a40:	e55b300e 	ldrb	r3, [fp, #-14]
     a44:	e3530000 	cmp	r3, #0
     a48:	0a000005 	beq	a64 <lcd_nybble+0x40>
		IOSET0 |= RS;	//set RS pin
     a4c:	e59f3064 	ldr	r3, [pc, #100]	; ab8 <lcd_nybble+0x94>
     a50:	e59f2060 	ldr	r2, [pc, #96]	; ab8 <lcd_nybble+0x94>
     a54:	e5922000 	ldr	r2, [r2]
     a58:	e3822501 	orr	r2, r2, #4194304	; 0x400000
     a5c:	e5832000 	str	r2, [r3]
     a60:	ea000004 	b	a78 <lcd_nybble+0x54>
	else
		IOCLR0 |= RS;	//clear RS pin
     a64:	e59f3050 	ldr	r3, [pc, #80]	; abc <lcd_nybble+0x98>
     a68:	e59f204c 	ldr	r2, [pc, #76]	; abc <lcd_nybble+0x98>
     a6c:	e5922000 	ldr	r2, [r2]
     a70:	e3822501 	orr	r2, r2, #4194304	; 0x400000
     a74:	e5832000 	str	r2, [r3]
	dat = nyb;			//get the nybble in an int
     a78:	e55b300d 	ldrb	r3, [fp, #-13]
     a7c:	e50b3008 	str	r3, [fp, #-8]
	IOCLR0 = LCD_DATA_MASK;   //clear D4-D7
     a80:	e59f3034 	ldr	r3, [pc, #52]	; abc <lcd_nybble+0x98>
     a84:	e3a02b0f 	mov	r2, #15360	; 0x3c00
     a88:	e5832000 	str	r2, [r3]
	IOPIN0 |= dat<<10;	//OR the bits in there
     a8c:	e59f302c 	ldr	r3, [pc, #44]	; ac0 <lcd_nybble+0x9c>
     a90:	e59f2028 	ldr	r2, [pc, #40]	; ac0 <lcd_nybble+0x9c>
     a94:	e5921000 	ldr	r1, [r2]
     a98:	e51b2008 	ldr	r2, [fp, #-8]
     a9c:	e1a02502 	lsl	r2, r2, #10
     aa0:	e1812002 	orr	r2, r1, r2
     aa4:	e5832000 	str	r2, [r3]
	strobe_e();			//latch data to LCD
     aa8:	eb000043 	bl	bbc <strobe_e>
}
     aac:	e24bd004 	sub	sp, fp, #4
     ab0:	e8bd4800 	pop	{fp, lr}
     ab4:	e12fff1e 	bx	lr
     ab8:	e0028004 	.word	0xe0028004
     abc:	e002800c 	.word	0xe002800c
     ac0:	e0028000 	.word	0xe0028000

00000ac4 <Inicializar_LCD>:

//---------------------------------------------------------------------
void Inicializar_LCD(void)
{
     ac4:	e92d4800 	push	{fp, lr}
     ac8:	e28db004 	add	fp, sp, #4
	IODIR0 |= LCD_DATA_MASK|LCD_CONTROL_MASK|LUZ;  //Configura E, RS, RW, D7, D6, D5 e D4 como saída
     acc:	e59f20d4 	ldr	r2, [pc, #212]	; ba8 <Inicializar_LCD+0xe4>
     ad0:	e59f30d0 	ldr	r3, [pc, #208]	; ba8 <Inicializar_LCD+0xe4>
     ad4:	e5931000 	ldr	r1, [r3]
     ad8:	e59f30cc 	ldr	r3, [pc, #204]	; bac <Inicializar_LCD+0xe8>
     adc:	e1813003 	orr	r3, r1, r3
     ae0:	e5823000 	str	r3, [r2]
	IOCLR0 = LCD_DATA_MASK|LCD_CONTROL_MASK;  //Configura E, RS, RW, D7, D6, D5 e D4 como saída
     ae4:	e59f30c4 	ldr	r3, [pc, #196]	; bb0 <Inicializar_LCD+0xec>
     ae8:	e59f20c4 	ldr	r2, [pc, #196]	; bb4 <Inicializar_LCD+0xf0>
     aec:	e5832000 	str	r2, [r3]

	delay_ms(500);		 //settle time delay
     af0:	e3a00f7d 	mov	r0, #500	; 0x1f4
     af4:	ebfffd77 	bl	d8 <delay_ms>
	lcd_nybble(0x03,0);	 //reset LCD
     af8:	e3a00003 	mov	r0, #3
     afc:	e3a01000 	mov	r1, #0
     b00:	ebffffc7 	bl	a24 <lcd_nybble>
	delay_ms(5);
     b04:	e3a00005 	mov	r0, #5
     b08:	ebfffd72 	bl	d8 <delay_ms>
	strobe_e();
     b0c:	eb00002a 	bl	bbc <strobe_e>
	delay_us(160);
     b10:	e3a000a0 	mov	r0, #160	; 0xa0
     b14:	ebfffd8b 	bl	148 <delay_us>
	strobe_e();
     b18:	eb000027 	bl	bbc <strobe_e>
	delay_us(160);
     b1c:	e3a000a0 	mov	r0, #160	; 0xa0
     b20:	ebfffd88 	bl	148 <delay_us>
	lcd_nybble(0x02,0);
     b24:	e3a00002 	mov	r0, #2
     b28:	e3a01000 	mov	r1, #0
     b2c:	ebffffbc 	bl	a24 <lcd_nybble>
	delay_us(160);
     b30:	e3a000a0 	mov	r0, #160	; 0xa0
     b34:	ebfffd83 	bl	148 <delay_us>
	lcd_cmd(0x28);	//set 4-bit mode and 2 lines
     b38:	e3a00028 	mov	r0, #40	; 0x28
     b3c:	ebffff84 	bl	954 <lcd_cmd>
	delay_us(160);
     b40:	e3a000a0 	mov	r0, #160	; 0xa0
     b44:	ebfffd7f 	bl	148 <delay_us>
	lcd_cmd(0x10);	//cursor move & shift left
     b48:	e3a00010 	mov	r0, #16
     b4c:	ebffff80 	bl	954 <lcd_cmd>
	delay_us(160);
     b50:	e3a000a0 	mov	r0, #160	; 0xa0
     b54:	ebfffd7b 	bl	148 <delay_us>
	lcd_cmd(0x06);	//entry mode = increment
     b58:	e3a00006 	mov	r0, #6
     b5c:	ebffff7c 	bl	954 <lcd_cmd>
	delay_us(160);
     b60:	e3a000a0 	mov	r0, #160	; 0xa0
     b64:	ebfffd77 	bl	148 <delay_us>
	lcd_cmd(0x0e);	//display on - cursor blink on
     b68:	e3a0000e 	mov	r0, #14
     b6c:	ebffff78 	bl	954 <lcd_cmd>
	delay_us(160);
     b70:	e3a000a0 	mov	r0, #160	; 0xa0
     b74:	ebfffd73 	bl	148 <delay_us>
	lcd_cmd(0x01);	//clear display
     b78:	e3a00001 	mov	r0, #1
     b7c:	ebffff74 	bl	954 <lcd_cmd>
	delay_ms(40);
     b80:	e3a00028 	mov	r0, #40	; 0x28
     b84:	ebfffd53 	bl	d8 <delay_ms>
	IOSET0 |= LUZ; 	// Liga a luz do display
     b88:	e59f3028 	ldr	r3, [pc, #40]	; bb8 <Inicializar_LCD+0xf4>
     b8c:	e59f2024 	ldr	r2, [pc, #36]	; bb8 <Inicializar_LCD+0xf4>
     b90:	e5922000 	ldr	r2, [r2]
     b94:	e3822602 	orr	r2, r2, #2097152	; 0x200000
     b98:	e5832000 	str	r2, [r3]
}
     b9c:	e24bd004 	sub	sp, fp, #4
     ba0:	e8bd4800 	pop	{fp, lr}
     ba4:	e12fff1e 	bx	lr
     ba8:	e0028008 	.word	0xe0028008
     bac:	30603c00 	.word	0x30603c00
     bb0:	e002800c 	.word	0xe002800c
     bb4:	30403c00 	.word	0x30403c00
     bb8:	e0028004 	.word	0xe0028004

00000bbc <strobe_e>:
//---------------------------------------------------------------------

static void strobe_e(void)
{
     bbc:	e92d4800 	push	{fp, lr}
     bc0:	e28db004 	add	fp, sp, #4
	IOSET0 |= E;
     bc4:	e59f303c 	ldr	r3, [pc, #60]	; c08 <strobe_e+0x4c>
     bc8:	e59f2038 	ldr	r2, [pc, #56]	; c08 <strobe_e+0x4c>
     bcc:	e5922000 	ldr	r2, [r2]
     bd0:	e3822201 	orr	r2, r2, #268435456	; 0x10000000
     bd4:	e5832000 	str	r2, [r3]
	delay_us(1);
     bd8:	e3a00001 	mov	r0, #1
     bdc:	ebfffd59 	bl	148 <delay_us>
	IOCLR0 |= E;
     be0:	e59f3024 	ldr	r3, [pc, #36]	; c0c <strobe_e+0x50>
     be4:	e59f2020 	ldr	r2, [pc, #32]	; c0c <strobe_e+0x50>
     be8:	e5922000 	ldr	r2, [r2]
     bec:	e3822201 	orr	r2, r2, #268435456	; 0x10000000
     bf0:	e5832000 	str	r2, [r3]
	delay_us(160);
     bf4:	e3a000a0 	mov	r0, #160	; 0xa0
     bf8:	ebfffd52 	bl	148 <delay_us>
}
     bfc:	e24bd004 	sub	sp, fp, #4
     c00:	e8bd4800 	pop	{fp, lr}
     c04:	e12fff1e 	bx	lr
     c08:	e0028004 	.word	0xe0028004
     c0c:	e002800c 	.word	0xe002800c

00000c10 <_HandleBulkIn>:
static U8     abVendorReqData[sizeof(TMemoryCmd)];
U8 str[] = "Felipe";
U8 buff[50] = {0};

static void _HandleBulkIn(U8 bEP, U8 bEPStatus)
{
     c10:	e92d4800 	push	{fp, lr}
     c14:	e28db004 	add	fp, sp, #4
     c18:	e24dd008 	sub	sp, sp, #8
     c1c:	e1a02000 	mov	r2, r0
     c20:	e1a03001 	mov	r3, r1
     c24:	e54b2005 	strb	r2, [fp, #-5]
     c28:	e54b3006 	strb	r3, [fp, #-6]

  USBHwEPWrite(bEP, str, sizeof(str));
     c2c:	e55b3005 	ldrb	r3, [fp, #-5]
     c30:	e1a00003 	mov	r0, r3
     c34:	e59f1010 	ldr	r1, [pc, #16]	; c4c <_HandleBulkIn+0x3c>
     c38:	e3a02007 	mov	r2, #7
     c3c:	eb000430 	bl	1d04 <USBHwEPWrite>

}
     c40:	e24bd004 	sub	sp, fp, #4
     c44:	e8bd4800 	pop	{fp, lr}
     c48:	e12fff1e 	bx	lr
     c4c:	40000200 	.word	0x40000200

00000c50 <_HandleBulkOut>:


static void _HandleBulkOut(U8 bEP, U8 bEPStatus)
{
     c50:	e92d4800 	push	{fp, lr}
     c54:	e28db004 	add	fp, sp, #4
     c58:	e24dd010 	sub	sp, sp, #16
     c5c:	e1a02000 	mov	r2, r0
     c60:	e1a03001 	mov	r3, r1
     c64:	e54b200d 	strb	r2, [fp, #-13]
     c68:	e54b300e 	strb	r3, [fp, #-14]
  int x = 0;
     c6c:	e3a03000 	mov	r3, #0
     c70:	e50b3008 	str	r3, [fp, #-8]

  x = USBHwEPRead(bEP,buff,sizeof(buff));
     c74:	e55b300d 	ldrb	r3, [fp, #-13]
     c78:	e1a00003 	mov	r0, r3
     c7c:	e59f1014 	ldr	r1, [pc, #20]	; c98 <_HandleBulkOut+0x48>
     c80:	e3a02032 	mov	r2, #50	; 0x32
     c84:	eb000460 	bl	1e0c <USBHwEPRead>
     c88:	e50b0008 	str	r0, [fp, #-8]


}
     c8c:	e24bd004 	sub	sp, fp, #4
     c90:	e8bd4800 	pop	{fp, lr}
     c94:	e12fff1e 	bx	lr
     c98:	40000218 	.word	0x40000218

00000c9c <HandleVendorRequest>:
  * data:   U32 dwAddress
        U32 dwLength

**************************************************************************/
static BOOL HandleVendorRequest(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
     c9c:	e92d4800 	push	{fp, lr}
     ca0:	e28db004 	add	fp, sp, #4
     ca4:	e24dd018 	sub	sp, sp, #24
     ca8:	e50b0010 	str	r0, [fp, #-16]
     cac:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
     cb0:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
  TMemoryCmd  *pCmd;

  pCmd = (TMemoryCmd *)*ppbData;
     cb4:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
     cb8:	e5933000 	ldr	r3, [r3]
     cbc:	e50b3008 	str	r3, [fp, #-8]

  switch (pSetup->bRequest) {
     cc0:	e51b3010 	ldr	r3, [fp, #-16]
     cc4:	e5d33001 	ldrb	r3, [r3, #1]
     cc8:	e3530001 	cmp	r3, #1
     ccc:	0a000002 	beq	cdc <HandleVendorRequest+0x40>
     cd0:	e3530002 	cmp	r3, #2
     cd4:	0a000013 	beq	d28 <HandleVendorRequest+0x8c>
     cd8:	ea000022 	b	d68 <HandleVendorRequest+0xcc>

  // prepare read
  case 0x01:
    MemoryCmd = *pCmd;
     cdc:	e59f30b4 	ldr	r3, [pc, #180]	; d98 <HandleVendorRequest+0xfc>
     ce0:	e51b2008 	ldr	r2, [fp, #-8]
     ce4:	e8920003 	ldm	r2, {r0, r1}
     ce8:	e8830003 	stm	r3, {r0, r1}
    TRACE_DEBUG("READ: addr=%X, len=%d\n", MemoryCmd.dwAddress, MemoryCmd.dwLength);
     cec:	e59f30a4 	ldr	r3, [pc, #164]	; d98 <HandleVendorRequest+0xfc>
     cf0:	e5932000 	ldr	r2, [r3]
     cf4:	e59f309c 	ldr	r3, [pc, #156]	; d98 <HandleVendorRequest+0xfc>
     cf8:	e5933004 	ldr	r3, [r3, #4]
     cfc:	e59f0098 	ldr	r0, [pc, #152]	; d9c <HandleVendorRequest+0x100>
     d00:	e1a01002 	mov	r1, r2
     d04:	e1a02003 	mov	r2, r3
     d08:	ebfffece 	bl	848 <iprintf>
    // send initial packet
    _HandleBulkIn(BULK_IN_EP, 0);
     d0c:	e3a00082 	mov	r0, #130	; 0x82
     d10:	e3a01000 	mov	r1, #0
     d14:	ebffffbd 	bl	c10 <_HandleBulkIn>
    *piLen = 0;
     d18:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
     d1c:	e3a02000 	mov	r2, #0
     d20:	e5832000 	str	r2, [r3]
    break;
     d24:	ea000016 	b	d84 <HandleVendorRequest+0xe8>

  // prepare write
  case 0x02:
    MemoryCmd = *pCmd;
     d28:	e59f3068 	ldr	r3, [pc, #104]	; d98 <HandleVendorRequest+0xfc>
     d2c:	e51b2008 	ldr	r2, [fp, #-8]
     d30:	e8920003 	ldm	r2, {r0, r1}
     d34:	e8830003 	stm	r3, {r0, r1}
    TRACE_DEBUG("WRITE: addr=%X, len=%d\n", MemoryCmd.dwAddress, MemoryCmd.dwLength);
     d38:	e59f3058 	ldr	r3, [pc, #88]	; d98 <HandleVendorRequest+0xfc>
     d3c:	e5932000 	ldr	r2, [r3]
     d40:	e59f3050 	ldr	r3, [pc, #80]	; d98 <HandleVendorRequest+0xfc>
     d44:	e5933004 	ldr	r3, [r3, #4]
     d48:	e59f0050 	ldr	r0, [pc, #80]	; da0 <HandleVendorRequest+0x104>
     d4c:	e1a01002 	mov	r1, r2
     d50:	e1a02003 	mov	r2, r3
     d54:	ebfffebb 	bl	848 <iprintf>
    *piLen = 0;
     d58:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
     d5c:	e3a02000 	mov	r2, #0
     d60:	e5832000 	str	r2, [r3]
    break;
     d64:	ea000006 	b	d84 <HandleVendorRequest+0xe8>

  default:
    TRACE_DEBUG("Unhandled class %X\n", pSetup->bRequest);
     d68:	e51b3010 	ldr	r3, [fp, #-16]
     d6c:	e5d33001 	ldrb	r3, [r3, #1]
     d70:	e59f002c 	ldr	r0, [pc, #44]	; da4 <HandleVendorRequest+0x108>
     d74:	e1a01003 	mov	r1, r3
     d78:	ebfffeb2 	bl	848 <iprintf>
    return FALSE;
     d7c:	e3a03000 	mov	r3, #0
     d80:	ea000000 	b	d88 <HandleVendorRequest+0xec>
  }
  return TRUE;
     d84:	e3a03001 	mov	r3, #1
}
     d88:	e1a00003 	mov	r0, r3
     d8c:	e24bd004 	sub	sp, fp, #4
     d90:	e8bd4800 	pop	{fp, lr}
     d94:	e12fff1e 	bx	lr
     d98:	40000208 	.word	0x40000208
     d9c:	00002f68 	.word	0x00002f68
     da0:	00002f88 	.word	0x00002f88
     da4:	00002fa8 	.word	0x00002fa8

00000da8 <main>:
  main
  ====
**************************************************************************/

int main(void)
{
     da8:	e92d4800 	push	{fp, lr}
     dac:	e28db004 	add	fp, sp, #4
//  int res = 0;
//  uint32_t i = 0;
//  U8 buff[] = "Felipe" ;


  Initialize();
     db0:	eb000056 	bl	f10 <Initialize>
  IODIR1 |= (1 << 17);
     db4:	e59f30c0 	ldr	r3, [pc, #192]	; e7c <main+0xd4>
     db8:	e59f20bc 	ldr	r2, [pc, #188]	; e7c <main+0xd4>
     dbc:	e5922000 	ldr	r2, [r2]
     dc0:	e3822802 	orr	r2, r2, #131072	; 0x20000
     dc4:	e5832000 	str	r2, [r3]
//  IOCLR1 = 1 << 17;
  IOSET1 = (1 << 17);
     dc8:	e59f30b0 	ldr	r3, [pc, #176]	; e80 <main+0xd8>
     dcc:	e3a02802 	mov	r2, #131072	; 0x20000
     dd0:	e5832000 	str	r2, [r3]

  // init DBG
//  ConsoleInit(60000000 / (16 * BAUD_RATE));
  UART_Init(0,BAUD_RATE);
     dd4:	e3a00000 	mov	r0, #0
     dd8:	e3a01d96 	mov	r1, #9600	; 0x2580
     ddc:	eb000075 	bl	fb8 <UART_Init>
//  Inicializar_LCD();

  TRACE_DEBUG("Initialising USB stack\n");
     de0:	e59f009c 	ldr	r0, [pc, #156]	; e84 <main+0xdc>
     de4:	ebfffe97 	bl	848 <iprintf>
//  lcd_string("FELIPE");
  // initialise stack
  USBInit();
     de8:	eb00055b 	bl	235c <USBInit>

  // register device descriptors
  USBRegisterDescriptors(abDescriptors);
     dec:	e59f0094 	ldr	r0, [pc, #148]	; e88 <main+0xe0>
     df0:	eb000577 	bl	23d4 <USBRegisterDescriptors>

  // override standard request handler
  USBRegisterRequestHandler(REQTYPE_TYPE_VENDOR, HandleVendorRequest, abVendorReqData);
     df4:	e3a00002 	mov	r0, #2
     df8:	e59f108c 	ldr	r1, [pc, #140]	; e8c <main+0xe4>
     dfc:	e59f208c 	ldr	r2, [pc, #140]	; e90 <main+0xe8>
     e00:	eb00022a 	bl	16b0 <USBRegisterRequestHandler>

  // register endpoints
  USBHwRegisterEPIntHandler(BULK_IN_EP, _HandleBulkIn);
     e04:	e3a00082 	mov	r0, #130	; 0x82
     e08:	e59f1084 	ldr	r1, [pc, #132]	; e94 <main+0xec>
     e0c:	eb0002f5 	bl	19e8 <USBHwRegisterEPIntHandler>
  USBHwRegisterEPIntHandler(BULK_OUT_EP, _HandleBulkOut);
     e10:	e3a00005 	mov	r0, #5
     e14:	e59f107c 	ldr	r1, [pc, #124]	; e98 <main+0xf0>
     e18:	eb0002f2 	bl	19e8 <USBHwRegisterEPIntHandler>

  TRACE_DEBUG("Starting USB communication\n");
     e1c:	e59f0078 	ldr	r0, [pc, #120]	; e9c <main+0xf4>
     e20:	ebfffe88 	bl	848 <iprintf>

  // connect to bus
  USBHwConnect(TRUE);
     e24:	e3a00001 	mov	r0, #1
     e28:	eb000362 	bl	1bb8 <USBHwConnect>
//    TRACE_DEBUG("No write EP")
//  else
//    TRACE_DEBUG("Write bulk")
  // call USB interrupt handler continuously

  T0PR = 30;          //incrementa o contador, quando o contador prescale atinge o valor de PR.
     e2c:	e59f306c 	ldr	r3, [pc, #108]	; ea0 <main+0xf8>
     e30:	e3a0201e 	mov	r2, #30
     e34:	e5832000 	str	r2, [r3]
  T0TCR = 0x00000002; //desabilita o contador e reseta o
     e38:	e59f3064 	ldr	r3, [pc, #100]	; ea4 <main+0xfc>
     e3c:	e3a02002 	mov	r2, #2
     e40:	e5832000 	str	r2, [r3]
  T0MCR = 0x00000003; //On match reset the counter and generate an interrupt
     e44:	e59f305c 	ldr	r3, [pc, #92]	; ea8 <main+0x100>
     e48:	e3a02003 	mov	r2, #3
     e4c:	e5832000 	str	r2, [r3]
  T0MR0 = 0xFFFFFFFF;      // T0MR0 = Match Register 0,
     e50:	e59f3054 	ldr	r3, [pc, #84]	; eac <main+0x104>
     e54:	e3e02000 	mvn	r2, #0
     e58:	e5832000 	str	r2, [r3]
                // Tempo = (CLOCK dos periféricos (PCLK) / Prescaler (T0PR)) *  Match Register (T0MR0)
                // Tempo = (PCLK/T0PR) * T0MR0, Ex: Tempo = (30 MHz/30) * 1000000 = 1us

  T0MR1   = 0x00000000; // Set duty cycle to zero
     e5c:	e59f304c 	ldr	r3, [pc, #76]	; eb0 <main+0x108>
     e60:	e3a02000 	mov	r2, #0
     e64:	e5832000 	str	r2, [r3]
  T0TCR     = 0x00000001; //enable timer
     e68:	e59f3034 	ldr	r3, [pc, #52]	; ea4 <main+0xfc>
     e6c:	e3a02001 	mov	r2, #1
     e70:	e5832000 	str	r2, [r3]
//  enableIRQ(); // habilita que havera a utilização de interrupção


  while (1) {

    USBHwISR();
     e74:	eb00044e 	bl	1fb4 <USBHwISR>
//
//       i = 0;
//    }
//
//       i++;
  }
     e78:	eafffffd 	b	e74 <main+0xcc>
     e7c:	e0028018 	.word	0xe0028018
     e80:	e0028014 	.word	0xe0028014
     e84:	00002fc4 	.word	0x00002fc4
     e88:	00002ef4 	.word	0x00002ef4
     e8c:	00000c9c 	.word	0x00000c9c
     e90:	40000210 	.word	0x40000210
     e94:	00000c10 	.word	0x00000c10
     e98:	00000c50 	.word	0x00000c50
     e9c:	00002fe4 	.word	0x00002fe4
     ea0:	e000400c 	.word	0xe000400c
     ea4:	e0004004 	.word	0xe0004004
     ea8:	e0004014 	.word	0xe0004014
     eac:	e0004018 	.word	0xe0004018
     eb0:	e000401c 	.word	0xe000401c

00000eb4 <IRQ_Routine>:


/*  Stubs for various interrupts (may be replaced later)  */
/*  ----------------------------------------------------  */

void IRQ_Routine (void) {
     eb4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
     eb8:	e28db000 	add	fp, sp, #0
	while (1) ;	
     ebc:	eafffffe 	b	ebc <IRQ_Routine+0x8>

00000ec0 <FIQ_Routine>:
}

void FIQ_Routine (void)  {
     ec0:	e24db004 	sub	fp, sp, #4
	while (1) ;	
     ec4:	eafffffe 	b	ec4 <FIQ_Routine+0x4>

00000ec8 <SWI_Routine>:
}


void SWI_Routine (void)  {
     ec8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
     ecc:	e28db000 	add	fp, sp, #0
	while (1) ;	
     ed0:	eafffffe 	b	ed0 <SWI_Routine+0x8>

00000ed4 <UNDEF_Routine>:
}


void UNDEF_Routine (void) {
     ed4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
     ed8:	e28db000 	add	fp, sp, #0
	while (1) ;	
     edc:	eafffffe 	b	edc <UNDEF_Routine+0x8>

00000ee0 <feed>:
**********************************************************/

#define PLOCK 0x400

static void feed(void)
{
     ee0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
     ee4:	e28db000 	add	fp, sp, #0
	PLLFEED = 0xAA;
     ee8:	e59f301c 	ldr	r3, [pc, #28]	; f0c <feed+0x2c>
     eec:	e3a020aa 	mov	r2, #170	; 0xaa
     ef0:	e5832000 	str	r2, [r3]
	PLLFEED = 0x55;
     ef4:	e59f3010 	ldr	r3, [pc, #16]	; f0c <feed+0x2c>
     ef8:	e3a02055 	mov	r2, #85	; 0x55
     efc:	e5832000 	str	r2, [r3]
}
     f00:	e28bd000 	add	sp, fp, #0
     f04:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
     f08:	e12fff1e 	bx	lr
     f0c:	e01fc08c 	.word	0xe01fc08c

00000f10 <Initialize>:


void Initialize(void)  
{
     f10:	e92d4800 	push	{fp, lr}
     f14:	e28db004 	add	fp, sp, #4
	// Final note: to load PLLCFG register, we must use the 0xAA followed 0x55 write sequence to the PLLFEED register
	//             this is done in the short function feed() below
	//
   
	// Setting Multiplier and Divider values
  	PLLCFG = 0x24;
     f18:	e59f3070 	ldr	r3, [pc, #112]	; f90 <Initialize+0x80>
     f1c:	e3a02024 	mov	r2, #36	; 0x24
     f20:	e5832000 	str	r2, [r3]
  	feed();
     f24:	ebffffed 	bl	ee0 <feed>
  
	// Enabling the PLL */	
	PLLCON = 0x1;
     f28:	e59f3064 	ldr	r3, [pc, #100]	; f94 <Initialize+0x84>
     f2c:	e3a02001 	mov	r2, #1
     f30:	e5832000 	str	r2, [r3]
	feed();
     f34:	ebffffe9 	bl	ee0 <feed>
  
	// Wait for the PLL to lock to set frequency
	while(!(PLLSTAT & PLOCK)) ;
     f38:	e1a00000 	nop			; (mov r0, r0)
     f3c:	e59f3054 	ldr	r3, [pc, #84]	; f98 <Initialize+0x88>
     f40:	e5933000 	ldr	r3, [r3]
     f44:	e2033b01 	and	r3, r3, #1024	; 0x400
     f48:	e3530000 	cmp	r3, #0
     f4c:	0afffffa 	beq	f3c <Initialize+0x2c>
  
	// Connect the PLL as the clock source
	PLLCON = 0x3;
     f50:	e59f303c 	ldr	r3, [pc, #60]	; f94 <Initialize+0x84>
     f54:	e3a02003 	mov	r2, #3
     f58:	e5832000 	str	r2, [r3]
	feed();
     f5c:	ebffffdf 	bl	ee0 <feed>
  
	// Enabling MAM and setting number of clocks used for Flash memory fetch
	MAMTIM = 0x3;
     f60:	e59f3034 	ldr	r3, [pc, #52]	; f9c <Initialize+0x8c>
     f64:	e3a02003 	mov	r2, #3
     f68:	e5832000 	str	r2, [r3]
	MAMCR = 0x2;
     f6c:	e59f302c 	ldr	r3, [pc, #44]	; fa0 <Initialize+0x90>
     f70:	e3a02002 	mov	r2, #2
     f74:	e5832000 	str	r2, [r3]
  
	// Setting peripheral Clock (pclk) to System Clock (cclk)
	VPBDIV = 0x1;
     f78:	e59f3024 	ldr	r3, [pc, #36]	; fa4 <Initialize+0x94>
     f7c:	e3a02001 	mov	r2, #1
     f80:	e5832000 	str	r2, [r3]
}
     f84:	e24bd004 	sub	sp, fp, #4
     f88:	e8bd4800 	pop	{fp, lr}
     f8c:	e12fff1e 	bx	lr
     f90:	e01fc084 	.word	0xe01fc084
     f94:	e01fc080 	.word	0xe01fc080
     f98:	e01fc088 	.word	0xe01fc088
     f9c:	e01fc004 	.word	0xe01fc004
     fa0:	e01fc000 	.word	0xe01fc000
     fa4:	e01fc100 	.word	0xe01fc100

00000fa8 <vUART_ISR_Wrapper>:
#define FCR_resetTXFIFO  0x02
#define N_UART_CHANNELS     2

void vUART_ISR_Wrapper(void)
{
  VICVectAddr = 0;
     fa8:	e59f3004 	ldr	r3, [pc, #4]	; fb4 <vUART_ISR_Wrapper+0xc>
     fac:	e3a02000 	mov	r2, #0
     fb0:	e5832000 	str	r2, [r3]
     fb4:	fffff030 	.word	0xfffff030

00000fb8 <UART_Init>:
}

void UART_Init(uint8_t channel, uint16_t baudrate)
{
     fb8:	e92d4800 	push	{fp, lr}
     fbc:	e28db004 	add	fp, sp, #4
     fc0:	e24dd010 	sub	sp, sp, #16
     fc4:	e1a02000 	mov	r2, r0
     fc8:	e1a03001 	mov	r3, r1
     fcc:	e54b200d 	strb	r2, [fp, #-13]
     fd0:	e14b31b0 	strh	r3, [fp, #-16]
  uint16_t Fdiv;

  PINSEL0 = 0x00050005; /* Habilita RxD1, TxD1, RxD0 e TxD0 */
     fd4:	e59f3080 	ldr	r3, [pc, #128]	; 105c <UART_Init+0xa4>
     fd8:	e59f2080 	ldr	r2, [pc, #128]	; 1060 <UART_Init+0xa8>
     fdc:	e5832000 	str	r2, [r3]

  U0LCR = 0x83; /* 8 bits, sem paridade, 1 Stop bit e o bit 7 é setado para configurar o divisor */
     fe0:	e59f307c 	ldr	r3, [pc, #124]	; 1064 <UART_Init+0xac>
     fe4:	e3a02083 	mov	r2, #131	; 0x83
     fe8:	e5832000 	str	r2, [r3]
  Fdiv = (60000000 / 16) / baudrate;
     fec:	e15b31b0 	ldrh	r3, [fp, #-16]
     ff0:	e59f0070 	ldr	r0, [pc, #112]	; 1068 <UART_Init+0xb0>
     ff4:	e1a01003 	mov	r1, r3
     ff8:	eb000768 	bl	2da0 <__aeabi_idiv>
     ffc:	e1a03000 	mov	r3, r0
    1000:	e14b30b6 	strh	r3, [fp, #-6]
  U0DLM = Fdiv / 256;  /* MSByte  */
    1004:	e59f3060 	ldr	r3, [pc, #96]	; 106c <UART_Init+0xb4>
    1008:	e15b20b6 	ldrh	r2, [fp, #-6]
    100c:	e1a02422 	lsr	r2, r2, #8
    1010:	e1a02802 	lsl	r2, r2, #16
    1014:	e1a02822 	lsr	r2, r2, #16
    1018:	e5832000 	str	r2, [r3]
  U0DLL = Fdiv % 256;  /* LSByte */
    101c:	e59f304c 	ldr	r3, [pc, #76]	; 1070 <UART_Init+0xb8>
    1020:	e15b20b6 	ldrh	r2, [fp, #-6]
    1024:	e20220ff 	and	r2, r2, #255	; 0xff
    1028:	e5832000 	str	r2, [r3]
  U0LCR = 0x03; /* DLAB = 0 */
    102c:	e59f3030 	ldr	r3, [pc, #48]	; 1064 <UART_Init+0xac>
    1030:	e3a02003 	mov	r2, #3
    1034:	e5832000 	str	r2, [r3]
  U0FCR = 0x07; /* Habilita e reseta TX e RX FIFO. */
    1038:	e59f3034 	ldr	r3, [pc, #52]	; 1074 <UART_Init+0xbc>
    103c:	e3a02007 	mov	r2, #7
    1040:	e5832000 	str	r2, [r3]
  U0TER = 0x80; /* Habilita Transmissão */
    1044:	e59f302c 	ldr	r3, [pc, #44]	; 1078 <UART_Init+0xc0>
    1048:	e3a02080 	mov	r2, #128	; 0x80
    104c:	e5832000 	str	r2, [r3]
//  VICIntSelect &= ~(1<<6);      //seleciona a se a interrupção sera FIQ ou IRQ para o timmer0
//  VICIntEnable |= (1 << 6);    //habilita a interrupção da UART
//
//  U0IER = 0x01|0x04;
//  enableIRQ();
}
    1050:	e24bd004 	sub	sp, fp, #4
    1054:	e8bd4800 	pop	{fp, lr}
    1058:	e12fff1e 	bx	lr
    105c:	e002c000 	.word	0xe002c000
    1060:	00050005 	.word	0x00050005
    1064:	e000c00c 	.word	0xe000c00c
    1068:	00393870 	.word	0x00393870
    106c:	e000c004 	.word	0xe000c004
    1070:	e000c000 	.word	0xe000c000
    1074:	e000c008 	.word	0xe000c008
    1078:	e000c030 	.word	0xe000c030

0000107c <UART_SendBuffer>:

void UART_SendBuffer(uint8_t channel,const uint8_t *Buffer, uint16_t size)
{
    107c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
    1080:	e28db000 	add	fp, sp, #0
    1084:	e24dd014 	sub	sp, sp, #20
    1088:	e50b100c 	str	r1, [fp, #-12]
    108c:	e1a03002 	mov	r3, r2
    1090:	e1a02000 	mov	r2, r0
    1094:	e54b2005 	strb	r2, [fp, #-5]
    1098:	e14b30be 	strh	r3, [fp, #-14]
  if(size > 0)
    109c:	e15b30be 	ldrh	r3, [fp, #-14]
    10a0:	e3530000 	cmp	r3, #0
    10a4:	0a000014 	beq	10fc <UART_SendBuffer+0x80>
  {
    do
    {
      while(!(U0LSR & LSR_TEMT)){} // Aguarda o registro ficar disponível
    10a8:	e1a00000 	nop			; (mov r0, r0)
    10ac:	ea000000 	b	10b4 <UART_SendBuffer+0x38>
    10b0:	e1a00000 	nop			; (mov r0, r0)
    10b4:	e59f304c 	ldr	r3, [pc, #76]	; 1108 <UART_SendBuffer+0x8c>
    10b8:	e5933000 	ldr	r3, [r3]
    10bc:	e2033040 	and	r3, r3, #64	; 0x40
    10c0:	e3530000 	cmp	r3, #0
    10c4:	0afffffa 	beq	10b4 <UART_SendBuffer+0x38>
      U0THR = *Buffer;
    10c8:	e59f303c 	ldr	r3, [pc, #60]	; 110c <UART_SendBuffer+0x90>
    10cc:	e51b200c 	ldr	r2, [fp, #-12]
    10d0:	e5d22000 	ldrb	r2, [r2]
    10d4:	e5832000 	str	r2, [r3]
      Buffer++;
    10d8:	e51b300c 	ldr	r3, [fp, #-12]
    10dc:	e2833001 	add	r3, r3, #1
    10e0:	e50b300c 	str	r3, [fp, #-12]
      size--;
    10e4:	e15b30be 	ldrh	r3, [fp, #-14]
    10e8:	e2433001 	sub	r3, r3, #1
    10ec:	e14b30be 	strh	r3, [fp, #-14]
    }while(size > 0);
    10f0:	e15b30be 	ldrh	r3, [fp, #-14]
    10f4:	e3530000 	cmp	r3, #0
    10f8:	1affffec 	bne	10b0 <UART_SendBuffer+0x34>
  }
}
    10fc:	e28bd000 	add	sp, fp, #0
    1100:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
    1104:	e12fff1e 	bx	lr
    1108:	e000c014 	.word	0xe000c014
    110c:	e000c000 	.word	0xe000c000

00001110 <UART_putc>:

void UART_putc(char c)
{
    1110:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
    1114:	e28db000 	add	fp, sp, #0
    1118:	e24dd00c 	sub	sp, sp, #12
    111c:	e1a03000 	mov	r3, r0
    1120:	e54b3005 	strb	r3, [fp, #-5]
  while(!(U0LSR & LSR_TEMT)){} // Aguarda o registro ficar disponível
    1124:	e1a00000 	nop			; (mov r0, r0)
    1128:	e59f3024 	ldr	r3, [pc, #36]	; 1154 <UART_putc+0x44>
    112c:	e5933000 	ldr	r3, [r3]
    1130:	e2033040 	and	r3, r3, #64	; 0x40
    1134:	e3530000 	cmp	r3, #0
    1138:	0afffffa 	beq	1128 <UART_putc+0x18>
  U0THR = c;
    113c:	e59f3014 	ldr	r3, [pc, #20]	; 1158 <UART_putc+0x48>
    1140:	e55b2005 	ldrb	r2, [fp, #-5]
    1144:	e5832000 	str	r2, [r3]
}
    1148:	e28bd000 	add	sp, fp, #0
    114c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
    1150:	e12fff1e 	bx	lr
    1154:	e000c014 	.word	0xe000c014
    1158:	e000c000 	.word	0xe000c000

0000115c <UART_ReceiveBuffer>:

uint16_t UART_ReceiveBuffer(uint8_t channel, uint8_t *Buffer, uint16_t size)
{
    115c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
    1160:	e28db000 	add	fp, sp, #0
    1164:	e24dd01c 	sub	sp, sp, #28
    1168:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    116c:	e1a03002 	mov	r3, r2
    1170:	e1a02000 	mov	r2, r0
    1174:	e54b200d 	strb	r2, [fp, #-13]
    1178:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
  uint16_t available = 0;
    117c:	e3a03000 	mov	r3, #0
    1180:	e14b30b6 	strh	r3, [fp, #-6]

  if (U0LSR & LSR_RDR) //Verifica a existência de um dado valido
    1184:	e59f306c 	ldr	r3, [pc, #108]	; 11f8 <UART_ReceiveBuffer+0x9c>
    1188:	e5933000 	ldr	r3, [r3]
    118c:	e2033001 	and	r3, r3, #1
    1190:	e20330ff 	and	r3, r3, #255	; 0xff
    1194:	e3530000 	cmp	r3, #0
    1198:	0a000011 	beq	11e4 <UART_ReceiveBuffer+0x88>
  {
    while (size > 0)
    119c:	ea00000d 	b	11d8 <UART_ReceiveBuffer+0x7c>
    {
      *Buffer++ = U0RBR;
    11a0:	e59f3054 	ldr	r3, [pc, #84]	; 11fc <UART_ReceiveBuffer+0xa0>
    11a4:	e5933000 	ldr	r3, [r3]
    11a8:	e20320ff 	and	r2, r3, #255	; 0xff
    11ac:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
    11b0:	e5c32000 	strb	r2, [r3]
    11b4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
    11b8:	e2833001 	add	r3, r3, #1
    11bc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
      size--;
    11c0:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
    11c4:	e2433001 	sub	r3, r3, #1
    11c8:	e14b31b6 	strh	r3, [fp, #-22]	; 0xffffffea
      available++;
    11cc:	e15b30b6 	ldrh	r3, [fp, #-6]
    11d0:	e2833001 	add	r3, r3, #1
    11d4:	e14b30b6 	strh	r3, [fp, #-6]
{
  uint16_t available = 0;

  if (U0LSR & LSR_RDR) //Verifica a existência de um dado valido
  {
    while (size > 0)
    11d8:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
    11dc:	e3530000 	cmp	r3, #0
    11e0:	1affffee 	bne	11a0 <UART_ReceiveBuffer+0x44>
      *Buffer++ = U0RBR;
      size--;
      available++;
    }
  }
  return available;
    11e4:	e15b30b6 	ldrh	r3, [fp, #-6]
}
    11e8:	e1a00003 	mov	r0, r3
    11ec:	e28bd000 	add	sp, fp, #0
    11f0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
    11f4:	e12fff1e 	bx	lr
    11f8:	e000c014 	.word	0xe000c014
    11fc:	e000c000 	.word	0xe000c000

00001200 <_HandleRequest>:
	@param [in,out]	ppbData		Data buffer.

	@return TRUE if the request was handles successfully
 */
static BOOL _HandleRequest(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
    1200:	e92d4800 	push	{fp, lr}
    1204:	e28db004 	add	fp, sp, #4
    1208:	e24dd018 	sub	sp, sp, #24
    120c:	e50b0010 	str	r0, [fp, #-16]
    1210:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    1214:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
	TFnHandleRequest *pfnHandler;
	int iType;

	iType = REQTYPE_GET_TYPE(pSetup->bmRequestType);
    1218:	e51b3010 	ldr	r3, [fp, #-16]
    121c:	e5d33000 	ldrb	r3, [r3]
    1220:	e1a032a3 	lsr	r3, r3, #5
    1224:	e20330ff 	and	r3, r3, #255	; 0xff
    1228:	e2033003 	and	r3, r3, #3
    122c:	e50b3008 	str	r3, [fp, #-8]
	pfnHandler = apfnReqHandlers[iType];
    1230:	e59f3054 	ldr	r3, [pc, #84]	; 128c <_HandleRequest+0x8c>
    1234:	e51b2008 	ldr	r2, [fp, #-8]
    1238:	e7933102 	ldr	r3, [r3, r2, lsl #2]
    123c:	e50b300c 	str	r3, [fp, #-12]
	if (pfnHandler == NULL) {
    1240:	e51b300c 	ldr	r3, [fp, #-12]
    1244:	e3530000 	cmp	r3, #0
    1248:	1a000004 	bne	1260 <_HandleRequest+0x60>
//		DBG("No handler for reqtype %d\n", iType);
	  TRACE_DEBUG("No handler for reqtype %d\n", iType);
    124c:	e59f003c 	ldr	r0, [pc, #60]	; 1290 <_HandleRequest+0x90>
    1250:	e51b1008 	ldr	r1, [fp, #-8]
    1254:	ebfffd7b 	bl	848 <iprintf>
		return FALSE;
    1258:	e3a03000 	mov	r3, #0
    125c:	ea000006 	b	127c <_HandleRequest+0x7c>
	}

	return pfnHandler(pSetup, piLen, ppbData);
    1260:	e51b300c 	ldr	r3, [fp, #-12]
    1264:	e51b0010 	ldr	r0, [fp, #-16]
    1268:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
    126c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
    1270:	e1a0e00f 	mov	lr, pc
    1274:	e12fff13 	bx	r3
    1278:	e1a03000 	mov	r3, r0
}
    127c:	e1a00003 	mov	r0, r3
    1280:	e24bd004 	sub	sp, fp, #4
    1284:	e8bd4800 	pop	{fp, lr}
    1288:	e12fff1e 	bx	lr
    128c:	40000260 	.word	0x40000260
    1290:	00003008 	.word	0x00003008

00001294 <StallControlPipe>:
	Local function to stall the control endpoint

	@param [in]	bEPStat	Endpoint status
 */
static void StallControlPipe(U8 bEPStat)
{
    1294:	e92d4800 	push	{fp, lr}
    1298:	e28db004 	add	fp, sp, #4
    129c:	e24dd010 	sub	sp, sp, #16
    12a0:	e1a03000 	mov	r3, r0
    12a4:	e54b300d 	strb	r3, [fp, #-13]
	U8	*pb;
	int	i;

	USBHwEPStall(0x80, TRUE);
    12a8:	e3a00080 	mov	r0, #128	; 0x80
    12ac:	e3a01001 	mov	r1, #1
    12b0:	eb000274 	bl	1c88 <USBHwEPStall>

// dump setup packet
//	DBG("STALL on [");
	TRACE_DEBUG("STALL on [");
    12b4:	e59f0068 	ldr	r0, [pc, #104]	; 1324 <StallControlPipe+0x90>
    12b8:	ebfffd62 	bl	848 <iprintf>
	pb = (U8 *)&Setup;
    12bc:	e59f3064 	ldr	r3, [pc, #100]	; 1328 <StallControlPipe+0x94>
    12c0:	e50b3008 	str	r3, [fp, #-8]
	for (i = 0; i < 8; i++) {
    12c4:	e3a03000 	mov	r3, #0
    12c8:	e50b300c 	str	r3, [fp, #-12]
    12cc:	ea00000a 	b	12fc <StallControlPipe+0x68>
		DBG(" %02x", *pb++);
    12d0:	e51b3008 	ldr	r3, [fp, #-8]
    12d4:	e5d33000 	ldrb	r3, [r3]
    12d8:	e51b2008 	ldr	r2, [fp, #-8]
    12dc:	e2822001 	add	r2, r2, #1
    12e0:	e50b2008 	str	r2, [fp, #-8]
    12e4:	e59f0040 	ldr	r0, [pc, #64]	; 132c <StallControlPipe+0x98>
    12e8:	e1a01003 	mov	r1, r3
    12ec:	ebfffd55 	bl	848 <iprintf>

// dump setup packet
//	DBG("STALL on [");
	TRACE_DEBUG("STALL on [");
	pb = (U8 *)&Setup;
	for (i = 0; i < 8; i++) {
    12f0:	e51b300c 	ldr	r3, [fp, #-12]
    12f4:	e2833001 	add	r3, r3, #1
    12f8:	e50b300c 	str	r3, [fp, #-12]
    12fc:	e51b300c 	ldr	r3, [fp, #-12]
    1300:	e3530007 	cmp	r3, #7
    1304:	dafffff1 	ble	12d0 <StallControlPipe+0x3c>
		DBG(" %02x", *pb++);
	}
//	DBG("] stat=%x\n", bEPStat);
	TRACE_DEBUG(" ] stat=%x\n", bEPStat);
    1308:	e55b300d 	ldrb	r3, [fp, #-13]
    130c:	e59f001c 	ldr	r0, [pc, #28]	; 1330 <StallControlPipe+0x9c>
    1310:	e1a01003 	mov	r1, r3
    1314:	ebfffd4b 	bl	848 <iprintf>
}
    1318:	e24bd004 	sub	sp, fp, #4
    131c:	e8bd4800 	pop	{fp, lr}
    1320:	e12fff1e 	bx	lr
    1324:	0000302c 	.word	0x0000302c
    1328:	4000024c 	.word	0x4000024c
    132c:	00003040 	.word	0x00003040
    1330:	00003048 	.word	0x00003048

00001334 <DataIn>:

/**
	Sends next chunk of data (possibly 0 bytes) to host
 */
static void DataIn(void)
{
    1334:	e92d4800 	push	{fp, lr}
    1338:	e28db004 	add	fp, sp, #4
    133c:	e24dd008 	sub	sp, sp, #8
	int iChunk;

	iChunk = MIN(MAX_PACKET_SIZE0, iResidue);
    1340:	e59f3060 	ldr	r3, [pc, #96]	; 13a8 <DataIn+0x74>
    1344:	e5933000 	ldr	r3, [r3]
    1348:	e3530040 	cmp	r3, #64	; 0x40
    134c:	a3a03040 	movge	r3, #64	; 0x40
    1350:	e50b3008 	str	r3, [fp, #-8]
	USBHwEPWrite(0x80, pbData, iChunk);
    1354:	e59f3050 	ldr	r3, [pc, #80]	; 13ac <DataIn+0x78>
    1358:	e5933000 	ldr	r3, [r3]
    135c:	e3a00080 	mov	r0, #128	; 0x80
    1360:	e1a01003 	mov	r1, r3
    1364:	e51b2008 	ldr	r2, [fp, #-8]
    1368:	eb000265 	bl	1d04 <USBHwEPWrite>
	pbData += iChunk;
    136c:	e59f3038 	ldr	r3, [pc, #56]	; 13ac <DataIn+0x78>
    1370:	e5932000 	ldr	r2, [r3]
    1374:	e51b3008 	ldr	r3, [fp, #-8]
    1378:	e0822003 	add	r2, r2, r3
    137c:	e59f3028 	ldr	r3, [pc, #40]	; 13ac <DataIn+0x78>
    1380:	e5832000 	str	r2, [r3]
	iResidue -= iChunk;
    1384:	e59f301c 	ldr	r3, [pc, #28]	; 13a8 <DataIn+0x74>
    1388:	e5932000 	ldr	r2, [r3]
    138c:	e51b3008 	ldr	r3, [fp, #-8]
    1390:	e0632002 	rsb	r2, r3, r2
    1394:	e59f300c 	ldr	r3, [pc, #12]	; 13a8 <DataIn+0x74>
    1398:	e5832000 	str	r2, [r3]
}
    139c:	e24bd004 	sub	sp, fp, #4
    13a0:	e8bd4800 	pop	{fp, lr}
    13a4:	e12fff1e 	bx	lr
    13a8:	40000258 	.word	0x40000258
    13ac:	40000254 	.word	0x40000254

000013b0 <USBHandleControlTransfer>:
 *
 *	@param [in]	bEP		Endpoint address
 *	@param [in]	bEPStat	Endpoint status
 */
void USBHandleControlTransfer(U8 bEP, U8 bEPStat)
{
    13b0:	e92d4800 	push	{fp, lr}
    13b4:	e28db004 	add	fp, sp, #4
    13b8:	e24dd018 	sub	sp, sp, #24
    13bc:	e1a02000 	mov	r2, r0
    13c0:	e1a03001 	mov	r3, r1
    13c4:	e54b200d 	strb	r2, [fp, #-13]
    13c8:	e54b300e 	strb	r3, [fp, #-14]
	int iChunk, iType;

	if (bEP == 0x00) {
    13cc:	e55b300d 	ldrb	r3, [fp, #-13]
    13d0:	e3530000 	cmp	r3, #0
    13d4:	1a000095 	bne	1630 <USBHandleControlTransfer+0x280>
		// OUT transfer
		if (bEPStat & EP_STATUS_SETUP) {
    13d8:	e55b300e 	ldrb	r3, [fp, #-14]
    13dc:	e2033004 	and	r3, r3, #4
    13e0:	e3530000 	cmp	r3, #0
    13e4:	0a000041 	beq	14f0 <USBHandleControlTransfer+0x140>
			// setup packet, reset request message state machine
			USBHwEPRead(0x00, (U8 *)&Setup, sizeof(Setup));
    13e8:	e3a00000 	mov	r0, #0
    13ec:	e59f127c 	ldr	r1, [pc, #636]	; 1670 <USBHandleControlTransfer+0x2c0>
    13f0:	e3a02008 	mov	r2, #8
    13f4:	eb000284 	bl	1e0c <USBHwEPRead>
//			DBG("S%x", Setup.bRequest);
			TRACE_DEBUG("S%x", Setup.bRequest);
    13f8:	e59f3270 	ldr	r3, [pc, #624]	; 1670 <USBHandleControlTransfer+0x2c0>
    13fc:	e5d33001 	ldrb	r3, [r3, #1]
    1400:	e59f026c 	ldr	r0, [pc, #620]	; 1674 <USBHandleControlTransfer+0x2c4>
    1404:	e1a01003 	mov	r1, r3
    1408:	ebfffd0e 	bl	848 <iprintf>

			// defaults for data pointer and residue
			iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
    140c:	e59f325c 	ldr	r3, [pc, #604]	; 1670 <USBHandleControlTransfer+0x2c0>
    1410:	e5d33000 	ldrb	r3, [r3]
    1414:	e1a032a3 	lsr	r3, r3, #5
    1418:	e20330ff 	and	r3, r3, #255	; 0xff
    141c:	e2033003 	and	r3, r3, #3
    1420:	e50b3008 	str	r3, [fp, #-8]
			pbData = apbDataStore[iType];
    1424:	e59f324c 	ldr	r3, [pc, #588]	; 1678 <USBHandleControlTransfer+0x2c8>
    1428:	e51b2008 	ldr	r2, [fp, #-8]
    142c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
    1430:	e59f3244 	ldr	r3, [pc, #580]	; 167c <USBHandleControlTransfer+0x2cc>
    1434:	e5832000 	str	r2, [r3]
			iResidue = Setup.wLength;
    1438:	e59f3230 	ldr	r3, [pc, #560]	; 1670 <USBHandleControlTransfer+0x2c0>
    143c:	e1d330b6 	ldrh	r3, [r3, #6]
    1440:	e1a02003 	mov	r2, r3
    1444:	e59f3234 	ldr	r3, [pc, #564]	; 1680 <USBHandleControlTransfer+0x2d0>
    1448:	e5832000 	str	r2, [r3]
			iLen = Setup.wLength;
    144c:	e59f321c 	ldr	r3, [pc, #540]	; 1670 <USBHandleControlTransfer+0x2c0>
    1450:	e1d330b6 	ldrh	r3, [r3, #6]
    1454:	e1a02003 	mov	r2, r3
    1458:	e59f3224 	ldr	r3, [pc, #548]	; 1684 <USBHandleControlTransfer+0x2d4>
    145c:	e5832000 	str	r2, [r3]

			if ((Setup.wLength == 0) ||
    1460:	e59f3208 	ldr	r3, [pc, #520]	; 1670 <USBHandleControlTransfer+0x2c0>
    1464:	e1d330b6 	ldrh	r3, [r3, #6]
    1468:	e3530000 	cmp	r3, #0
    146c:	0a000007 	beq	1490 <USBHandleControlTransfer+0xe0>
				(REQTYPE_GET_DIR(Setup.bmRequestType) == REQTYPE_DIR_TO_HOST)) {
    1470:	e59f31f8 	ldr	r3, [pc, #504]	; 1670 <USBHandleControlTransfer+0x2c0>
    1474:	e5d33000 	ldrb	r3, [r3]
    1478:	e1a033a3 	lsr	r3, r3, #7
    147c:	e20330ff 	and	r3, r3, #255	; 0xff
    1480:	e2033001 	and	r3, r3, #1
    1484:	e20330ff 	and	r3, r3, #255	; 0xff
			iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
			pbData = apbDataStore[iType];
			iResidue = Setup.wLength;
			iLen = Setup.wLength;

			if ((Setup.wLength == 0) ||
    1488:	e3530000 	cmp	r3, #0
    148c:	0a000074 	beq	1664 <USBHandleControlTransfer+0x2b4>
				(REQTYPE_GET_DIR(Setup.bmRequestType) == REQTYPE_DIR_TO_HOST)) {
				// ask installed handler to process request
				if (!_HandleRequest(&Setup, &iLen, &pbData)) {
    1490:	e59f01d8 	ldr	r0, [pc, #472]	; 1670 <USBHandleControlTransfer+0x2c0>
    1494:	e59f11e8 	ldr	r1, [pc, #488]	; 1684 <USBHandleControlTransfer+0x2d4>
    1498:	e59f21dc 	ldr	r2, [pc, #476]	; 167c <USBHandleControlTransfer+0x2cc>
    149c:	ebffff57 	bl	1200 <_HandleRequest>
    14a0:	e1a03000 	mov	r3, r0
    14a4:	e3530000 	cmp	r3, #0
    14a8:	1a000005 	bne	14c4 <USBHandleControlTransfer+0x114>
//					DBG("_HandleRequest1 failed\n");
				  TRACE_DEBUG("_HandleRequest1 failed\n");
    14ac:	e59f01d4 	ldr	r0, [pc, #468]	; 1688 <USBHandleControlTransfer+0x2d8>
    14b0:	ebfffce4 	bl	848 <iprintf>
					StallControlPipe(bEPStat);
    14b4:	e55b300e 	ldrb	r3, [fp, #-14]
    14b8:	e1a00003 	mov	r0, r3
    14bc:	ebffff74 	bl	1294 <StallControlPipe>
					return;
    14c0:	ea000067 	b	1664 <USBHandleControlTransfer+0x2b4>
				}
				// send smallest of requested and offered length
				iResidue = MIN(iLen, Setup.wLength);
    14c4:	e59f31a4 	ldr	r3, [pc, #420]	; 1670 <USBHandleControlTransfer+0x2c0>
    14c8:	e1d330b6 	ldrh	r3, [r3, #6]
    14cc:	e1a02003 	mov	r2, r3
    14d0:	e59f31ac 	ldr	r3, [pc, #428]	; 1684 <USBHandleControlTransfer+0x2d4>
    14d4:	e5933000 	ldr	r3, [r3]
    14d8:	e1520003 	cmp	r2, r3
    14dc:	a1a02003 	movge	r2, r3
    14e0:	e59f3198 	ldr	r3, [pc, #408]	; 1680 <USBHandleControlTransfer+0x2d0>
    14e4:	e5832000 	str	r2, [r3]
				// send first part (possibly a zero-length status message)
				DataIn();
    14e8:	ebffff91 	bl	1334 <DataIn>
    14ec:	ea00005c 	b	1664 <USBHandleControlTransfer+0x2b4>
			}
		}
		else {
			if (iResidue > 0) {
    14f0:	e59f3188 	ldr	r3, [pc, #392]	; 1680 <USBHandleControlTransfer+0x2d0>
    14f4:	e5933000 	ldr	r3, [r3]
    14f8:	e3530000 	cmp	r3, #0
    14fc:	da00003b 	ble	15f0 <USBHandleControlTransfer+0x240>
				// store data
				iChunk = USBHwEPRead(0x00, pbData, iResidue);
    1500:	e59f3174 	ldr	r3, [pc, #372]	; 167c <USBHandleControlTransfer+0x2cc>
    1504:	e5932000 	ldr	r2, [r3]
    1508:	e59f3170 	ldr	r3, [pc, #368]	; 1680 <USBHandleControlTransfer+0x2d0>
    150c:	e5933000 	ldr	r3, [r3]
    1510:	e3a00000 	mov	r0, #0
    1514:	e1a01002 	mov	r1, r2
    1518:	e1a02003 	mov	r2, r3
    151c:	eb00023a 	bl	1e0c <USBHwEPRead>
    1520:	e50b000c 	str	r0, [fp, #-12]
				if (iChunk < 0) {
    1524:	e51b300c 	ldr	r3, [fp, #-12]
    1528:	e3530000 	cmp	r3, #0
    152c:	aa000003 	bge	1540 <USBHandleControlTransfer+0x190>
					StallControlPipe(bEPStat);
    1530:	e55b300e 	ldrb	r3, [fp, #-14]
    1534:	e1a00003 	mov	r0, r3
    1538:	ebffff55 	bl	1294 <StallControlPipe>
					return;
    153c:	ea000048 	b	1664 <USBHandleControlTransfer+0x2b4>
				}
				pbData += iChunk;
    1540:	e59f3134 	ldr	r3, [pc, #308]	; 167c <USBHandleControlTransfer+0x2cc>
    1544:	e5932000 	ldr	r2, [r3]
    1548:	e51b300c 	ldr	r3, [fp, #-12]
    154c:	e0822003 	add	r2, r2, r3
    1550:	e59f3124 	ldr	r3, [pc, #292]	; 167c <USBHandleControlTransfer+0x2cc>
    1554:	e5832000 	str	r2, [r3]
				iResidue -= iChunk;
    1558:	e59f3120 	ldr	r3, [pc, #288]	; 1680 <USBHandleControlTransfer+0x2d0>
    155c:	e5932000 	ldr	r2, [r3]
    1560:	e51b300c 	ldr	r3, [fp, #-12]
    1564:	e0632002 	rsb	r2, r3, r2
    1568:	e59f3110 	ldr	r3, [pc, #272]	; 1680 <USBHandleControlTransfer+0x2d0>
    156c:	e5832000 	str	r2, [r3]
				if (iResidue == 0) {
    1570:	e59f3108 	ldr	r3, [pc, #264]	; 1680 <USBHandleControlTransfer+0x2d0>
    1574:	e5933000 	ldr	r3, [r3]
    1578:	e3530000 	cmp	r3, #0
    157c:	1a000038 	bne	1664 <USBHandleControlTransfer+0x2b4>
					// received all, send data to handler
					iType = REQTYPE_GET_TYPE(Setup.bmRequestType);
    1580:	e59f30e8 	ldr	r3, [pc, #232]	; 1670 <USBHandleControlTransfer+0x2c0>
    1584:	e5d33000 	ldrb	r3, [r3]
    1588:	e1a032a3 	lsr	r3, r3, #5
    158c:	e20330ff 	and	r3, r3, #255	; 0xff
    1590:	e2033003 	and	r3, r3, #3
    1594:	e50b3008 	str	r3, [fp, #-8]
					pbData = apbDataStore[iType];
    1598:	e59f30d8 	ldr	r3, [pc, #216]	; 1678 <USBHandleControlTransfer+0x2c8>
    159c:	e51b2008 	ldr	r2, [fp, #-8]
    15a0:	e7932102 	ldr	r2, [r3, r2, lsl #2]
    15a4:	e59f30d0 	ldr	r3, [pc, #208]	; 167c <USBHandleControlTransfer+0x2cc>
    15a8:	e5832000 	str	r2, [r3]
					if (!_HandleRequest(&Setup, &iLen, &pbData)) {
    15ac:	e59f00bc 	ldr	r0, [pc, #188]	; 1670 <USBHandleControlTransfer+0x2c0>
    15b0:	e59f10cc 	ldr	r1, [pc, #204]	; 1684 <USBHandleControlTransfer+0x2d4>
    15b4:	e59f20c0 	ldr	r2, [pc, #192]	; 167c <USBHandleControlTransfer+0x2cc>
    15b8:	ebffff10 	bl	1200 <_HandleRequest>
    15bc:	e1a03000 	mov	r3, r0
    15c0:	e3530000 	cmp	r3, #0
    15c4:	1a000007 	bne	15e8 <USBHandleControlTransfer+0x238>
						DBG("_HandleRequest2 failed\n");
    15c8:	e59f00bc 	ldr	r0, [pc, #188]	; 168c <USBHandleControlTransfer+0x2dc>
    15cc:	ebfffc9d 	bl	848 <iprintf>
						TRACE_DEBUG("_HandleRequest2 failed\n");
    15d0:	e59f00b8 	ldr	r0, [pc, #184]	; 1690 <USBHandleControlTransfer+0x2e0>
    15d4:	ebfffc9b 	bl	848 <iprintf>
						StallControlPipe(bEPStat);
    15d8:	e55b300e 	ldrb	r3, [fp, #-14]
    15dc:	e1a00003 	mov	r0, r3
    15e0:	ebffff2b 	bl	1294 <StallControlPipe>
						return;
    15e4:	ea00001e 	b	1664 <USBHandleControlTransfer+0x2b4>
					}
					// send status to host
					DataIn();
    15e8:	ebffff51 	bl	1334 <DataIn>
    15ec:	ea00001c 	b	1664 <USBHandleControlTransfer+0x2b4>
				}
			}
			else {
				// absorb zero-length status message
				iChunk = USBHwEPRead(0x00, NULL, 0);
    15f0:	e3a00000 	mov	r0, #0
    15f4:	e3a01000 	mov	r1, #0
    15f8:	e3a02000 	mov	r2, #0
    15fc:	eb000202 	bl	1e0c <USBHwEPRead>
    1600:	e50b000c 	str	r0, [fp, #-12]
				DBG(iChunk > 0 ? "?" : "");
    1604:	e51b300c 	ldr	r3, [fp, #-12]
    1608:	e3530000 	cmp	r3, #0
    160c:	da000001 	ble	1618 <USBHandleControlTransfer+0x268>
    1610:	e59f307c 	ldr	r3, [pc, #124]	; 1694 <USBHandleControlTransfer+0x2e4>
    1614:	ea000000 	b	161c <USBHandleControlTransfer+0x26c>
    1618:	e59f3078 	ldr	r3, [pc, #120]	; 1698 <USBHandleControlTransfer+0x2e8>
    161c:	e1a00003 	mov	r0, r3
    1620:	ebfffc88 	bl	848 <iprintf>
				TRACE_DEBUG("\r\n");
    1624:	e59f0070 	ldr	r0, [pc, #112]	; 169c <USBHandleControlTransfer+0x2ec>
    1628:	ebfffc86 	bl	848 <iprintf>
    162c:	ea00000c 	b	1664 <USBHandleControlTransfer+0x2b4>
			}
		}
	}
	else if (bEP == 0x80) {
    1630:	e55b300d 	ldrb	r3, [fp, #-13]
    1634:	e3530080 	cmp	r3, #128	; 0x80
    1638:	1a000001 	bne	1644 <USBHandleControlTransfer+0x294>
		// IN transfer
		// send more data if available (possibly a 0-length packet)
		DataIn();
    163c:	ebffff3c 	bl	1334 <DataIn>
    1640:	ea000007 	b	1664 <USBHandleControlTransfer+0x2b4>
	}
	else {
		ASSERT(FALSE);
    1644:	e3a030db 	mov	r3, #219	; 0xdb
    1648:	e58d3000 	str	r3, [sp]
    164c:	e59f004c 	ldr	r0, [pc, #76]	; 16a0 <USBHandleControlTransfer+0x2f0>
    1650:	e59f104c 	ldr	r1, [pc, #76]	; 16a4 <USBHandleControlTransfer+0x2f4>
    1654:	e59f204c 	ldr	r2, [pc, #76]	; 16a8 <USBHandleControlTransfer+0x2f8>
    1658:	e59f304c 	ldr	r3, [pc, #76]	; 16ac <USBHandleControlTransfer+0x2fc>
    165c:	ebfffc79 	bl	848 <iprintf>
    1660:	eafffffe 	b	1660 <USBHandleControlTransfer+0x2b0>
	}
}
    1664:	e24bd004 	sub	sp, fp, #4
    1668:	e8bd4800 	pop	{fp, lr}
    166c:	e12fff1e 	bx	lr
    1670:	4000024c 	.word	0x4000024c
    1674:	0000305c 	.word	0x0000305c
    1678:	40000270 	.word	0x40000270
    167c:	40000254 	.word	0x40000254
    1680:	40000258 	.word	0x40000258
    1684:	4000025c 	.word	0x4000025c
    1688:	00003068 	.word	0x00003068
    168c:	00003088 	.word	0x00003088
    1690:	000030a0 	.word	0x000030a0
    1694:	000030c0 	.word	0x000030c0
    1698:	000030c4 	.word	0x000030c4
    169c:	000030c8 	.word	0x000030c8
    16a0:	000030d4 	.word	0x000030d4
    16a4:	000030fc 	.word	0x000030fc
    16a8:	00003104 	.word	0x00003104
    16ac:	00003148 	.word	0x00003148

000016b0 <USBRegisterRequestHandler>:
	@param [in]	iType			Type of request, e.g. REQTYPE_TYPE_STANDARD
	@param [in]	*pfnHandler		Callback function pointer
	@param [in]	*pbDataStore	Data storage area for this type of request
 */
void USBRegisterRequestHandler(int iType, TFnHandleRequest *pfnHandler, U8 *pbDataStore)
{
    16b0:	e92d4800 	push	{fp, lr}
    16b4:	e28db004 	add	fp, sp, #4
    16b8:	e24dd018 	sub	sp, sp, #24
    16bc:	e50b0008 	str	r0, [fp, #-8]
    16c0:	e50b100c 	str	r1, [fp, #-12]
    16c4:	e50b2010 	str	r2, [fp, #-16]
	ASSERT(iType >= 0);
    16c8:	e51b3008 	ldr	r3, [fp, #-8]
    16cc:	e3530000 	cmp	r3, #0
    16d0:	aa000007 	bge	16f4 <USBRegisterRequestHandler+0x44>
    16d4:	e3a030e9 	mov	r3, #233	; 0xe9
    16d8:	e58d3000 	str	r3, [sp]
    16dc:	e59f0068 	ldr	r0, [pc, #104]	; 174c <USBRegisterRequestHandler+0x9c>
    16e0:	e59f1068 	ldr	r1, [pc, #104]	; 1750 <USBRegisterRequestHandler+0xa0>
    16e4:	e59f2068 	ldr	r2, [pc, #104]	; 1754 <USBRegisterRequestHandler+0xa4>
    16e8:	e59f3068 	ldr	r3, [pc, #104]	; 1758 <USBRegisterRequestHandler+0xa8>
    16ec:	ebfffc55 	bl	848 <iprintf>
    16f0:	eafffffe 	b	16f0 <USBRegisterRequestHandler+0x40>
	ASSERT(iType < 4);
    16f4:	e51b3008 	ldr	r3, [fp, #-8]
    16f8:	e3530003 	cmp	r3, #3
    16fc:	da000007 	ble	1720 <USBRegisterRequestHandler+0x70>
    1700:	e3a030ea 	mov	r3, #234	; 0xea
    1704:	e58d3000 	str	r3, [sp]
    1708:	e59f003c 	ldr	r0, [pc, #60]	; 174c <USBRegisterRequestHandler+0x9c>
    170c:	e59f1048 	ldr	r1, [pc, #72]	; 175c <USBRegisterRequestHandler+0xac>
    1710:	e59f203c 	ldr	r2, [pc, #60]	; 1754 <USBRegisterRequestHandler+0xa4>
    1714:	e59f303c 	ldr	r3, [pc, #60]	; 1758 <USBRegisterRequestHandler+0xa8>
    1718:	ebfffc4a 	bl	848 <iprintf>
    171c:	eafffffe 	b	171c <USBRegisterRequestHandler+0x6c>
	apfnReqHandlers[iType] = pfnHandler;
    1720:	e59f3038 	ldr	r3, [pc, #56]	; 1760 <USBRegisterRequestHandler+0xb0>
    1724:	e51b2008 	ldr	r2, [fp, #-8]
    1728:	e51b100c 	ldr	r1, [fp, #-12]
    172c:	e7831102 	str	r1, [r3, r2, lsl #2]
	apbDataStore[iType] = pbDataStore;
    1730:	e59f302c 	ldr	r3, [pc, #44]	; 1764 <USBRegisterRequestHandler+0xb4>
    1734:	e51b2008 	ldr	r2, [fp, #-8]
    1738:	e51b1010 	ldr	r1, [fp, #-16]
    173c:	e7831102 	str	r1, [r3, r2, lsl #2]
}
    1740:	e24bd004 	sub	sp, fp, #4
    1744:	e8bd4800 	pop	{fp, lr}
    1748:	e12fff1e 	bx	lr
    174c:	000030d4 	.word	0x000030d4
    1750:	00003114 	.word	0x00003114
    1754:	00003104 	.word	0x00003104
    1758:	0000312c 	.word	0x0000312c
    175c:	00003120 	.word	0x00003120
    1760:	40000260 	.word	0x40000260
    1764:	40000270 	.word	0x40000270

00001768 <Wait4DevInt>:
	Local function to wait for a device interrupt (and clear it)

	@param [in]	dwIntr		Bitmask of interrupts to wait for
 */
static void Wait4DevInt(U32 dwIntr)
{
    1768:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
    176c:	e28db000 	add	fp, sp, #0
    1770:	e24dd00c 	sub	sp, sp, #12
    1774:	e50b0008 	str	r0, [fp, #-8]
	// wait for specific interrupt
	while ((USBDevIntSt & dwIntr) != dwIntr);
    1778:	e1a00000 	nop			; (mov r0, r0)
    177c:	e59f302c 	ldr	r3, [pc, #44]	; 17b0 <Wait4DevInt+0x48>
    1780:	e5932000 	ldr	r2, [r3]
    1784:	e51b3008 	ldr	r3, [fp, #-8]
    1788:	e0022003 	and	r2, r2, r3
    178c:	e51b3008 	ldr	r3, [fp, #-8]
    1790:	e1520003 	cmp	r2, r3
    1794:	1afffff8 	bne	177c <Wait4DevInt+0x14>
	// clear the interrupt bits
	USBDevIntClr = dwIntr;
    1798:	e59f3014 	ldr	r3, [pc, #20]	; 17b4 <Wait4DevInt+0x4c>
    179c:	e51b2008 	ldr	r2, [fp, #-8]
    17a0:	e5832000 	str	r2, [r3]
}
    17a4:	e28bd000 	add	sp, fp, #0
    17a8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
    17ac:	e12fff1e 	bx	lr
    17b0:	e0090000 	.word	0xe0090000
    17b4:	e0090008 	.word	0xe0090008

000017b8 <USBHwCmd>:
	Local function to send a command to the USB protocol engine

	@param [in]	bCmd		Command to send
 */
static void USBHwCmd(U8 bCmd)
{
    17b8:	e92d4800 	push	{fp, lr}
    17bc:	e28db004 	add	fp, sp, #4
    17c0:	e24dd008 	sub	sp, sp, #8
    17c4:	e1a03000 	mov	r3, r0
    17c8:	e54b3005 	strb	r3, [fp, #-5]
	// clear CDFULL/CCEMTY
	USBDevIntClr = CDFULL | CCEMTY;
    17cc:	e59f302c 	ldr	r3, [pc, #44]	; 1800 <USBHwCmd+0x48>
    17d0:	e3a02030 	mov	r2, #48	; 0x30
    17d4:	e5832000 	str	r2, [r3]
	// write command code
	USBCmdCode = 0x00000500 | (bCmd << 16);
    17d8:	e59f3024 	ldr	r3, [pc, #36]	; 1804 <USBHwCmd+0x4c>
    17dc:	e55b2005 	ldrb	r2, [fp, #-5]
    17e0:	e1a02802 	lsl	r2, r2, #16
    17e4:	e3822c05 	orr	r2, r2, #1280	; 0x500
    17e8:	e5832000 	str	r2, [r3]
	Wait4DevInt(CCEMTY);
    17ec:	e3a00010 	mov	r0, #16
    17f0:	ebffffdc 	bl	1768 <Wait4DevInt>
}
    17f4:	e24bd004 	sub	sp, fp, #4
    17f8:	e8bd4800 	pop	{fp, lr}
    17fc:	e12fff1e 	bx	lr
    1800:	e0090008 	.word	0xe0090008
    1804:	e0090010 	.word	0xe0090010

00001808 <USBHwCmdWrite>:

	@param [in]	bCmd		Command to send
	@param [in]	bData		Data to send
 */
static void USBHwCmdWrite(U8 bCmd, U16 bData)
{
    1808:	e92d4800 	push	{fp, lr}
    180c:	e28db004 	add	fp, sp, #4
    1810:	e24dd008 	sub	sp, sp, #8
    1814:	e1a02000 	mov	r2, r0
    1818:	e1a03001 	mov	r3, r1
    181c:	e54b2005 	strb	r2, [fp, #-5]
    1820:	e14b30b8 	strh	r3, [fp, #-8]
	// write command code
	USBHwCmd(bCmd);
    1824:	e55b3005 	ldrb	r3, [fp, #-5]
    1828:	e1a00003 	mov	r0, r3
    182c:	ebffffe1 	bl	17b8 <USBHwCmd>

	// write command data
	USBCmdCode = 0x00000100 | (bData << 16);
    1830:	e59f3020 	ldr	r3, [pc, #32]	; 1858 <USBHwCmdWrite+0x50>
    1834:	e15b20b8 	ldrh	r2, [fp, #-8]
    1838:	e1a02802 	lsl	r2, r2, #16
    183c:	e3822c01 	orr	r2, r2, #256	; 0x100
    1840:	e5832000 	str	r2, [r3]
	Wait4DevInt(CCEMTY);
    1844:	e3a00010 	mov	r0, #16
    1848:	ebffffc6 	bl	1768 <Wait4DevInt>
}
    184c:	e24bd004 	sub	sp, fp, #4
    1850:	e8bd4800 	pop	{fp, lr}
    1854:	e12fff1e 	bx	lr
    1858:	e0090010 	.word	0xe0090010

0000185c <USBHwCmdRead>:
	@param [in]	bCmd		Command to send

	@return the data
 */
static U8 USBHwCmdRead(U8 bCmd)
{
    185c:	e92d4800 	push	{fp, lr}
    1860:	e28db004 	add	fp, sp, #4
    1864:	e24dd008 	sub	sp, sp, #8
    1868:	e1a03000 	mov	r3, r0
    186c:	e54b3005 	strb	r3, [fp, #-5]
	// write command code
	USBHwCmd(bCmd);
    1870:	e55b3005 	ldrb	r3, [fp, #-5]
    1874:	e1a00003 	mov	r0, r3
    1878:	ebffffce 	bl	17b8 <USBHwCmd>

	// get data
	USBCmdCode = 0x00000200 | (bCmd << 16);
    187c:	e59f3030 	ldr	r3, [pc, #48]	; 18b4 <USBHwCmdRead+0x58>
    1880:	e55b2005 	ldrb	r2, [fp, #-5]
    1884:	e1a02802 	lsl	r2, r2, #16
    1888:	e3822c02 	orr	r2, r2, #512	; 0x200
    188c:	e5832000 	str	r2, [r3]
	Wait4DevInt(CDFULL);
    1890:	e3a00020 	mov	r0, #32
    1894:	ebffffb3 	bl	1768 <Wait4DevInt>
	return USBCmdData;
    1898:	e59f3018 	ldr	r3, [pc, #24]	; 18b8 <USBHwCmdRead+0x5c>
    189c:	e5933000 	ldr	r3, [r3]
    18a0:	e20330ff 	and	r3, r3, #255	; 0xff
}
    18a4:	e1a00003 	mov	r0, r3
    18a8:	e24bd004 	sub	sp, fp, #4
    18ac:	e8bd4800 	pop	{fp, lr}
    18b0:	e12fff1e 	bx	lr
    18b4:	e0090010 	.word	0xe0090010
    18b8:	e0090014 	.word	0xe0090014

000018bc <USBHwEPRealize>:

	@param [in]	idx			Endpoint index
	@param [in] wMaxPSize	Maximum packet size for this endpoint
 */
static void USBHwEPRealize(int idx, U16 wMaxPSize)
{
    18bc:	e92d4800 	push	{fp, lr}
    18c0:	e28db004 	add	fp, sp, #4
    18c4:	e24dd008 	sub	sp, sp, #8
    18c8:	e50b0008 	str	r0, [fp, #-8]
    18cc:	e1a03001 	mov	r3, r1
    18d0:	e14b30ba 	strh	r3, [fp, #-10]
	USBReEP |= (1 << idx);
    18d4:	e59f3044 	ldr	r3, [pc, #68]	; 1920 <USBHwEPRealize+0x64>
    18d8:	e59f2040 	ldr	r2, [pc, #64]	; 1920 <USBHwEPRealize+0x64>
    18dc:	e5921000 	ldr	r1, [r2]
    18e0:	e3a00001 	mov	r0, #1
    18e4:	e51b2008 	ldr	r2, [fp, #-8]
    18e8:	e1a02210 	lsl	r2, r0, r2
    18ec:	e1812002 	orr	r2, r1, r2
    18f0:	e5832000 	str	r2, [r3]
	USBEpInd = idx;
    18f4:	e59f3028 	ldr	r3, [pc, #40]	; 1924 <USBHwEPRealize+0x68>
    18f8:	e51b2008 	ldr	r2, [fp, #-8]
    18fc:	e5832000 	str	r2, [r3]
	USBMaxPSize = wMaxPSize;
    1900:	e59f3020 	ldr	r3, [pc, #32]	; 1928 <USBHwEPRealize+0x6c>
    1904:	e15b20ba 	ldrh	r2, [fp, #-10]
    1908:	e5832000 	str	r2, [r3]
	Wait4DevInt(EP_RLZED);
    190c:	e3a00c01 	mov	r0, #256	; 0x100
    1910:	ebffff94 	bl	1768 <Wait4DevInt>
}
    1914:	e24bd004 	sub	sp, fp, #4
    1918:	e8bd4800 	pop	{fp, lr}
    191c:	e12fff1e 	bx	lr
    1920:	e0090044 	.word	0xe0090044
    1924:	e0090048 	.word	0xe0090048
    1928:	e009004c 	.word	0xe009004c

0000192c <USBHwEPEnable>:

	@param [in]	idx		Endpoint index
	@param [in]	fEnable	TRUE to enable, FALSE to disable
 */
static void USBHwEPEnable(int idx, BOOL fEnable)
{
    192c:	e92d4800 	push	{fp, lr}
    1930:	e28db004 	add	fp, sp, #4
    1934:	e24dd008 	sub	sp, sp, #8
    1938:	e50b0008 	str	r0, [fp, #-8]
    193c:	e50b100c 	str	r1, [fp, #-12]
	USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fEnable ? 0 : EP_DA);
    1940:	e51b3008 	ldr	r3, [fp, #-8]
    1944:	e20330ff 	and	r3, r3, #255	; 0xff
    1948:	e3833040 	orr	r3, r3, #64	; 0x40
    194c:	e20330ff 	and	r3, r3, #255	; 0xff
    1950:	e20320ff 	and	r2, r3, #255	; 0xff
    1954:	e51b300c 	ldr	r3, [fp, #-12]
    1958:	e3530000 	cmp	r3, #0
    195c:	0a000001 	beq	1968 <USBHwEPEnable+0x3c>
    1960:	e3a03000 	mov	r3, #0
    1964:	ea000000 	b	196c <USBHwEPEnable+0x40>
    1968:	e3a03020 	mov	r3, #32
    196c:	e1a00002 	mov	r0, r2
    1970:	e1a01003 	mov	r1, r3
    1974:	ebffffa3 	bl	1808 <USBHwCmdWrite>
}
    1978:	e24bd004 	sub	sp, fp, #4
    197c:	e8bd4800 	pop	{fp, lr}
    1980:	e12fff1e 	bx	lr

00001984 <USBHwEPConfig>:

	@param [in]	bEP				Endpoint number
	@param [in]	wMaxPacketSize	Maximum packet size for this EP
 */
void USBHwEPConfig(U8 bEP, U16 wMaxPacketSize)
{
    1984:	e92d4800 	push	{fp, lr}
    1988:	e28db004 	add	fp, sp, #4
    198c:	e24dd010 	sub	sp, sp, #16
    1990:	e1a02000 	mov	r2, r0
    1994:	e1a03001 	mov	r3, r1
    1998:	e54b200d 	strb	r2, [fp, #-13]
    199c:	e14b31b0 	strh	r3, [fp, #-16]
	int idx;

	idx = EP2IDX(bEP);
    19a0:	e55b300d 	ldrb	r3, [fp, #-13]
    19a4:	e203300f 	and	r3, r3, #15
    19a8:	e1a02083 	lsl	r2, r3, #1
    19ac:	e55b300d 	ldrb	r3, [fp, #-13]
    19b0:	e1a033a3 	lsr	r3, r3, #7
    19b4:	e20330ff 	and	r3, r3, #255	; 0xff
    19b8:	e1823003 	orr	r3, r2, r3
    19bc:	e50b3008 	str	r3, [fp, #-8]

	// realise EP
	USBHwEPRealize(idx, wMaxPacketSize);
    19c0:	e15b31b0 	ldrh	r3, [fp, #-16]
    19c4:	e51b0008 	ldr	r0, [fp, #-8]
    19c8:	e1a01003 	mov	r1, r3
    19cc:	ebffffba 	bl	18bc <USBHwEPRealize>

	// enable EP
	USBHwEPEnable(idx, TRUE);
    19d0:	e51b0008 	ldr	r0, [fp, #-8]
    19d4:	e3a01001 	mov	r1, #1
    19d8:	ebffffd3 	bl	192c <USBHwEPEnable>
}
    19dc:	e24bd004 	sub	sp, fp, #4
    19e0:	e8bd4800 	pop	{fp, lr}
    19e4:	e12fff1e 	bx	lr

000019e8 <USBHwRegisterEPIntHandler>:

	@param [in]	bEP				Endpoint number
	@param [in]	pfnHandler		Callback function
 */
void USBHwRegisterEPIntHandler(U8 bEP, TFnEPIntHandler *pfnHandler)
{
    19e8:	e92d4800 	push	{fp, lr}
    19ec:	e28db004 	add	fp, sp, #4
    19f0:	e24dd018 	sub	sp, sp, #24
    19f4:	e1a03000 	mov	r3, r0
    19f8:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    19fc:	e54b300d 	strb	r3, [fp, #-13]
	int idx;

	idx = EP2IDX(bEP);
    1a00:	e55b300d 	ldrb	r3, [fp, #-13]
    1a04:	e203300f 	and	r3, r3, #15
    1a08:	e1a02083 	lsl	r2, r3, #1
    1a0c:	e55b300d 	ldrb	r3, [fp, #-13]
    1a10:	e1a033a3 	lsr	r3, r3, #7
    1a14:	e20330ff 	and	r3, r3, #255	; 0xff
    1a18:	e1823003 	orr	r3, r2, r3
    1a1c:	e50b3008 	str	r3, [fp, #-8]

	ASSERT(idx<32);
    1a20:	e51b3008 	ldr	r3, [fp, #-8]
    1a24:	e353001f 	cmp	r3, #31
    1a28:	da000007 	ble	1a4c <USBHwRegisterEPIntHandler+0x64>
    1a2c:	e3a030c5 	mov	r3, #197	; 0xc5
    1a30:	e58d3000 	str	r3, [sp]
    1a34:	e59f0080 	ldr	r0, [pc, #128]	; 1abc <USBHwRegisterEPIntHandler+0xd4>
    1a38:	e59f1080 	ldr	r1, [pc, #128]	; 1ac0 <USBHwRegisterEPIntHandler+0xd8>
    1a3c:	e59f2080 	ldr	r2, [pc, #128]	; 1ac4 <USBHwRegisterEPIntHandler+0xdc>
    1a40:	e59f3080 	ldr	r3, [pc, #128]	; 1ac8 <USBHwRegisterEPIntHandler+0xe0>
    1a44:	ebfffb7f 	bl	848 <iprintf>
    1a48:	eafffffe 	b	1a48 <USBHwRegisterEPIntHandler+0x60>

	/* add handler to list of EP handlers */
	_apfnEPIntHandlers[idx / 2] = pfnHandler;
    1a4c:	e51b3008 	ldr	r3, [fp, #-8]
    1a50:	e1a02fa3 	lsr	r2, r3, #31
    1a54:	e0823003 	add	r3, r2, r3
    1a58:	e1a030c3 	asr	r3, r3, #1
    1a5c:	e1a02003 	mov	r2, r3
    1a60:	e59f3064 	ldr	r3, [pc, #100]	; 1acc <USBHwRegisterEPIntHandler+0xe4>
    1a64:	e51b1014 	ldr	r1, [fp, #-20]	; 0xffffffec
    1a68:	e7831102 	str	r1, [r3, r2, lsl #2]

	/* enable EP interrupt */
	USBEpIntEn |= (1 << idx);
    1a6c:	e59f305c 	ldr	r3, [pc, #92]	; 1ad0 <USBHwRegisterEPIntHandler+0xe8>
    1a70:	e59f2058 	ldr	r2, [pc, #88]	; 1ad0 <USBHwRegisterEPIntHandler+0xe8>
    1a74:	e5921000 	ldr	r1, [r2]
    1a78:	e3a00001 	mov	r0, #1
    1a7c:	e51b2008 	ldr	r2, [fp, #-8]
    1a80:	e1a02210 	lsl	r2, r0, r2
    1a84:	e1812002 	orr	r2, r1, r2
    1a88:	e5832000 	str	r2, [r3]
	USBDevIntEn |= EP_SLOW;
    1a8c:	e59f3040 	ldr	r3, [pc, #64]	; 1ad4 <USBHwRegisterEPIntHandler+0xec>
    1a90:	e59f203c 	ldr	r2, [pc, #60]	; 1ad4 <USBHwRegisterEPIntHandler+0xec>
    1a94:	e5922000 	ldr	r2, [r2]
    1a98:	e3822004 	orr	r2, r2, #4
    1a9c:	e5832000 	str	r2, [r3]

//	DBG("Registered handler for EP 0x%x\n", bEP);
	TRACE_DEBUG("Registered handler for EP 0x%x\n", bEP);
    1aa0:	e55b300d 	ldrb	r3, [fp, #-13]
    1aa4:	e59f002c 	ldr	r0, [pc, #44]	; 1ad8 <USBHwRegisterEPIntHandler+0xf0>
    1aa8:	e1a01003 	mov	r1, r3
    1aac:	ebfffb65 	bl	848 <iprintf>
}
    1ab0:	e24bd004 	sub	sp, fp, #4
    1ab4:	e8bd4800 	pop	{fp, lr}
    1ab8:	e12fff1e 	bx	lr
    1abc:	00003164 	.word	0x00003164
    1ac0:	0000318c 	.word	0x0000318c
    1ac4:	00003194 	.word	0x00003194
    1ac8:	0000321c 	.word	0x0000321c
    1acc:	40000284 	.word	0x40000284
    1ad0:	e0090034 	.word	0xe0090034
    1ad4:	e0090004 	.word	0xe0090004
    1ad8:	000031a4 	.word	0x000031a4

00001adc <USBHwRegisterDevIntHandler>:
	Registers an device status callback

	@param [in]	pfnHandler	Callback function
 */
void USBHwRegisterDevIntHandler(TFnDevIntHandler *pfnHandler)
{
    1adc:	e92d4800 	push	{fp, lr}
    1ae0:	e28db004 	add	fp, sp, #4
    1ae4:	e24dd008 	sub	sp, sp, #8
    1ae8:	e50b0008 	str	r0, [fp, #-8]
	_pfnDevIntHandler = pfnHandler;
    1aec:	e59f302c 	ldr	r3, [pc, #44]	; 1b20 <USBHwRegisterDevIntHandler+0x44>
    1af0:	e51b2008 	ldr	r2, [fp, #-8]
    1af4:	e5832000 	str	r2, [r3]

	// enable device interrupt
	USBDevIntEn |= DEV_STAT;
    1af8:	e59f3024 	ldr	r3, [pc, #36]	; 1b24 <USBHwRegisterDevIntHandler+0x48>
    1afc:	e59f2020 	ldr	r2, [pc, #32]	; 1b24 <USBHwRegisterDevIntHandler+0x48>
    1b00:	e5922000 	ldr	r2, [r2]
    1b04:	e3822008 	orr	r2, r2, #8
    1b08:	e5832000 	str	r2, [r3]

//	DBG("Registered handler for device status\n");
	TRACE_DEBUG("Registered handler for device status\n");
    1b0c:	e59f0014 	ldr	r0, [pc, #20]	; 1b28 <USBHwRegisterDevIntHandler+0x4c>
    1b10:	ebfffb4c 	bl	848 <iprintf>
}
    1b14:	e24bd004 	sub	sp, fp, #4
    1b18:	e8bd4800 	pop	{fp, lr}
    1b1c:	e12fff1e 	bx	lr
    1b20:	40000280 	.word	0x40000280
    1b24:	e0090004 	.word	0xe0090004
    1b28:	000031cc 	.word	0x000031cc

00001b2c <USBHwRegisterFrameHandler>:
	Registers the frame callback

	@param [in]	pfnHandler	Callback function
 */
void USBHwRegisterFrameHandler(TFnFrameHandler *pfnHandler)
{
    1b2c:	e92d4800 	push	{fp, lr}
    1b30:	e28db004 	add	fp, sp, #4
    1b34:	e24dd008 	sub	sp, sp, #8
    1b38:	e50b0008 	str	r0, [fp, #-8]
	_pfnFrameHandler = pfnHandler;
    1b3c:	e59f302c 	ldr	r3, [pc, #44]	; 1b70 <USBHwRegisterFrameHandler+0x44>
    1b40:	e51b2008 	ldr	r2, [fp, #-8]
    1b44:	e5832000 	str	r2, [r3]

	// enable device interrupt
	USBDevIntEn |= FRAME;
    1b48:	e59f3024 	ldr	r3, [pc, #36]	; 1b74 <USBHwRegisterFrameHandler+0x48>
    1b4c:	e59f2020 	ldr	r2, [pc, #32]	; 1b74 <USBHwRegisterFrameHandler+0x48>
    1b50:	e5922000 	ldr	r2, [r2]
    1b54:	e3822001 	orr	r2, r2, #1
    1b58:	e5832000 	str	r2, [r3]

//	DBG("Registered handler for frame\n");
	TRACE_DEBUG("Registered handler for frame\n");
    1b5c:	e59f0014 	ldr	r0, [pc, #20]	; 1b78 <USBHwRegisterFrameHandler+0x4c>
    1b60:	ebfffb38 	bl	848 <iprintf>
}
    1b64:	e24bd004 	sub	sp, fp, #4
    1b68:	e8bd4800 	pop	{fp, lr}
    1b6c:	e12fff1e 	bx	lr
    1b70:	400002c4 	.word	0x400002c4
    1b74:	e0090004 	.word	0xe0090004
    1b78:	000031f8 	.word	0x000031f8

00001b7c <USBHwSetAddress>:
	Sets the USB address.

	@param [in]	bAddr		Device address to set
 */
void USBHwSetAddress(U8 bAddr)
{
    1b7c:	e92d4800 	push	{fp, lr}
    1b80:	e28db004 	add	fp, sp, #4
    1b84:	e24dd008 	sub	sp, sp, #8
    1b88:	e1a03000 	mov	r3, r0
    1b8c:	e54b3005 	strb	r3, [fp, #-5]
	USBHwCmdWrite(CMD_DEV_SET_ADDRESS, DEV_EN | bAddr);
    1b90:	e55b3005 	ldrb	r3, [fp, #-5]
    1b94:	e1e03c83 	mvn	r3, r3, lsl #25
    1b98:	e1e03ca3 	mvn	r3, r3, lsr #25
    1b9c:	e20330ff 	and	r3, r3, #255	; 0xff
    1ba0:	e3a000d0 	mov	r0, #208	; 0xd0
    1ba4:	e1a01003 	mov	r1, r3
    1ba8:	ebffff16 	bl	1808 <USBHwCmdWrite>
}
    1bac:	e24bd004 	sub	sp, fp, #4
    1bb0:	e8bd4800 	pop	{fp, lr}
    1bb4:	e12fff1e 	bx	lr

00001bb8 <USBHwConnect>:
	Connects or disconnects from the USB bus

	@param [in]	fConnect	If TRUE, connect, otherwise disconnect
 */
void USBHwConnect(BOOL fConnect)
{
    1bb8:	e92d4800 	push	{fp, lr}
    1bbc:	e28db004 	add	fp, sp, #4
    1bc0:	e24dd008 	sub	sp, sp, #8
    1bc4:	e50b0008 	str	r0, [fp, #-8]
	USBHwCmdWrite(CMD_DEV_STATUS, fConnect ? CON : 0);
    1bc8:	e51b3008 	ldr	r3, [fp, #-8]
    1bcc:	e3530000 	cmp	r3, #0
    1bd0:	03a03000 	moveq	r3, #0
    1bd4:	13a03001 	movne	r3, #1
    1bd8:	e1a03803 	lsl	r3, r3, #16
    1bdc:	e1a03823 	lsr	r3, r3, #16
    1be0:	e3a000fe 	mov	r0, #254	; 0xfe
    1be4:	e1a01003 	mov	r1, r3
    1be8:	ebffff06 	bl	1808 <USBHwCmdWrite>
}
    1bec:	e24bd004 	sub	sp, fp, #4
    1bf0:	e8bd4800 	pop	{fp, lr}
    1bf4:	e12fff1e 	bx	lr

00001bf8 <USBHwNakIntEnable>:
	from NAK interrupt by checking the bits in their bEPStatus argument.

	@param [in]	bIntBits	Bitmap indicating which NAK interrupts to enable
 */
void USBHwNakIntEnable(U8 bIntBits)
{
    1bf8:	e92d4800 	push	{fp, lr}
    1bfc:	e28db004 	add	fp, sp, #4
    1c00:	e24dd008 	sub	sp, sp, #8
    1c04:	e1a03000 	mov	r3, r0
    1c08:	e54b3005 	strb	r3, [fp, #-5]
	USBHwCmdWrite(CMD_DEV_SET_MODE, bIntBits);
    1c0c:	e55b3005 	ldrb	r3, [fp, #-5]
    1c10:	e1a03803 	lsl	r3, r3, #16
    1c14:	e1a03823 	lsr	r3, r3, #16
    1c18:	e3a000f3 	mov	r0, #243	; 0xf3
    1c1c:	e1a01003 	mov	r1, r3
    1c20:	ebfffef8 	bl	1808 <USBHwCmdWrite>
}
    1c24:	e24bd004 	sub	sp, fp, #4
    1c28:	e8bd4800 	pop	{fp, lr}
    1c2c:	e12fff1e 	bx	lr

00001c30 <USBHwEPGetStatus>:

	@param [in]	bEP		Endpoint number
	@return Endpoint status byte (containing EP_STATUS_xxx bits)
 */
U8	USBHwEPGetStatus(U8 bEP)
{
    1c30:	e92d4800 	push	{fp, lr}
    1c34:	e28db004 	add	fp, sp, #4
    1c38:	e24dd010 	sub	sp, sp, #16
    1c3c:	e1a03000 	mov	r3, r0
    1c40:	e54b300d 	strb	r3, [fp, #-13]
	int idx = EP2IDX(bEP);
    1c44:	e55b300d 	ldrb	r3, [fp, #-13]
    1c48:	e203300f 	and	r3, r3, #15
    1c4c:	e1a02083 	lsl	r2, r3, #1
    1c50:	e55b300d 	ldrb	r3, [fp, #-13]
    1c54:	e1a033a3 	lsr	r3, r3, #7
    1c58:	e20330ff 	and	r3, r3, #255	; 0xff
    1c5c:	e1823003 	orr	r3, r2, r3
    1c60:	e50b3008 	str	r3, [fp, #-8]

	return USBHwCmdRead(CMD_EP_SELECT | idx);
    1c64:	e51b3008 	ldr	r3, [fp, #-8]
    1c68:	e20330ff 	and	r3, r3, #255	; 0xff
    1c6c:	e1a00003 	mov	r0, r3
    1c70:	ebfffef9 	bl	185c <USBHwCmdRead>
    1c74:	e1a03000 	mov	r3, r0
}
    1c78:	e1a00003 	mov	r0, r3
    1c7c:	e24bd004 	sub	sp, fp, #4
    1c80:	e8bd4800 	pop	{fp, lr}
    1c84:	e12fff1e 	bx	lr

00001c88 <USBHwEPStall>:

	@param [in]	bEP		Endpoint number
	@param [in]	fStall	TRUE to stall, FALSE to unstall
 */
void USBHwEPStall(U8 bEP, BOOL fStall)
{
    1c88:	e92d4800 	push	{fp, lr}
    1c8c:	e28db004 	add	fp, sp, #4
    1c90:	e24dd010 	sub	sp, sp, #16
    1c94:	e1a03000 	mov	r3, r0
    1c98:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    1c9c:	e54b300d 	strb	r3, [fp, #-13]
	int idx = EP2IDX(bEP);
    1ca0:	e55b300d 	ldrb	r3, [fp, #-13]
    1ca4:	e203300f 	and	r3, r3, #15
    1ca8:	e1a02083 	lsl	r2, r3, #1
    1cac:	e55b300d 	ldrb	r3, [fp, #-13]
    1cb0:	e1a033a3 	lsr	r3, r3, #7
    1cb4:	e20330ff 	and	r3, r3, #255	; 0xff
    1cb8:	e1823003 	orr	r3, r2, r3
    1cbc:	e50b3008 	str	r3, [fp, #-8]

	USBHwCmdWrite(CMD_EP_SET_STATUS | idx, fStall ? EP_ST : 0);
    1cc0:	e51b3008 	ldr	r3, [fp, #-8]
    1cc4:	e20330ff 	and	r3, r3, #255	; 0xff
    1cc8:	e3833040 	orr	r3, r3, #64	; 0x40
    1ccc:	e20330ff 	and	r3, r3, #255	; 0xff
    1cd0:	e20320ff 	and	r2, r3, #255	; 0xff
    1cd4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
    1cd8:	e3530000 	cmp	r3, #0
    1cdc:	03a03000 	moveq	r3, #0
    1ce0:	13a03001 	movne	r3, #1
    1ce4:	e1a03803 	lsl	r3, r3, #16
    1ce8:	e1a03823 	lsr	r3, r3, #16
    1cec:	e1a00002 	mov	r0, r2
    1cf0:	e1a01003 	mov	r1, r3
    1cf4:	ebfffec3 	bl	1808 <USBHwCmdWrite>
}
    1cf8:	e24bd004 	sub	sp, fp, #4
    1cfc:	e8bd4800 	pop	{fp, lr}
    1d00:	e12fff1e 	bx	lr

00001d04 <USBHwEPWrite>:
	@param [in]	iLen	Number of bytes to write

	@return TRUE if the data was successfully written or <0 in case of error.
*/
int USBHwEPWrite(U8 bEP, U8 *pbBuf, int iLen)
{
    1d04:	e92d4800 	push	{fp, lr}
    1d08:	e28db004 	add	fp, sp, #4
    1d0c:	e24dd018 	sub	sp, sp, #24
    1d10:	e1a03000 	mov	r3, r0
    1d14:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    1d18:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
    1d1c:	e54b300d 	strb	r3, [fp, #-13]
	int idx;

	idx = EP2IDX(bEP);
    1d20:	e55b300d 	ldrb	r3, [fp, #-13]
    1d24:	e203300f 	and	r3, r3, #15
    1d28:	e1a02083 	lsl	r2, r3, #1
    1d2c:	e55b300d 	ldrb	r3, [fp, #-13]
    1d30:	e1a033a3 	lsr	r3, r3, #7
    1d34:	e20330ff 	and	r3, r3, #255	; 0xff
    1d38:	e1823003 	orr	r3, r2, r3
    1d3c:	e50b3008 	str	r3, [fp, #-8]

	// set write enable for specific endpoint
	USBCtrl = WR_EN | ((bEP & 0xF) << 2);
    1d40:	e59f30b8 	ldr	r3, [pc, #184]	; 1e00 <USBHwEPWrite+0xfc>
    1d44:	e55b200d 	ldrb	r2, [fp, #-13]
    1d48:	e202200f 	and	r2, r2, #15
    1d4c:	e1a02102 	lsl	r2, r2, #2
    1d50:	e3822002 	orr	r2, r2, #2
    1d54:	e5832000 	str	r2, [r3]

	// set packet length
	USBTxPLen = iLen;
    1d58:	e59f30a4 	ldr	r3, [pc, #164]	; 1e04 <USBHwEPWrite+0x100>
    1d5c:	e51b2018 	ldr	r2, [fp, #-24]	; 0xffffffe8
    1d60:	e5832000 	str	r2, [r3]

	// write data
	while (USBCtrl & WR_EN) {
    1d64:	ea000015 	b	1dc0 <USBHwEPWrite+0xbc>
		USBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];
    1d68:	e59f3098 	ldr	r3, [pc, #152]	; 1e08 <USBHwEPWrite+0x104>
    1d6c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
    1d70:	e2822003 	add	r2, r2, #3
    1d74:	e5d22000 	ldrb	r2, [r2]
    1d78:	e1a01c02 	lsl	r1, r2, #24
    1d7c:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
    1d80:	e2822002 	add	r2, r2, #2
    1d84:	e5d22000 	ldrb	r2, [r2]
    1d88:	e1a02802 	lsl	r2, r2, #16
    1d8c:	e1811002 	orr	r1, r1, r2
    1d90:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
    1d94:	e2822001 	add	r2, r2, #1
    1d98:	e5d22000 	ldrb	r2, [r2]
    1d9c:	e1a02402 	lsl	r2, r2, #8
    1da0:	e1811002 	orr	r1, r1, r2
    1da4:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
    1da8:	e5d22000 	ldrb	r2, [r2]
    1dac:	e1812002 	orr	r2, r1, r2
    1db0:	e5832000 	str	r2, [r3]
		pbBuf += 4;
    1db4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
    1db8:	e2833004 	add	r3, r3, #4
    1dbc:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	// set packet length
	USBTxPLen = iLen;

	// write data
	while (USBCtrl & WR_EN) {
    1dc0:	e59f3038 	ldr	r3, [pc, #56]	; 1e00 <USBHwEPWrite+0xfc>
    1dc4:	e5933000 	ldr	r3, [r3]
    1dc8:	e2033002 	and	r3, r3, #2
    1dcc:	e3530000 	cmp	r3, #0
    1dd0:	1affffe4 	bne	1d68 <USBHwEPWrite+0x64>
		USBTxData = (pbBuf[3] << 24) | (pbBuf[2] << 16) | (pbBuf[1] << 8) | pbBuf[0];
		pbBuf += 4;
	}

	// select endpoint and validate buffer
	USBHwCmd(CMD_EP_SELECT | idx);
    1dd4:	e51b3008 	ldr	r3, [fp, #-8]
    1dd8:	e20330ff 	and	r3, r3, #255	; 0xff
    1ddc:	e1a00003 	mov	r0, r3
    1de0:	ebfffe74 	bl	17b8 <USBHwCmd>
	USBHwCmd(CMD_EP_VALIDATE_BUFFER);
    1de4:	e3a000fa 	mov	r0, #250	; 0xfa
    1de8:	ebfffe72 	bl	17b8 <USBHwCmd>

	return iLen;
    1dec:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
}
    1df0:	e1a00003 	mov	r0, r3
    1df4:	e24bd004 	sub	sp, fp, #4
    1df8:	e8bd4800 	pop	{fp, lr}
    1dfc:	e12fff1e 	bx	lr
    1e00:	e0090028 	.word	0xe0090028
    1e04:	e0090024 	.word	0xe0090024
    1e08:	e009001c 	.word	0xe009001c

00001e0c <USBHwEPRead>:

	@return the number of bytes available in the EP (possibly more than iMaxLen),
	or <0 in case of error.
 */
int USBHwEPRead(U8 bEP, U8 *pbBuf, int iMaxLen)
{
    1e0c:	e92d4800 	push	{fp, lr}
    1e10:	e28db004 	add	fp, sp, #4
    1e14:	e24dd020 	sub	sp, sp, #32
    1e18:	e1a03000 	mov	r3, r0
    1e1c:	e50b101c 	str	r1, [fp, #-28]	; 0xffffffe4
    1e20:	e50b2020 	str	r2, [fp, #-32]	; 0xffffffe0
    1e24:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
	int i, idx;
	U32	dwData, dwLen;

	idx = EP2IDX(bEP);
    1e28:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
    1e2c:	e203300f 	and	r3, r3, #15
    1e30:	e1a02083 	lsl	r2, r3, #1
    1e34:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
    1e38:	e1a033a3 	lsr	r3, r3, #7
    1e3c:	e20330ff 	and	r3, r3, #255	; 0xff
    1e40:	e1823003 	orr	r3, r2, r3
    1e44:	e50b3010 	str	r3, [fp, #-16]

	// set read enable bit for specific endpoint
	USBCtrl = RD_EN | ((bEP & 0xF) << 2);
    1e48:	e59f3118 	ldr	r3, [pc, #280]	; 1f68 <USBHwEPRead+0x15c>
    1e4c:	e55b2015 	ldrb	r2, [fp, #-21]	; 0xffffffeb
    1e50:	e202200f 	and	r2, r2, #15
    1e54:	e1a02102 	lsl	r2, r2, #2
    1e58:	e3822001 	orr	r2, r2, #1
    1e5c:	e5832000 	str	r2, [r3]

	// wait for PKT_RDY
	do {
		dwLen = USBRxPLen;
    1e60:	e59f3104 	ldr	r3, [pc, #260]	; 1f6c <USBHwEPRead+0x160>
    1e64:	e5933000 	ldr	r3, [r3]
    1e68:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
	} while ((dwLen & PKT_RDY) == 0);
    1e6c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
    1e70:	e2033b02 	and	r3, r3, #2048	; 0x800
    1e74:	e3530000 	cmp	r3, #0
    1e78:	0afffff8 	beq	1e60 <USBHwEPRead+0x54>

	// packet valid?
	if ((dwLen & DV) == 0) {
    1e7c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
    1e80:	e2033b01 	and	r3, r3, #1024	; 0x400
    1e84:	e3530000 	cmp	r3, #0
    1e88:	1a000001 	bne	1e94 <USBHwEPRead+0x88>
		return -1;
    1e8c:	e3e03000 	mvn	r3, #0
    1e90:	ea000030 	b	1f58 <USBHwEPRead+0x14c>
	}

	// get length
	dwLen &= PKT_LNGTH_MASK;
    1e94:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
    1e98:	e1a03b03 	lsl	r3, r3, #22
    1e9c:	e1a03b23 	lsr	r3, r3, #22
    1ea0:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec

	// get data
	dwData = 0;
    1ea4:	e3a03000 	mov	r3, #0
    1ea8:	e50b300c 	str	r3, [fp, #-12]
	for (i = 0; i < dwLen; i++) {
    1eac:	e3a03000 	mov	r3, #0
    1eb0:	e50b3008 	str	r3, [fp, #-8]
    1eb4:	ea000019 	b	1f20 <USBHwEPRead+0x114>
		if ((i % 4) == 0) {
    1eb8:	e51b3008 	ldr	r3, [fp, #-8]
    1ebc:	e2033003 	and	r3, r3, #3
    1ec0:	e3530000 	cmp	r3, #0
    1ec4:	1a000002 	bne	1ed4 <USBHwEPRead+0xc8>
			dwData = USBRxData;
    1ec8:	e59f30a0 	ldr	r3, [pc, #160]	; 1f70 <USBHwEPRead+0x164>
    1ecc:	e5933000 	ldr	r3, [r3]
    1ed0:	e50b300c 	str	r3, [fp, #-12]
		}
		if ((pbBuf != NULL) && (i < iMaxLen)) {
    1ed4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
    1ed8:	e3530000 	cmp	r3, #0
    1edc:	0a000009 	beq	1f08 <USBHwEPRead+0xfc>
    1ee0:	e51b2008 	ldr	r2, [fp, #-8]
    1ee4:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
    1ee8:	e1520003 	cmp	r2, r3
    1eec:	aa000005 	bge	1f08 <USBHwEPRead+0xfc>
			pbBuf[i] = dwData & 0xFF;
    1ef0:	e51b3008 	ldr	r3, [fp, #-8]
    1ef4:	e51b201c 	ldr	r2, [fp, #-28]	; 0xffffffe4
    1ef8:	e0823003 	add	r3, r2, r3
    1efc:	e51b200c 	ldr	r2, [fp, #-12]
    1f00:	e20220ff 	and	r2, r2, #255	; 0xff
    1f04:	e5c32000 	strb	r2, [r3]
		}
		dwData >>= 8;
    1f08:	e51b300c 	ldr	r3, [fp, #-12]
    1f0c:	e1a03423 	lsr	r3, r3, #8
    1f10:	e50b300c 	str	r3, [fp, #-12]
	// get length
	dwLen &= PKT_LNGTH_MASK;

	// get data
	dwData = 0;
	for (i = 0; i < dwLen; i++) {
    1f14:	e51b3008 	ldr	r3, [fp, #-8]
    1f18:	e2833001 	add	r3, r3, #1
    1f1c:	e50b3008 	str	r3, [fp, #-8]
    1f20:	e51b2008 	ldr	r2, [fp, #-8]
    1f24:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
    1f28:	e1520003 	cmp	r2, r3
    1f2c:	3affffe1 	bcc	1eb8 <USBHwEPRead+0xac>
		}
		dwData >>= 8;
	}

	// make sure RD_EN is clear
	USBCtrl = 0;
    1f30:	e59f3030 	ldr	r3, [pc, #48]	; 1f68 <USBHwEPRead+0x15c>
    1f34:	e3a02000 	mov	r2, #0
    1f38:	e5832000 	str	r2, [r3]

	// select endpoint and clear buffer
	USBHwCmd(CMD_EP_SELECT | idx);
    1f3c:	e51b3010 	ldr	r3, [fp, #-16]
    1f40:	e20330ff 	and	r3, r3, #255	; 0xff
    1f44:	e1a00003 	mov	r0, r3
    1f48:	ebfffe1a 	bl	17b8 <USBHwCmd>
	USBHwCmd(CMD_EP_CLEAR_BUFFER);
    1f4c:	e3a000f2 	mov	r0, #242	; 0xf2
    1f50:	ebfffe18 	bl	17b8 <USBHwCmd>

	return dwLen;
    1f54:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
}
    1f58:	e1a00003 	mov	r0, r3
    1f5c:	e24bd004 	sub	sp, fp, #4
    1f60:	e8bd4800 	pop	{fp, lr}
    1f64:	e12fff1e 	bx	lr
    1f68:	e0090028 	.word	0xe0090028
    1f6c:	e0090020 	.word	0xe0090020
    1f70:	e0090018 	.word	0xe0090018

00001f74 <USBHwConfigDevice>:
	'configured' bit is set in the device status register.

	@param [in]	fConfigured	If TRUE, configure device, else unconfigure
 */
void USBHwConfigDevice(BOOL fConfigured)
{
    1f74:	e92d4800 	push	{fp, lr}
    1f78:	e28db004 	add	fp, sp, #4
    1f7c:	e24dd008 	sub	sp, sp, #8
    1f80:	e50b0008 	str	r0, [fp, #-8]
	// set configured bit
	USBHwCmdWrite(CMD_DEV_CONFIG, fConfigured ? CONF_DEVICE : 0);
    1f84:	e51b3008 	ldr	r3, [fp, #-8]
    1f88:	e3530000 	cmp	r3, #0
    1f8c:	03a03000 	moveq	r3, #0
    1f90:	13a03001 	movne	r3, #1
    1f94:	e1a03803 	lsl	r3, r3, #16
    1f98:	e1a03823 	lsr	r3, r3, #16
    1f9c:	e3a000d8 	mov	r0, #216	; 0xd8
    1fa0:	e1a01003 	mov	r1, r3
    1fa4:	ebfffe17 	bl	1808 <USBHwCmdWrite>
}
    1fa8:	e24bd004 	sub	sp, fp, #4
    1fac:	e8bd4800 	pop	{fp, lr}
    1fb0:	e12fff1e 	bx	lr

00001fb4 <USBHwISR>:
	@todo Get all 11 bits of frame number instead of just 8

	Endpoint interrupts are mapped to the slow interrupt
 */
void USBHwISR(void)
{
    1fb4:	e92d4800 	push	{fp, lr}
    1fb8:	e28db004 	add	fp, sp, #4
    1fbc:	e24dd018 	sub	sp, sp, #24

  // LED9 monitors total time in interrupt routine
  DEBUG_LED_ON(9);

  // handle device interrupts
  dwStatus = USBDevIntSt;
    1fc0:	e59f31ec 	ldr	r3, [pc, #492]	; 21b4 <USBHwISR+0x200>
    1fc4:	e5933000 	ldr	r3, [r3]
    1fc8:	e50b300c 	str	r3, [fp, #-12]

  // frame interrupt
  if (dwStatus & FRAME)
    1fcc:	e51b300c 	ldr	r3, [fp, #-12]
    1fd0:	e2033001 	and	r3, r3, #1
    1fd4:	e20330ff 	and	r3, r3, #255	; 0xff
    1fd8:	e3530000 	cmp	r3, #0
    1fdc:	0a000010 	beq	2024 <USBHwISR+0x70>
  {
    // clear int
    USBDevIntClr = FRAME;
    1fe0:	e59f31d0 	ldr	r3, [pc, #464]	; 21b8 <USBHwISR+0x204>
    1fe4:	e3a02001 	mov	r2, #1
    1fe8:	e5832000 	str	r2, [r3]
    // call handler
    if (_pfnFrameHandler != NULL)
    1fec:	e59f31c8 	ldr	r3, [pc, #456]	; 21bc <USBHwISR+0x208>
    1ff0:	e5933000 	ldr	r3, [r3]
    1ff4:	e3530000 	cmp	r3, #0
    1ff8:	0a000009 	beq	2024 <USBHwISR+0x70>
    {
      wFrame = USBHwCmdRead(CMD_DEV_READ_CUR_FRAME_NR);
    1ffc:	e3a000f5 	mov	r0, #245	; 0xf5
    2000:	ebfffe15 	bl	185c <USBHwCmdRead>
    2004:	e1a03000 	mov	r3, r0
    2008:	e14b30be 	strh	r3, [fp, #-14]
      _pfnFrameHandler(wFrame);
    200c:	e59f31a8 	ldr	r3, [pc, #424]	; 21bc <USBHwISR+0x208>
    2010:	e5933000 	ldr	r3, [r3]
    2014:	e15b20be 	ldrh	r2, [fp, #-14]
    2018:	e1a00002 	mov	r0, r2
    201c:	e1a0e00f 	mov	lr, pc
    2020:	e12fff13 	bx	r3
    }
  }

  // device status interrupt
  if (dwStatus & DEV_STAT)
    2024:	e51b300c 	ldr	r3, [fp, #-12]
    2028:	e2033008 	and	r3, r3, #8
    202c:	e3530000 	cmp	r3, #0
    2030:	0a000017 	beq	2094 <USBHwISR+0xe0>
  {
    /*	Clear DEV_STAT interrupt before reading DEV_STAT register.
			This prevents corrupted device status reads, see
			LPC2148 User manual revision 2, 25 july 2006.
     */
    USBDevIntClr = DEV_STAT;
    2034:	e59f317c 	ldr	r3, [pc, #380]	; 21b8 <USBHwISR+0x204>
    2038:	e3a02008 	mov	r2, #8
    203c:	e5832000 	str	r2, [r3]
    bDevStat = USBHwCmdRead(CMD_DEV_STATUS);
    2040:	e3a000fe 	mov	r0, #254	; 0xfe
    2044:	ebfffe04 	bl	185c <USBHwCmdRead>
    2048:	e1a03000 	mov	r3, r0
    204c:	e54b300f 	strb	r3, [fp, #-15]
    if (bDevStat & (CON_CH | SUS_CH | RST))
    2050:	e55b300f 	ldrb	r3, [fp, #-15]
    2054:	e203301a 	and	r3, r3, #26
    2058:	e3530000 	cmp	r3, #0
    205c:	0a00000c 	beq	2094 <USBHwISR+0xe0>
    {
      // convert device status into something HW independent
      bStat = ((bDevStat & CON) ? DEV_STATUS_CONNECT : 0) |
    2060:	e55b300f 	ldrb	r3, [fp, #-15]
    2064:	e2033015 	and	r3, r3, #21
    2068:	e54b3010 	strb	r3, [fp, #-16]
          ((bDevStat & SUS) ? DEV_STATUS_SUSPEND : 0) |
          ((bDevStat & RST) ? DEV_STATUS_RESET : 0);
      // call handler
      if (_pfnDevIntHandler != NULL)
    206c:	e59f314c 	ldr	r3, [pc, #332]	; 21c0 <USBHwISR+0x20c>
    2070:	e5933000 	ldr	r3, [r3]
    2074:	e3530000 	cmp	r3, #0
    2078:	0a000005 	beq	2094 <USBHwISR+0xe0>
      {
        DEBUG_LED_ON(8);
        _pfnDevIntHandler(bStat);
    207c:	e59f313c 	ldr	r3, [pc, #316]	; 21c0 <USBHwISR+0x20c>
    2080:	e5933000 	ldr	r3, [r3]
    2084:	e55b2010 	ldrb	r2, [fp, #-16]
    2088:	e1a00002 	mov	r0, r2
    208c:	e1a0e00f 	mov	lr, pc
    2090:	e12fff13 	bx	r3
      }
    }
  }

  // endpoint interrupt
  if (dwStatus & EP_SLOW)
    2094:	e51b300c 	ldr	r3, [fp, #-12]
    2098:	e2033004 	and	r3, r3, #4
    209c:	e3530000 	cmp	r3, #0
    20a0:	0a000040 	beq	21a8 <USBHwISR+0x1f4>
  {
    // clear EP_SLOW
    USBDevIntClr = EP_SLOW;
    20a4:	e59f310c 	ldr	r3, [pc, #268]	; 21b8 <USBHwISR+0x204>
    20a8:	e3a02004 	mov	r2, #4
    20ac:	e5832000 	str	r2, [r3]
    // check all endpoints
    for (i = 0; i < 32; i++)
    20b0:	e3a03000 	mov	r3, #0
    20b4:	e50b3008 	str	r3, [fp, #-8]
    20b8:	ea000037 	b	219c <USBHwISR+0x1e8>
    {
      dwIntBit = (1 << i);
    20bc:	e3a02001 	mov	r2, #1
    20c0:	e51b3008 	ldr	r3, [fp, #-8]
    20c4:	e1a03312 	lsl	r3, r2, r3
    20c8:	e50b3014 	str	r3, [fp, #-20]	; 0xffffffec
      if (USBEpIntSt & dwIntBit)
    20cc:	e59f30f0 	ldr	r3, [pc, #240]	; 21c4 <USBHwISR+0x210>
    20d0:	e5932000 	ldr	r2, [r3]
    20d4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
    20d8:	e0023003 	and	r3, r2, r3
    20dc:	e3530000 	cmp	r3, #0
    20e0:	0a00002a 	beq	2190 <USBHwISR+0x1dc>
      {
        // clear int (and retrieve status)
        USBEpIntClr = dwIntBit;
    20e4:	e59f30dc 	ldr	r3, [pc, #220]	; 21c8 <USBHwISR+0x214>
    20e8:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
    20ec:	e5832000 	str	r2, [r3]
        Wait4DevInt(CDFULL);
    20f0:	e3a00020 	mov	r0, #32
    20f4:	ebfffd9b 	bl	1768 <Wait4DevInt>
        bEPStat = USBCmdData;
    20f8:	e59f30cc 	ldr	r3, [pc, #204]	; 21cc <USBHwISR+0x218>
    20fc:	e5933000 	ldr	r3, [r3]
    2100:	e54b3015 	strb	r3, [fp, #-21]	; 0xffffffeb
        // convert EP pipe stat into something HW independent
        bStat = ((bEPStat & EPSTAT_FE) ? EP_STATUS_DATA : 0) |
    2104:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
    2108:	e203301f 	and	r3, r3, #31
    210c:	e54b3010 	strb	r3, [fp, #-16]
            ((bEPStat & EPSTAT_ST) ? EP_STATUS_STALLED : 0) |
            ((bEPStat & EPSTAT_STP) ? EP_STATUS_SETUP : 0) |
            ((bEPStat & EPSTAT_EPN) ? EP_STATUS_NACKED : 0) |
            ((bEPStat & EPSTAT_PO) ? EP_STATUS_ERROR : 0);
        // call handler
        if (_apfnEPIntHandlers[i / 2] != NULL)
    2110:	e51b3008 	ldr	r3, [fp, #-8]
    2114:	e1a02fa3 	lsr	r2, r3, #31
    2118:	e0823003 	add	r3, r2, r3
    211c:	e1a030c3 	asr	r3, r3, #1
    2120:	e1a02003 	mov	r2, r3
    2124:	e59f30a4 	ldr	r3, [pc, #164]	; 21d0 <USBHwISR+0x21c>
    2128:	e7933102 	ldr	r3, [r3, r2, lsl #2]
    212c:	e3530000 	cmp	r3, #0
    2130:	0a000016 	beq	2190 <USBHwISR+0x1dc>
        {
          DEBUG_LED_ON(10);
          _apfnEPIntHandlers[i / 2](IDX2EP(i), bStat);
    2134:	e51b3008 	ldr	r3, [fp, #-8]
    2138:	e1a02fa3 	lsr	r2, r3, #31
    213c:	e0823003 	add	r3, r2, r3
    2140:	e1a030c3 	asr	r3, r3, #1
    2144:	e1a02003 	mov	r2, r3
    2148:	e59f3080 	ldr	r3, [pc, #128]	; 21d0 <USBHwISR+0x21c>
    214c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
    2150:	e51b2008 	ldr	r2, [fp, #-8]
    2154:	e1a02382 	lsl	r2, r2, #7
    2158:	e20210ff 	and	r1, r2, #255	; 0xff
    215c:	e51b2008 	ldr	r2, [fp, #-8]
    2160:	e1a020c2 	asr	r2, r2, #1
    2164:	e20220ff 	and	r2, r2, #255	; 0xff
    2168:	e202200f 	and	r2, r2, #15
    216c:	e20220ff 	and	r2, r2, #255	; 0xff
    2170:	e1812002 	orr	r2, r1, r2
    2174:	e20220ff 	and	r2, r2, #255	; 0xff
    2178:	e20210ff 	and	r1, r2, #255	; 0xff
    217c:	e55b2010 	ldrb	r2, [fp, #-16]
    2180:	e1a00001 	mov	r0, r1
    2184:	e1a01002 	mov	r1, r2
    2188:	e1a0e00f 	mov	lr, pc
    218c:	e12fff13 	bx	r3
  if (dwStatus & EP_SLOW)
  {
    // clear EP_SLOW
    USBDevIntClr = EP_SLOW;
    // check all endpoints
    for (i = 0; i < 32; i++)
    2190:	e51b3008 	ldr	r3, [fp, #-8]
    2194:	e2833001 	add	r3, r3, #1
    2198:	e50b3008 	str	r3, [fp, #-8]
    219c:	e51b3008 	ldr	r3, [fp, #-8]
    21a0:	e353001f 	cmp	r3, #31
    21a4:	daffffc4 	ble	20bc <USBHwISR+0x108>
      }
    }
  }

  DEBUG_LED_OFF(9);
}
    21a8:	e24bd004 	sub	sp, fp, #4
    21ac:	e8bd4800 	pop	{fp, lr}
    21b0:	e12fff1e 	bx	lr
    21b4:	e0090000 	.word	0xe0090000
    21b8:	e0090008 	.word	0xe0090008
    21bc:	400002c4 	.word	0x400002c4
    21c0:	40000280 	.word	0x40000280
    21c4:	e0090030 	.word	0xe0090030
    21c8:	e0090038 	.word	0xe0090038
    21cc:	e0090014 	.word	0xe0090014
    21d0:	40000284 	.word	0x40000284

000021d4 <USBHwInit>:
	acts as a pull-up and so prevents detection of USB disconnect.

	@return TRUE if the hardware was successfully initialised
 */
BOOL USBHwInit(void)
{
    21d4:	e92d4800 	push	{fp, lr}
    21d8:	e28db004 	add	fp, sp, #4
	// configure P0.23 for Vbus sense
	PINSEL1 = (PINSEL1 & ~(3 << 14)) | (1 << 14);	// P0.23
    21dc:	e59f310c 	ldr	r3, [pc, #268]	; 22f0 <USBHwInit+0x11c>
    21e0:	e59f2108 	ldr	r2, [pc, #264]	; 22f0 <USBHwInit+0x11c>
    21e4:	e5922000 	ldr	r2, [r2]
    21e8:	e3c22903 	bic	r2, r2, #49152	; 0xc000
    21ec:	e3822901 	orr	r2, r2, #16384	; 0x4000
    21f0:	e5832000 	str	r2, [r3]
	// configure P0.31 for CONNECT
	PINSEL1 = (PINSEL1 & ~(3 << 30)) | (2 << 30);	// P0.31
    21f4:	e59f30f4 	ldr	r3, [pc, #244]	; 22f0 <USBHwInit+0x11c>
    21f8:	e59f20f0 	ldr	r2, [pc, #240]	; 22f0 <USBHwInit+0x11c>
    21fc:	e5922000 	ldr	r2, [r2]
    2200:	e3c22103 	bic	r2, r2, #-1073741824	; 0xc0000000
    2204:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
    2208:	e5832000 	str	r2, [r3]

	// enable PUSB
	PCONP |= (1 << 31);
    220c:	e59f30e0 	ldr	r3, [pc, #224]	; 22f4 <USBHwInit+0x120>
    2210:	e59f20dc 	ldr	r2, [pc, #220]	; 22f4 <USBHwInit+0x120>
    2214:	e5922000 	ldr	r2, [r2]
    2218:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
    221c:	e5832000 	str	r2, [r3]

	// initialise PLL
	PLL1CON = 1;			// enable PLL
    2220:	e59f30d0 	ldr	r3, [pc, #208]	; 22f8 <USBHwInit+0x124>
    2224:	e3a02001 	mov	r2, #1
    2228:	e5832000 	str	r2, [r3]
	PLL1CFG = (1 << 5) | 3; // P = 2, M = 4
    222c:	e59f30c8 	ldr	r3, [pc, #200]	; 22fc <USBHwInit+0x128>
    2230:	e3a02023 	mov	r2, #35	; 0x23
    2234:	e5832000 	str	r2, [r3]
	PLL1FEED = 0xAA;
    2238:	e59f30c0 	ldr	r3, [pc, #192]	; 2300 <USBHwInit+0x12c>
    223c:	e3a020aa 	mov	r2, #170	; 0xaa
    2240:	e5832000 	str	r2, [r3]
	PLL1FEED = 0x55;
    2244:	e59f30b4 	ldr	r3, [pc, #180]	; 2300 <USBHwInit+0x12c>
    2248:	e3a02055 	mov	r2, #85	; 0x55
    224c:	e5832000 	str	r2, [r3]
	while ((PLL1STAT & (1 << 10)) == 0);
    2250:	e1a00000 	nop			; (mov r0, r0)
    2254:	e59f30a8 	ldr	r3, [pc, #168]	; 2304 <USBHwInit+0x130>
    2258:	e5933000 	ldr	r3, [r3]
    225c:	e2033b01 	and	r3, r3, #1024	; 0x400
    2260:	e3530000 	cmp	r3, #0
    2264:	0afffffa 	beq	2254 <USBHwInit+0x80>

	PLL1CON = 3;			// enable and connect
    2268:	e59f3088 	ldr	r3, [pc, #136]	; 22f8 <USBHwInit+0x124>
    226c:	e3a02003 	mov	r2, #3
    2270:	e5832000 	str	r2, [r3]
	PLL1FEED = 0xAA;
    2274:	e59f3084 	ldr	r3, [pc, #132]	; 2300 <USBHwInit+0x12c>
    2278:	e3a020aa 	mov	r2, #170	; 0xaa
    227c:	e5832000 	str	r2, [r3]
	PLL1FEED = 0x55;
    2280:	e59f3078 	ldr	r3, [pc, #120]	; 2300 <USBHwInit+0x12c>
    2284:	e3a02055 	mov	r2, #85	; 0x55
    2288:	e5832000 	str	r2, [r3]

	// disable/clear all interrupts for now
	USBDevIntEn = 0;
    228c:	e59f3074 	ldr	r3, [pc, #116]	; 2308 <USBHwInit+0x134>
    2290:	e3a02000 	mov	r2, #0
    2294:	e5832000 	str	r2, [r3]
	USBDevIntClr = 0xFFFFFFFF;
    2298:	e59f306c 	ldr	r3, [pc, #108]	; 230c <USBHwInit+0x138>
    229c:	e3e02000 	mvn	r2, #0
    22a0:	e5832000 	str	r2, [r3]
	USBDevIntPri = 0;
    22a4:	e59f3064 	ldr	r3, [pc, #100]	; 2310 <USBHwInit+0x13c>
    22a8:	e3a02000 	mov	r2, #0
    22ac:	e5832000 	str	r2, [r3]

	USBEpIntEn = 0;
    22b0:	e59f305c 	ldr	r3, [pc, #92]	; 2314 <USBHwInit+0x140>
    22b4:	e3a02000 	mov	r2, #0
    22b8:	e5832000 	str	r2, [r3]
	USBEpIntClr = 0xFFFFFFFF;
    22bc:	e59f3054 	ldr	r3, [pc, #84]	; 2318 <USBHwInit+0x144>
    22c0:	e3e02000 	mvn	r2, #0
    22c4:	e5832000 	str	r2, [r3]
	USBEpIntPri = 0;
    22c8:	e59f304c 	ldr	r3, [pc, #76]	; 231c <USBHwInit+0x148>
    22cc:	e3a02000 	mov	r2, #0
    22d0:	e5832000 	str	r2, [r3]

	// by default, only ACKs generate interrupts
	USBHwNakIntEnable(0);
    22d4:	e3a00000 	mov	r0, #0
    22d8:	ebfffe46 	bl	1bf8 <USBHwNakIntEnable>
	// init debug leds
	DEBUG_LED_INIT(8);
	DEBUG_LED_INIT(9);
	DEBUG_LED_INIT(10);

	return TRUE;
    22dc:	e3a03001 	mov	r3, #1
}
    22e0:	e1a00003 	mov	r0, r3
    22e4:	e24bd004 	sub	sp, fp, #4
    22e8:	e8bd4800 	pop	{fp, lr}
    22ec:	e12fff1e 	bx	lr
    22f0:	e002c004 	.word	0xe002c004
    22f4:	e01fc0c4 	.word	0xe01fc0c4
    22f8:	e01fc0a0 	.word	0xe01fc0a0
    22fc:	e01fc0a4 	.word	0xe01fc0a4
    2300:	e01fc0ac 	.word	0xe01fc0ac
    2304:	e01fc0a8 	.word	0xe01fc0a8
    2308:	e0090004 	.word	0xe0090004
    230c:	e0090008 	.word	0xe0090008
    2310:	e009002c 	.word	0xe009002c
    2314:	e0090034 	.word	0xe0090034
    2318:	e0090038 	.word	0xe0090038
    231c:	e0090040 	.word	0xe0090040

00002320 <HandleUsbReset>:
	USB reset handler

	@param [in] bDevStatus	Device status
 */
static void HandleUsbReset(U8 bDevStatus)
{
    2320:	e92d4800 	push	{fp, lr}
    2324:	e28db004 	add	fp, sp, #4
    2328:	e24dd008 	sub	sp, sp, #8
    232c:	e1a03000 	mov	r3, r0
    2330:	e54b3005 	strb	r3, [fp, #-5]
	if (bDevStatus & DEV_STATUS_RESET) {
    2334:	e55b3005 	ldrb	r3, [fp, #-5]
    2338:	e2033010 	and	r3, r3, #16
    233c:	e3530000 	cmp	r3, #0
    2340:	0a000001 	beq	234c <HandleUsbReset+0x2c>
//		DBG("\n!");
	  TRACE_DEBUG("\n");
    2344:	e59f000c 	ldr	r0, [pc, #12]	; 2358 <HandleUsbReset+0x38>
    2348:	ebfff93e 	bl	848 <iprintf>
	}
}
    234c:	e24bd004 	sub	sp, fp, #4
    2350:	e8bd4800 	pop	{fp, lr}
    2354:	e12fff1e 	bx	lr
    2358:	00003238 	.word	0x00003238

0000235c <USBInit>:
	installing default callbacks.

	@return TRUE if initialisation was successful
 */
BOOL USBInit(void)
{
    235c:	e92d4800 	push	{fp, lr}
    2360:	e28db004 	add	fp, sp, #4
	// init hardware
	USBHwInit();
    2364:	ebffff9a 	bl	21d4 <USBHwInit>

	// register bus reset handler
	USBHwRegisterDevIntHandler(HandleUsbReset);
    2368:	e59f0054 	ldr	r0, [pc, #84]	; 23c4 <USBInit+0x68>
    236c:	ebfffdda 	bl	1adc <USBHwRegisterDevIntHandler>

	// register control transfer handler on EP0
	USBHwRegisterEPIntHandler(0x00, USBHandleControlTransfer);
    2370:	e3a00000 	mov	r0, #0
    2374:	e59f104c 	ldr	r1, [pc, #76]	; 23c8 <USBInit+0x6c>
    2378:	ebfffd9a 	bl	19e8 <USBHwRegisterEPIntHandler>
	USBHwRegisterEPIntHandler(0x80, USBHandleControlTransfer);
    237c:	e3a00080 	mov	r0, #128	; 0x80
    2380:	e59f1040 	ldr	r1, [pc, #64]	; 23c8 <USBInit+0x6c>
    2384:	ebfffd97 	bl	19e8 <USBHwRegisterEPIntHandler>

	// setup control endpoints
	USBHwEPConfig(0x00, MAX_PACKET_SIZE0);
    2388:	e3a00000 	mov	r0, #0
    238c:	e3a01040 	mov	r1, #64	; 0x40
    2390:	ebfffd7b 	bl	1984 <USBHwEPConfig>
	USBHwEPConfig(0x80, MAX_PACKET_SIZE0);
    2394:	e3a00080 	mov	r0, #128	; 0x80
    2398:	e3a01040 	mov	r1, #64	; 0x40
    239c:	ebfffd78 	bl	1984 <USBHwEPConfig>

	// register standard request handler
	USBRegisterRequestHandler(REQTYPE_TYPE_STANDARD, USBHandleStandardRequest, abStdReqData);
    23a0:	e3a00000 	mov	r0, #0
    23a4:	e59f1020 	ldr	r1, [pc, #32]	; 23cc <USBInit+0x70>
    23a8:	e59f2020 	ldr	r2, [pc, #32]	; 23d0 <USBInit+0x74>
    23ac:	ebfffcbf 	bl	16b0 <USBRegisterRequestHandler>

	return TRUE;
    23b0:	e3a03001 	mov	r3, #1
}
    23b4:	e1a00003 	mov	r0, r3
    23b8:	e24bd004 	sub	sp, fp, #4
    23bc:	e8bd4800 	pop	{fp, lr}
    23c0:	e12fff1e 	bx	lr
    23c4:	00002320 	.word	0x00002320
    23c8:	000013b0 	.word	0x000013b0
    23cc:	00002b84 	.word	0x00002b84
    23d0:	400002c8 	.word	0x400002c8

000023d4 <USBRegisterDescriptors>:
	for the device.

	@param [in]	pabDescriptors	The descriptor byte array
 */
void USBRegisterDescriptors(const U8 *pabDescriptors)
{
    23d4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
    23d8:	e28db000 	add	fp, sp, #0
    23dc:	e24dd00c 	sub	sp, sp, #12
    23e0:	e50b0008 	str	r0, [fp, #-8]
	pabDescrip = pabDescriptors;
    23e4:	e59f3010 	ldr	r3, [pc, #16]	; 23fc <USBRegisterDescriptors+0x28>
    23e8:	e51b2008 	ldr	r2, [fp, #-8]
    23ec:	e5832000 	str	r2, [r3]
}
    23f0:	e28bd000 	add	sp, fp, #0
    23f4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
    23f8:	e12fff1e 	bx	lr
    23fc:	400002d8 	.word	0x400002d8

00002400 <USBGetDescriptor>:
	@param [out]	*ppbData	Descriptor data

	@return TRUE if the descriptor was found, FALSE otherwise
 */
BOOL USBGetDescriptor(U16 wTypeIndex, U16 wLangID, int *piLen, U8 **ppbData)
{
    2400:	e92d4800 	push	{fp, lr}
    2404:	e28db004 	add	fp, sp, #4
    2408:	e24dd028 	sub	sp, sp, #40	; 0x28
    240c:	e50b201c 	str	r2, [fp, #-28]	; 0xffffffe4
    2410:	e50b3020 	str	r3, [fp, #-32]	; 0xffffffe0
    2414:	e14b01b6 	strh	r0, [fp, #-22]	; 0xffffffea
    2418:	e14b11b8 	strh	r1, [fp, #-24]	; 0xffffffe8
	U8	bType, bIndex;
	U8	*pab;
	int iCurIndex;

	ASSERT(pabDescrip != NULL);
    241c:	e59f313c 	ldr	r3, [pc, #316]	; 2560 <USBGetDescriptor+0x160>
    2420:	e5933000 	ldr	r3, [r3]
    2424:	e3530000 	cmp	r3, #0
    2428:	1a000007 	bne	244c <USBGetDescriptor+0x4c>
    242c:	e3a0306c 	mov	r3, #108	; 0x6c
    2430:	e58d3000 	str	r3, [sp]
    2434:	e59f0128 	ldr	r0, [pc, #296]	; 2564 <USBGetDescriptor+0x164>
    2438:	e59f1128 	ldr	r1, [pc, #296]	; 2568 <USBGetDescriptor+0x168>
    243c:	e59f2128 	ldr	r2, [pc, #296]	; 256c <USBGetDescriptor+0x16c>
    2440:	e59f3128 	ldr	r3, [pc, #296]	; 2570 <USBGetDescriptor+0x170>
    2444:	ebfff8ff 	bl	848 <iprintf>
    2448:	eafffffe 	b	2448 <USBGetDescriptor+0x48>

	bType = GET_DESC_TYPE(wTypeIndex);
    244c:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
    2450:	e1a03423 	lsr	r3, r3, #8
    2454:	e1a03803 	lsl	r3, r3, #16
    2458:	e1a03823 	lsr	r3, r3, #16
    245c:	e54b300d 	strb	r3, [fp, #-13]
	bIndex = GET_DESC_INDEX(wTypeIndex);
    2460:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
    2464:	e54b300e 	strb	r3, [fp, #-14]

	pab = (U8 *)pabDescrip;
    2468:	e59f30f0 	ldr	r3, [pc, #240]	; 2560 <USBGetDescriptor+0x160>
    246c:	e5933000 	ldr	r3, [r3]
    2470:	e50b3008 	str	r3, [fp, #-8]
	iCurIndex = 0;
    2474:	e3a03000 	mov	r3, #0
    2478:	e50b300c 	str	r3, [fp, #-12]

	while (pab[DESC_bLength] != 0) {
    247c:	ea00002a 	b	252c <USBGetDescriptor+0x12c>
		if (pab[DESC_bDescriptorType] == bType) {
    2480:	e51b3008 	ldr	r3, [fp, #-8]
    2484:	e2833001 	add	r3, r3, #1
    2488:	e5d33000 	ldrb	r3, [r3]
    248c:	e55b200d 	ldrb	r2, [fp, #-13]
    2490:	e1520003 	cmp	r2, r3
    2494:	1a00001f 	bne	2518 <USBGetDescriptor+0x118>
			if (iCurIndex == bIndex) {
    2498:	e55b200e 	ldrb	r2, [fp, #-14]
    249c:	e51b300c 	ldr	r3, [fp, #-12]
    24a0:	e1520003 	cmp	r2, r3
    24a4:	1a000018 	bne	250c <USBGetDescriptor+0x10c>
				// set data pointer
				*ppbData = pab;
    24a8:	e51b3020 	ldr	r3, [fp, #-32]	; 0xffffffe0
    24ac:	e51b2008 	ldr	r2, [fp, #-8]
    24b0:	e5832000 	str	r2, [r3]
				// get length from structure
				if (bType == DESC_CONFIGURATION) {
    24b4:	e55b300d 	ldrb	r3, [fp, #-13]
    24b8:	e3530002 	cmp	r3, #2
    24bc:	1a00000b 	bne	24f0 <USBGetDescriptor+0xf0>
					// configuration descriptor is an exception, length is at offset 2 and 3
					*piLen =	(pab[CONF_DESC_wTotalLength]) |
    24c0:	e51b3008 	ldr	r3, [fp, #-8]
    24c4:	e2833002 	add	r3, r3, #2
    24c8:	e5d33000 	ldrb	r3, [r3]
    24cc:	e1a02003 	mov	r2, r3
								(pab[CONF_DESC_wTotalLength + 1] << 8);
    24d0:	e51b3008 	ldr	r3, [fp, #-8]
    24d4:	e2833003 	add	r3, r3, #3
    24d8:	e5d33000 	ldrb	r3, [r3]
    24dc:	e1a03403 	lsl	r3, r3, #8
				// set data pointer
				*ppbData = pab;
				// get length from structure
				if (bType == DESC_CONFIGURATION) {
					// configuration descriptor is an exception, length is at offset 2 and 3
					*piLen =	(pab[CONF_DESC_wTotalLength]) |
    24e0:	e1822003 	orr	r2, r2, r3
    24e4:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
    24e8:	e5832000 	str	r2, [r3]
    24ec:	ea000004 	b	2504 <USBGetDescriptor+0x104>
								(pab[CONF_DESC_wTotalLength + 1] << 8);
				}
				else {
					// normally length is at offset 0
					*piLen = pab[DESC_bLength];
    24f0:	e51b3008 	ldr	r3, [fp, #-8]
    24f4:	e5d33000 	ldrb	r3, [r3]
    24f8:	e1a02003 	mov	r2, r3
    24fc:	e51b301c 	ldr	r3, [fp, #-28]	; 0xffffffe4
    2500:	e5832000 	str	r2, [r3]
				}
				return TRUE;
    2504:	e3a03001 	mov	r3, #1
    2508:	ea000010 	b	2550 <USBGetDescriptor+0x150>
			}
			iCurIndex++;
    250c:	e51b300c 	ldr	r3, [fp, #-12]
    2510:	e2833001 	add	r3, r3, #1
    2514:	e50b300c 	str	r3, [fp, #-12]
		}
		// skip to next descriptor
		pab += pab[DESC_bLength];
    2518:	e51b3008 	ldr	r3, [fp, #-8]
    251c:	e5d33000 	ldrb	r3, [r3]
    2520:	e51b2008 	ldr	r2, [fp, #-8]
    2524:	e0823003 	add	r3, r2, r3
    2528:	e50b3008 	str	r3, [fp, #-8]
	bIndex = GET_DESC_INDEX(wTypeIndex);

	pab = (U8 *)pabDescrip;
	iCurIndex = 0;

	while (pab[DESC_bLength] != 0) {
    252c:	e51b3008 	ldr	r3, [fp, #-8]
    2530:	e5d33000 	ldrb	r3, [r3]
    2534:	e3530000 	cmp	r3, #0
    2538:	1affffd0 	bne	2480 <USBGetDescriptor+0x80>
		// skip to next descriptor
		pab += pab[DESC_bLength];
	}
	// nothing found
//	DBG("Desc %x not found!\n", wTypeIndex);
	TRACE_DEBUG("Desc %x not found!\n", wTypeIndex);
    253c:	e15b31b6 	ldrh	r3, [fp, #-22]	; 0xffffffea
    2540:	e59f002c 	ldr	r0, [pc, #44]	; 2574 <USBGetDescriptor+0x174>
    2544:	e1a01003 	mov	r1, r3
    2548:	ebfff8be 	bl	848 <iprintf>
	return FALSE;
    254c:	e3a03000 	mov	r3, #0
}
    2550:	e1a00003 	mov	r0, r3
    2554:	e24bd004 	sub	sp, fp, #4
    2558:	e8bd4800 	pop	{fp, lr}
    255c:	e12fff1e 	bx	lr
    2560:	400002d8 	.word	0x400002d8
    2564:	00003240 	.word	0x00003240
    2568:	00003268 	.word	0x00003268
    256c:	0000327c 	.word	0x0000327c
    2570:	000033b4 	.word	0x000033b4
    2574:	0000328c 	.word	0x0000328c

00002578 <USBSetConfiguration>:
	@todo function always returns TRUE, add stricter checking?

	@return TRUE if successfully configured, FALSE otherwise
 */
static BOOL USBSetConfiguration(U8 bConfigIndex, U8 bAltSetting)
{
    2578:	e92d4800 	push	{fp, lr}
    257c:	e28db004 	add	fp, sp, #4
    2580:	e24dd020 	sub	sp, sp, #32
    2584:	e1a02000 	mov	r2, r0
    2588:	e1a03001 	mov	r3, r1
    258c:	e54b2015 	strb	r2, [fp, #-21]	; 0xffffffeb
    2590:	e54b3016 	strb	r3, [fp, #-22]	; 0xffffffea
	U8	*pab;
	U8	bCurConfig, bCurAltSetting;
	U8	bEP;
	U16	wMaxPktSize;

	ASSERT(pabDescrip != NULL);
    2594:	e59f3180 	ldr	r3, [pc, #384]	; 271c <USBSetConfiguration+0x1a4>
    2598:	e5933000 	ldr	r3, [r3]
    259c:	e3530000 	cmp	r3, #0
    25a0:	1a000007 	bne	25c4 <USBSetConfiguration+0x4c>
    25a4:	e3a030a4 	mov	r3, #164	; 0xa4
    25a8:	e58d3000 	str	r3, [sp]
    25ac:	e59f016c 	ldr	r0, [pc, #364]	; 2720 <USBSetConfiguration+0x1a8>
    25b0:	e59f116c 	ldr	r1, [pc, #364]	; 2724 <USBSetConfiguration+0x1ac>
    25b4:	e59f216c 	ldr	r2, [pc, #364]	; 2728 <USBSetConfiguration+0x1b0>
    25b8:	e59f316c 	ldr	r3, [pc, #364]	; 272c <USBSetConfiguration+0x1b4>
    25bc:	ebfff8a1 	bl	848 <iprintf>
    25c0:	eafffffe 	b	25c0 <USBSetConfiguration+0x48>

	if (bConfigIndex == 0) {
    25c4:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
    25c8:	e3530000 	cmp	r3, #0
    25cc:	1a000002 	bne	25dc <USBSetConfiguration+0x64>
		// unconfigure device
		USBHwConfigDevice(FALSE);
    25d0:	e3a00000 	mov	r0, #0
    25d4:	ebfffe66 	bl	1f74 <USBHwConfigDevice>
    25d8:	ea00004a 	b	2708 <USBSetConfiguration+0x190>
	}
	else {
		// configure endpoints for this configuration/altsetting
		pab = (U8 *)pabDescrip;
    25dc:	e59f3138 	ldr	r3, [pc, #312]	; 271c <USBSetConfiguration+0x1a4>
    25e0:	e5933000 	ldr	r3, [r3]
    25e4:	e50b3008 	str	r3, [fp, #-8]
		bCurConfig = 0xFF;
    25e8:	e3e03000 	mvn	r3, #0
    25ec:	e54b3009 	strb	r3, [fp, #-9]
		bCurAltSetting = 0xFF;
    25f0:	e3e03000 	mvn	r3, #0
    25f4:	e54b300a 	strb	r3, [fp, #-10]

		while (pab[DESC_bLength] != 0) {
    25f8:	ea00003c 	b	26f0 <USBSetConfiguration+0x178>

			switch (pab[DESC_bDescriptorType]) {
    25fc:	e51b3008 	ldr	r3, [fp, #-8]
    2600:	e2833001 	add	r3, r3, #1
    2604:	e5d33000 	ldrb	r3, [r3]
    2608:	e3530004 	cmp	r3, #4
    260c:	0a000008 	beq	2634 <USBSetConfiguration+0xbc>
    2610:	e3530005 	cmp	r3, #5
    2614:	0a00000b 	beq	2648 <USBSetConfiguration+0xd0>
    2618:	e3530002 	cmp	r3, #2
    261c:	1a000029 	bne	26c8 <USBSetConfiguration+0x150>

			case DESC_CONFIGURATION:
				// remember current configuration index
				bCurConfig = pab[CONF_DESC_bConfigurationValue];
    2620:	e51b3008 	ldr	r3, [fp, #-8]
    2624:	e2833005 	add	r3, r3, #5
    2628:	e5d33000 	ldrb	r3, [r3]
    262c:	e54b3009 	strb	r3, [fp, #-9]
				break;
    2630:	ea000029 	b	26dc <USBSetConfiguration+0x164>

			case DESC_INTERFACE:
				// remember current alternate setting
				bCurAltSetting = pab[INTF_DESC_bAlternateSetting];
    2634:	e51b3008 	ldr	r3, [fp, #-8]
    2638:	e2833003 	add	r3, r3, #3
    263c:	e5d33000 	ldrb	r3, [r3]
    2640:	e54b300a 	strb	r3, [fp, #-10]
				break;
    2644:	ea000024 	b	26dc <USBSetConfiguration+0x164>

			case DESC_ENDPOINT:
				if ((bCurConfig == bConfigIndex) &&
    2648:	e55b2009 	ldrb	r2, [fp, #-9]
    264c:	e55b3015 	ldrb	r3, [fp, #-21]	; 0xffffffeb
    2650:	e1520003 	cmp	r2, r3
    2654:	1a00001d 	bne	26d0 <USBSetConfiguration+0x158>
    2658:	e55b200a 	ldrb	r2, [fp, #-10]
    265c:	e55b3016 	ldrb	r3, [fp, #-22]	; 0xffffffea
    2660:	e1520003 	cmp	r2, r3
    2664:	1a00001b 	bne	26d8 <USBSetConfiguration+0x160>
					(bCurAltSetting == bAltSetting)) {
					// endpoint found for desired config and alternate setting
					bEP = pab[ENDP_DESC_bEndpointAddress];
    2668:	e51b3008 	ldr	r3, [fp, #-8]
    266c:	e2833002 	add	r3, r3, #2
    2670:	e5d33000 	ldrb	r3, [r3]
    2674:	e54b300b 	strb	r3, [fp, #-11]
					wMaxPktSize = 	(pab[ENDP_DESC_wMaxPacketSize]) |
    2678:	e51b3008 	ldr	r3, [fp, #-8]
    267c:	e2833004 	add	r3, r3, #4
    2680:	e5d33000 	ldrb	r3, [r3]
    2684:	e1a02003 	mov	r2, r3
									(pab[ENDP_DESC_wMaxPacketSize + 1] << 8);
    2688:	e51b3008 	ldr	r3, [fp, #-8]
    268c:	e2833005 	add	r3, r3, #5
    2690:	e5d33000 	ldrb	r3, [r3]
    2694:	e1a03403 	lsl	r3, r3, #8
			case DESC_ENDPOINT:
				if ((bCurConfig == bConfigIndex) &&
					(bCurAltSetting == bAltSetting)) {
					// endpoint found for desired config and alternate setting
					bEP = pab[ENDP_DESC_bEndpointAddress];
					wMaxPktSize = 	(pab[ENDP_DESC_wMaxPacketSize]) |
    2698:	e1a03803 	lsl	r3, r3, #16
    269c:	e1a03823 	lsr	r3, r3, #16
    26a0:	e1823003 	orr	r3, r2, r3
    26a4:	e1a03803 	lsl	r3, r3, #16
    26a8:	e1a03823 	lsr	r3, r3, #16
    26ac:	e14b30be 	strh	r3, [fp, #-14]
									(pab[ENDP_DESC_wMaxPacketSize + 1] << 8);
					// configure endpoint
					USBHwEPConfig(bEP, wMaxPktSize);
    26b0:	e55b200b 	ldrb	r2, [fp, #-11]
    26b4:	e15b30be 	ldrh	r3, [fp, #-14]
    26b8:	e1a00002 	mov	r0, r2
    26bc:	e1a01003 	mov	r1, r3
    26c0:	ebfffcaf 	bl	1984 <USBHwEPConfig>
				}
				break;
    26c4:	ea000004 	b	26dc <USBSetConfiguration+0x164>

			default:
				break;
    26c8:	e1a00000 	nop			; (mov r0, r0)
    26cc:	ea000002 	b	26dc <USBSetConfiguration+0x164>
					wMaxPktSize = 	(pab[ENDP_DESC_wMaxPacketSize]) |
									(pab[ENDP_DESC_wMaxPacketSize + 1] << 8);
					// configure endpoint
					USBHwEPConfig(bEP, wMaxPktSize);
				}
				break;
    26d0:	e1a00000 	nop			; (mov r0, r0)
    26d4:	ea000000 	b	26dc <USBSetConfiguration+0x164>
    26d8:	e1a00000 	nop			; (mov r0, r0)

			default:
				break;
			}
			// skip to next descriptor
			pab += pab[DESC_bLength];
    26dc:	e51b3008 	ldr	r3, [fp, #-8]
    26e0:	e5d33000 	ldrb	r3, [r3]
    26e4:	e51b2008 	ldr	r2, [fp, #-8]
    26e8:	e0823003 	add	r3, r2, r3
    26ec:	e50b3008 	str	r3, [fp, #-8]
		// configure endpoints for this configuration/altsetting
		pab = (U8 *)pabDescrip;
		bCurConfig = 0xFF;
		bCurAltSetting = 0xFF;

		while (pab[DESC_bLength] != 0) {
    26f0:	e51b3008 	ldr	r3, [fp, #-8]
    26f4:	e5d33000 	ldrb	r3, [r3]
    26f8:	e3530000 	cmp	r3, #0
    26fc:	1affffbe 	bne	25fc <USBSetConfiguration+0x84>
			// skip to next descriptor
			pab += pab[DESC_bLength];
		}

		// configure device
		USBHwConfigDevice(TRUE);
    2700:	e3a00001 	mov	r0, #1
    2704:	ebfffe1a 	bl	1f74 <USBHwConfigDevice>
	}

	return TRUE;
    2708:	e3a03001 	mov	r3, #1
}
    270c:	e1a00003 	mov	r0, r3
    2710:	e24bd004 	sub	sp, fp, #4
    2714:	e8bd4800 	pop	{fp, lr}
    2718:	e12fff1e 	bx	lr
    271c:	400002d8 	.word	0x400002d8
    2720:	00003240 	.word	0x00003240
    2724:	00003268 	.word	0x00003268
    2728:	0000327c 	.word	0x0000327c
    272c:	000033a0 	.word	0x000033a0

00002730 <HandleStdDeviceReq>:
	@param [in,out]	ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdDeviceReq(TSetupPacket *pSetup, int *piLen, U8 **ppbData)
{
    2730:	e92d4800 	push	{fp, lr}
    2734:	e28db004 	add	fp, sp, #4
    2738:	e24dd018 	sub	sp, sp, #24
    273c:	e50b0010 	str	r0, [fp, #-16]
    2740:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    2744:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
	U8	*pbData = *ppbData;
    2748:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
    274c:	e5933000 	ldr	r3, [r3]
    2750:	e50b3008 	str	r3, [fp, #-8]

	switch (pSetup->bRequest) {
    2754:	e51b3010 	ldr	r3, [fp, #-16]
    2758:	e5d33001 	ldrb	r3, [r3, #1]
    275c:	e3530009 	cmp	r3, #9
    2760:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    2764:	ea000050 	b	28ac <HandleStdDeviceReq+0x17c>
    2768:	00002790 	.word	0x00002790
    276c:	00002888 	.word	0x00002888
    2770:	000028ac 	.word	0x000028ac
    2774:	00002888 	.word	0x00002888
    2778:	000028ac 	.word	0x000028ac
    277c:	000027bc 	.word	0x000027bc
    2780:	000027d4 	.word	0x000027d4
    2784:	00002890 	.word	0x00002890
    2788:	00002814 	.word	0x00002814
    278c:	00002834 	.word	0x00002834

	case REQ_GET_STATUS:
		// bit 0: self-powered
		// bit 1: remote wakeup = not supported
		pbData[0] = 0;
    2790:	e51b3008 	ldr	r3, [fp, #-8]
    2794:	e3a02000 	mov	r2, #0
    2798:	e5c32000 	strb	r2, [r3]
		pbData[1] = 0;
    279c:	e51b3008 	ldr	r3, [fp, #-8]
    27a0:	e2833001 	add	r3, r3, #1
    27a4:	e3a02000 	mov	r2, #0
    27a8:	e5c32000 	strb	r2, [r3]
		*piLen = 2;
    27ac:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
    27b0:	e3a02002 	mov	r2, #2
    27b4:	e5832000 	str	r2, [r3]
		break;
    27b8:	ea000042 	b	28c8 <HandleStdDeviceReq+0x198>

	case REQ_SET_ADDRESS:
		USBHwSetAddress(pSetup->wValue);
    27bc:	e51b3010 	ldr	r3, [fp, #-16]
    27c0:	e1d330b2 	ldrh	r3, [r3, #2]
    27c4:	e20330ff 	and	r3, r3, #255	; 0xff
    27c8:	e1a00003 	mov	r0, r3
    27cc:	ebfffcea 	bl	1b7c <USBHwSetAddress>
		break;
    27d0:	ea00003c 	b	28c8 <HandleStdDeviceReq+0x198>

	case REQ_GET_DESCRIPTOR:
//		DBG("D%x", pSetup->wValue);
	  TRACE_DEBUG("D%x", pSetup->wValue);
    27d4:	e51b3010 	ldr	r3, [fp, #-16]
    27d8:	e1d330b2 	ldrh	r3, [r3, #2]
    27dc:	e59f00f8 	ldr	r0, [pc, #248]	; 28dc <HandleStdDeviceReq+0x1ac>
    27e0:	e1a01003 	mov	r1, r3
    27e4:	ebfff817 	bl	848 <iprintf>
		return USBGetDescriptor(pSetup->wValue, pSetup->wIndex, piLen, ppbData);
    27e8:	e51b3010 	ldr	r3, [fp, #-16]
    27ec:	e1d320b2 	ldrh	r2, [r3, #2]
    27f0:	e51b3010 	ldr	r3, [fp, #-16]
    27f4:	e1d330b4 	ldrh	r3, [r3, #4]
    27f8:	e1a00002 	mov	r0, r2
    27fc:	e1a01003 	mov	r1, r3
    2800:	e51b2014 	ldr	r2, [fp, #-20]	; 0xffffffec
    2804:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
    2808:	ebfffefc 	bl	2400 <USBGetDescriptor>
    280c:	e1a03000 	mov	r3, r0
    2810:	ea00002d 	b	28cc <HandleStdDeviceReq+0x19c>

	case REQ_GET_CONFIGURATION:
		// indicate if we are configured
		pbData[0] = bConfiguration;
    2814:	e59f30c4 	ldr	r3, [pc, #196]	; 28e0 <HandleStdDeviceReq+0x1b0>
    2818:	e5d32000 	ldrb	r2, [r3]
    281c:	e51b3008 	ldr	r3, [fp, #-8]
    2820:	e5c32000 	strb	r2, [r3]
		*piLen = 1;
    2824:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
    2828:	e3a02001 	mov	r2, #1
    282c:	e5832000 	str	r2, [r3]
		break;
    2830:	ea000024 	b	28c8 <HandleStdDeviceReq+0x198>

	case REQ_SET_CONFIGURATION:
		if (!USBSetConfiguration(pSetup->wValue & 0xFF, 0)) {
    2834:	e51b3010 	ldr	r3, [fp, #-16]
    2838:	e1d330b2 	ldrh	r3, [r3, #2]
    283c:	e20330ff 	and	r3, r3, #255	; 0xff
    2840:	e1a00003 	mov	r0, r3
    2844:	e3a01000 	mov	r1, #0
    2848:	ebffff4a 	bl	2578 <USBSetConfiguration>
    284c:	e1a03000 	mov	r3, r0
    2850:	e3530000 	cmp	r3, #0
    2854:	1a000005 	bne	2870 <HandleStdDeviceReq+0x140>
			DBG("USBSetConfiguration failed!\n");
    2858:	e59f0084 	ldr	r0, [pc, #132]	; 28e4 <HandleStdDeviceReq+0x1b4>
    285c:	ebfff7f9 	bl	848 <iprintf>
			TRACE_DEBUG("USBSetConfiguration failed!\n");
    2860:	e59f0080 	ldr	r0, [pc, #128]	; 28e8 <HandleStdDeviceReq+0x1b8>
    2864:	ebfff7f7 	bl	848 <iprintf>
			return FALSE;
    2868:	e3a03000 	mov	r3, #0
    286c:	ea000016 	b	28cc <HandleStdDeviceReq+0x19c>
		}
		// configuration successful, update current configuration
		bConfiguration = pSetup->wValue & 0xFF;
    2870:	e51b3010 	ldr	r3, [fp, #-16]
    2874:	e1d330b2 	ldrh	r3, [r3, #2]
    2878:	e20320ff 	and	r2, r3, #255	; 0xff
    287c:	e59f305c 	ldr	r3, [pc, #92]	; 28e0 <HandleStdDeviceReq+0x1b0>
    2880:	e5c32000 	strb	r2, [r3]
		break;
    2884:	ea00000f 	b	28c8 <HandleStdDeviceReq+0x198>
			// put DEVICE_REMOTE_WAKEUP code here
		}
		if (pSetup->wValue == FEA_TEST_MODE) {
			// put TEST_MODE code here
		}
		return FALSE;
    2888:	e3a03000 	mov	r3, #0
    288c:	ea00000e 	b	28cc <HandleStdDeviceReq+0x19c>

	case REQ_SET_DESCRIPTOR:
//		DBG("Device req %d not implemented\n", pSetup->bRequest);
		TRACE_DEBUG("Device req %d not implemented\n", pSetup->bRequest);
    2890:	e51b3010 	ldr	r3, [fp, #-16]
    2894:	e5d33001 	ldrb	r3, [r3, #1]
    2898:	e59f004c 	ldr	r0, [pc, #76]	; 28ec <HandleStdDeviceReq+0x1bc>
    289c:	e1a01003 	mov	r1, r3
    28a0:	ebfff7e8 	bl	848 <iprintf>
		return FALSE;
    28a4:	e3a03000 	mov	r3, #0
    28a8:	ea000007 	b	28cc <HandleStdDeviceReq+0x19c>

	default:
//		DBG("Illegal device req %d\n", pSetup->bRequest);
	  TRACE_DEBUG("Illegal device req %d\n", pSetup->bRequest);
    28ac:	e51b3010 	ldr	r3, [fp, #-16]
    28b0:	e5d33001 	ldrb	r3, [r3, #1]
    28b4:	e59f0034 	ldr	r0, [pc, #52]	; 28f0 <HandleStdDeviceReq+0x1c0>
    28b8:	e1a01003 	mov	r1, r3
    28bc:	ebfff7e1 	bl	848 <iprintf>
		return FALSE;
    28c0:	e3a03000 	mov	r3, #0
    28c4:	ea000000 	b	28cc <HandleStdDeviceReq+0x19c>
	}

	return TRUE;
    28c8:	e3a03001 	mov	r3, #1
}
    28cc:	e1a00003 	mov	r0, r3
    28d0:	e24bd004 	sub	sp, fp, #4
    28d4:	e8bd4800 	pop	{fp, lr}
    28d8:	e12fff1e 	bx	lr
    28dc:	000032a8 	.word	0x000032a8
    28e0:	400002d0 	.word	0x400002d0
    28e4:	000032b4 	.word	0x000032b4
    28e8:	000032d4 	.word	0x000032d4
    28ec:	000032f8 	.word	0x000032f8
    28f0:	00003320 	.word	0x00003320

000028f4 <HandleStdInterfaceReq>:
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdInterfaceReq(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
    28f4:	e92d4800 	push	{fp, lr}
    28f8:	e28db004 	add	fp, sp, #4
    28fc:	e24dd018 	sub	sp, sp, #24
    2900:	e50b0010 	str	r0, [fp, #-16]
    2904:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    2908:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
	U8	*pbData = *ppbData;
    290c:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
    2910:	e5933000 	ldr	r3, [r3]
    2914:	e50b3008 	str	r3, [fp, #-8]

	switch (pSetup->bRequest) {
    2918:	e51b3010 	ldr	r3, [fp, #-16]
    291c:	e5d33001 	ldrb	r3, [r3, #1]
    2920:	e353000b 	cmp	r3, #11
    2924:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    2928:	ea000029 	b	29d4 <HandleStdInterfaceReq+0xe0>
    292c:	0000295c 	.word	0x0000295c
    2930:	00002988 	.word	0x00002988
    2934:	000029d4 	.word	0x000029d4
    2938:	00002988 	.word	0x00002988
    293c:	000029d4 	.word	0x000029d4
    2940:	000029d4 	.word	0x000029d4
    2944:	000029d4 	.word	0x000029d4
    2948:	000029d4 	.word	0x000029d4
    294c:	000029d4 	.word	0x000029d4
    2950:	000029d4 	.word	0x000029d4
    2954:	00002990 	.word	0x00002990
    2958:	000029ac 	.word	0x000029ac

	case REQ_GET_STATUS:
		// no bits specified
		pbData[0] = 0;
    295c:	e51b3008 	ldr	r3, [fp, #-8]
    2960:	e3a02000 	mov	r2, #0
    2964:	e5c32000 	strb	r2, [r3]
		pbData[1] = 0;
    2968:	e51b3008 	ldr	r3, [fp, #-8]
    296c:	e2833001 	add	r3, r3, #1
    2970:	e3a02000 	mov	r2, #0
    2974:	e5c32000 	strb	r2, [r3]
		*piLen = 2;
    2978:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
    297c:	e3a02002 	mov	r2, #2
    2980:	e5832000 	str	r2, [r3]
		break;
    2984:	ea000019 	b	29f0 <HandleStdInterfaceReq+0xfc>

	case REQ_CLEAR_FEATURE:
	case REQ_SET_FEATURE:
		// not defined for interface
		return FALSE;
    2988:	e3a03000 	mov	r3, #0
    298c:	ea000018 	b	29f4 <HandleStdInterfaceReq+0x100>

	case REQ_GET_INTERFACE:	// TODO use bNumInterfaces
        // there is only one interface, return n-1 (= 0)
		pbData[0] = 0;
    2990:	e51b3008 	ldr	r3, [fp, #-8]
    2994:	e3a02000 	mov	r2, #0
    2998:	e5c32000 	strb	r2, [r3]
		*piLen = 1;
    299c:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
    29a0:	e3a02001 	mov	r2, #1
    29a4:	e5832000 	str	r2, [r3]
		break;
    29a8:	ea000010 	b	29f0 <HandleStdInterfaceReq+0xfc>

	case REQ_SET_INTERFACE:	// TODO use bNumInterfaces
		// there is only one interface (= 0)
		if (pSetup->wValue != 0) {
    29ac:	e51b3010 	ldr	r3, [fp, #-16]
    29b0:	e1d330b2 	ldrh	r3, [r3, #2]
    29b4:	e3530000 	cmp	r3, #0
    29b8:	0a000001 	beq	29c4 <HandleStdInterfaceReq+0xd0>
			return FALSE;
    29bc:	e3a03000 	mov	r3, #0
    29c0:	ea00000b 	b	29f4 <HandleStdInterfaceReq+0x100>
		}
		*piLen = 0;
    29c4:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
    29c8:	e3a02000 	mov	r2, #0
    29cc:	e5832000 	str	r2, [r3]
		break;
    29d0:	ea000006 	b	29f0 <HandleStdInterfaceReq+0xfc>

	default:
//		DBG("Illegal interface req %d\n", pSetup->bRequest);
	  TRACE_DEBUG("Illegal interface req %d\n", pSetup->bRequest);
    29d4:	e51b3010 	ldr	r3, [fp, #-16]
    29d8:	e5d33001 	ldrb	r3, [r3, #1]
    29dc:	e59f0020 	ldr	r0, [pc, #32]	; 2a04 <HandleStdInterfaceReq+0x110>
    29e0:	e1a01003 	mov	r1, r3
    29e4:	ebfff797 	bl	848 <iprintf>
		return FALSE;
    29e8:	e3a03000 	mov	r3, #0
    29ec:	ea000000 	b	29f4 <HandleStdInterfaceReq+0x100>
	}

	return TRUE;
    29f0:	e3a03001 	mov	r3, #1
}
    29f4:	e1a00003 	mov	r0, r3
    29f8:	e24bd004 	sub	sp, fp, #4
    29fc:	e8bd4800 	pop	{fp, lr}
    2a00:	e12fff1e 	bx	lr
    2a04:	00003340 	.word	0x00003340

00002a08 <HandleStdEndPointReq>:
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
static BOOL HandleStdEndPointReq(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
    2a08:	e92d4800 	push	{fp, lr}
    2a0c:	e28db004 	add	fp, sp, #4
    2a10:	e24dd018 	sub	sp, sp, #24
    2a14:	e50b0010 	str	r0, [fp, #-16]
    2a18:	e50b1014 	str	r1, [fp, #-20]	; 0xffffffec
    2a1c:	e50b2018 	str	r2, [fp, #-24]	; 0xffffffe8
	U8	*pbData = *ppbData;
    2a20:	e51b3018 	ldr	r3, [fp, #-24]	; 0xffffffe8
    2a24:	e5933000 	ldr	r3, [r3]
    2a28:	e50b3008 	str	r3, [fp, #-8]

	switch (pSetup->bRequest) {
    2a2c:	e51b3010 	ldr	r3, [fp, #-16]
    2a30:	e5d33001 	ldrb	r3, [r3, #1]
    2a34:	e353000c 	cmp	r3, #12
    2a38:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    2a3c:	ea000042 	b	2b4c <HandleStdEndPointReq+0x144>
    2a40:	00002a74 	.word	0x00002a74
    2a44:	00002ac8 	.word	0x00002ac8
    2a48:	00002b4c 	.word	0x00002b4c
    2a4c:	00002afc 	.word	0x00002afc
    2a50:	00002b4c 	.word	0x00002b4c
    2a54:	00002b4c 	.word	0x00002b4c
    2a58:	00002b4c 	.word	0x00002b4c
    2a5c:	00002b4c 	.word	0x00002b4c
    2a60:	00002b4c 	.word	0x00002b4c
    2a64:	00002b4c 	.word	0x00002b4c
    2a68:	00002b4c 	.word	0x00002b4c
    2a6c:	00002b4c 	.word	0x00002b4c
    2a70:	00002b30 	.word	0x00002b30
	case REQ_GET_STATUS:
		// bit 0 = endpointed halted or not
		pbData[0] = (USBHwEPGetStatus(pSetup->wIndex) & EP_STATUS_STALLED) ? 1 : 0;
    2a74:	e51b3010 	ldr	r3, [fp, #-16]
    2a78:	e1d330b4 	ldrh	r3, [r3, #4]
    2a7c:	e20330ff 	and	r3, r3, #255	; 0xff
    2a80:	e1a00003 	mov	r0, r3
    2a84:	ebfffc69 	bl	1c30 <USBHwEPGetStatus>
    2a88:	e1a03000 	mov	r3, r0
    2a8c:	e2033002 	and	r3, r3, #2
    2a90:	e3530000 	cmp	r3, #0
    2a94:	03a03000 	moveq	r3, #0
    2a98:	13a03001 	movne	r3, #1
    2a9c:	e20320ff 	and	r2, r3, #255	; 0xff
    2aa0:	e51b3008 	ldr	r3, [fp, #-8]
    2aa4:	e5c32000 	strb	r2, [r3]
		pbData[1] = 0;
    2aa8:	e51b3008 	ldr	r3, [fp, #-8]
    2aac:	e2833001 	add	r3, r3, #1
    2ab0:	e3a02000 	mov	r2, #0
    2ab4:	e5c32000 	strb	r2, [r3]
		*piLen = 2;
    2ab8:	e51b3014 	ldr	r3, [fp, #-20]	; 0xffffffec
    2abc:	e3a02002 	mov	r2, #2
    2ac0:	e5832000 	str	r2, [r3]
		break;
    2ac4:	ea000027 	b	2b68 <HandleStdEndPointReq+0x160>

	case REQ_CLEAR_FEATURE:
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
    2ac8:	e51b3010 	ldr	r3, [fp, #-16]
    2acc:	e1d330b2 	ldrh	r3, [r3, #2]
    2ad0:	e3530000 	cmp	r3, #0
    2ad4:	1a000006 	bne	2af4 <HandleStdEndPointReq+0xec>
			// clear HALT by unstalling
			USBHwEPStall(pSetup->wIndex, FALSE);
    2ad8:	e51b3010 	ldr	r3, [fp, #-16]
    2adc:	e1d330b4 	ldrh	r3, [r3, #4]
    2ae0:	e20330ff 	and	r3, r3, #255	; 0xff
    2ae4:	e1a00003 	mov	r0, r3
    2ae8:	e3a01000 	mov	r1, #0
    2aec:	ebfffc65 	bl	1c88 <USBHwEPStall>
			break;
    2af0:	ea00001c 	b	2b68 <HandleStdEndPointReq+0x160>
		}
		// only ENDPOINT_HALT defined for endpoints
		return FALSE;
    2af4:	e3a03000 	mov	r3, #0
    2af8:	ea00001b 	b	2b6c <HandleStdEndPointReq+0x164>

	case REQ_SET_FEATURE:
		if (pSetup->wValue == FEA_ENDPOINT_HALT) {
    2afc:	e51b3010 	ldr	r3, [fp, #-16]
    2b00:	e1d330b2 	ldrh	r3, [r3, #2]
    2b04:	e3530000 	cmp	r3, #0
    2b08:	1a000006 	bne	2b28 <HandleStdEndPointReq+0x120>
			// set HALT by stalling
			USBHwEPStall(pSetup->wIndex, TRUE);
    2b0c:	e51b3010 	ldr	r3, [fp, #-16]
    2b10:	e1d330b4 	ldrh	r3, [r3, #4]
    2b14:	e20330ff 	and	r3, r3, #255	; 0xff
    2b18:	e1a00003 	mov	r0, r3
    2b1c:	e3a01001 	mov	r1, #1
    2b20:	ebfffc58 	bl	1c88 <USBHwEPStall>
			break;
    2b24:	ea00000f 	b	2b68 <HandleStdEndPointReq+0x160>
		}
		// only ENDPOINT_HALT defined for endpoints
		return FALSE;
    2b28:	e3a03000 	mov	r3, #0
    2b2c:	ea00000e 	b	2b6c <HandleStdEndPointReq+0x164>

	case REQ_SYNCH_FRAME:
//		DBG("EP req %d not implemented\n", pSetup->bRequest);
	  TRACE_DEBUG("EP req %d not implemented\n", pSetup->bRequest);
    2b30:	e51b3010 	ldr	r3, [fp, #-16]
    2b34:	e5d33001 	ldrb	r3, [r3, #1]
    2b38:	e59f003c 	ldr	r0, [pc, #60]	; 2b7c <HandleStdEndPointReq+0x174>
    2b3c:	e1a01003 	mov	r1, r3
    2b40:	ebfff740 	bl	848 <iprintf>
		return FALSE;
    2b44:	e3a03000 	mov	r3, #0
    2b48:	ea000007 	b	2b6c <HandleStdEndPointReq+0x164>

	default:
//		DBG("Illegal EP req %d\n", pSetup->bRequest);
	  TRACE_DEBUG("Illegal EP req %d\n", pSetup->bRequest);
    2b4c:	e51b3010 	ldr	r3, [fp, #-16]
    2b50:	e5d33001 	ldrb	r3, [r3, #1]
    2b54:	e59f0024 	ldr	r0, [pc, #36]	; 2b80 <HandleStdEndPointReq+0x178>
    2b58:	e1a01003 	mov	r1, r3
    2b5c:	ebfff739 	bl	848 <iprintf>
		return FALSE;
    2b60:	e3a03000 	mov	r3, #0
    2b64:	ea000000 	b	2b6c <HandleStdEndPointReq+0x164>
	}

	return TRUE;
    2b68:	e3a03001 	mov	r3, #1
}
    2b6c:	e1a00003 	mov	r0, r3
    2b70:	e24bd004 	sub	sp, fp, #4
    2b74:	e8bd4800 	pop	{fp, lr}
    2b78:	e12fff1e 	bx	lr
    2b7c:	00003360 	.word	0x00003360
    2b80:	00003384 	.word	0x00003384

00002b84 <USBHandleStandardRequest>:
	@param [in]		ppbData		Data buffer.

	@return TRUE if the request was handled successfully
 */
BOOL USBHandleStandardRequest(TSetupPacket	*pSetup, int *piLen, U8 **ppbData)
{
    2b84:	e92d4800 	push	{fp, lr}
    2b88:	e28db004 	add	fp, sp, #4
    2b8c:	e24dd010 	sub	sp, sp, #16
    2b90:	e50b0008 	str	r0, [fp, #-8]
    2b94:	e50b100c 	str	r1, [fp, #-12]
    2b98:	e50b2010 	str	r2, [fp, #-16]
	// try the custom request handler first
	if ((pfnHandleCustomReq != NULL) && pfnHandleCustomReq(pSetup, piLen, ppbData)) {
    2b9c:	e59f30b8 	ldr	r3, [pc, #184]	; 2c5c <USBHandleStandardRequest+0xd8>
    2ba0:	e5933000 	ldr	r3, [r3]
    2ba4:	e3530000 	cmp	r3, #0
    2ba8:	0a00000b 	beq	2bdc <USBHandleStandardRequest+0x58>
    2bac:	e59f30a8 	ldr	r3, [pc, #168]	; 2c5c <USBHandleStandardRequest+0xd8>
    2bb0:	e5933000 	ldr	r3, [r3]
    2bb4:	e51b0008 	ldr	r0, [fp, #-8]
    2bb8:	e51b100c 	ldr	r1, [fp, #-12]
    2bbc:	e51b2010 	ldr	r2, [fp, #-16]
    2bc0:	e1a0e00f 	mov	lr, pc
    2bc4:	e12fff13 	bx	r3
    2bc8:	e1a03000 	mov	r3, r0
    2bcc:	e3530000 	cmp	r3, #0
    2bd0:	0a000001 	beq	2bdc <USBHandleStandardRequest+0x58>
		return TRUE;
    2bd4:	e3a03001 	mov	r3, #1
    2bd8:	ea00001b 	b	2c4c <USBHandleStandardRequest+0xc8>
	}

	switch (REQTYPE_GET_RECIP(pSetup->bmRequestType)) {
    2bdc:	e51b3008 	ldr	r3, [fp, #-8]
    2be0:	e5d33000 	ldrb	r3, [r3]
    2be4:	e203301f 	and	r3, r3, #31
    2be8:	e3530001 	cmp	r3, #1
    2bec:	0a000009 	beq	2c18 <USBHandleStandardRequest+0x94>
    2bf0:	e3530002 	cmp	r3, #2
    2bf4:	0a00000d 	beq	2c30 <USBHandleStandardRequest+0xac>
    2bf8:	e3530000 	cmp	r3, #0
    2bfc:	1a000011 	bne	2c48 <USBHandleStandardRequest+0xc4>
	case REQTYPE_RECIP_DEVICE:		return HandleStdDeviceReq(pSetup, piLen, ppbData);
    2c00:	e51b0008 	ldr	r0, [fp, #-8]
    2c04:	e51b100c 	ldr	r1, [fp, #-12]
    2c08:	e51b2010 	ldr	r2, [fp, #-16]
    2c0c:	ebfffec7 	bl	2730 <HandleStdDeviceReq>
    2c10:	e1a03000 	mov	r3, r0
    2c14:	ea00000c 	b	2c4c <USBHandleStandardRequest+0xc8>
	case REQTYPE_RECIP_INTERFACE:	return HandleStdInterfaceReq(pSetup, piLen, ppbData);
    2c18:	e51b0008 	ldr	r0, [fp, #-8]
    2c1c:	e51b100c 	ldr	r1, [fp, #-12]
    2c20:	e51b2010 	ldr	r2, [fp, #-16]
    2c24:	ebffff32 	bl	28f4 <HandleStdInterfaceReq>
    2c28:	e1a03000 	mov	r3, r0
    2c2c:	ea000006 	b	2c4c <USBHandleStandardRequest+0xc8>
	case REQTYPE_RECIP_ENDPOINT: 	return HandleStdEndPointReq(pSetup, piLen, ppbData);
    2c30:	e51b0008 	ldr	r0, [fp, #-8]
    2c34:	e51b100c 	ldr	r1, [fp, #-12]
    2c38:	e51b2010 	ldr	r2, [fp, #-16]
    2c3c:	ebffff71 	bl	2a08 <HandleStdEndPointReq>
    2c40:	e1a03000 	mov	r3, r0
    2c44:	ea000000 	b	2c4c <USBHandleStandardRequest+0xc8>
	default: 						return FALSE;
    2c48:	e3a03000 	mov	r3, #0
	}
}
    2c4c:	e1a00003 	mov	r0, r3
    2c50:	e24bd004 	sub	sp, fp, #4
    2c54:	e8bd4800 	pop	{fp, lr}
    2c58:	e12fff1e 	bx	lr
    2c5c:	400002d4 	.word	0x400002d4

00002c60 <USBRegisterCustomReqHandler>:
	specification.

	@param [in]	pfnHandler	Callback function pointer
 */
void USBRegisterCustomReqHandler(TFnHandleRequest *pfnHandler)
{
    2c60:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
    2c64:	e28db000 	add	fp, sp, #0
    2c68:	e24dd00c 	sub	sp, sp, #12
    2c6c:	e50b0008 	str	r0, [fp, #-8]
	pfnHandleCustomReq = pfnHandler;
    2c70:	e59f3010 	ldr	r3, [pc, #16]	; 2c88 <USBRegisterCustomReqHandler+0x28>
    2c74:	e51b2008 	ldr	r2, [fp, #-8]
    2c78:	e5832000 	str	r2, [r3]
}
    2c7c:	e28bd000 	add	sp, fp, #0
    2c80:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
    2c84:	e12fff1e 	bx	lr
    2c88:	400002d4 	.word	0x400002d4

00002c8c <__aeabi_uidiv>:
    2c8c:	e2512001 	subs	r2, r1, #1
    2c90:	012fff1e 	bxeq	lr
    2c94:	3a000036 	bcc	2d74 <__aeabi_uidiv+0xe8>
    2c98:	e1500001 	cmp	r0, r1
    2c9c:	9a000022 	bls	2d2c <__aeabi_uidiv+0xa0>
    2ca0:	e1110002 	tst	r1, r2
    2ca4:	0a000023 	beq	2d38 <__aeabi_uidiv+0xac>
    2ca8:	e311020e 	tst	r1, #-536870912	; 0xe0000000
    2cac:	01a01181 	lsleq	r1, r1, #3
    2cb0:	03a03008 	moveq	r3, #8
    2cb4:	13a03001 	movne	r3, #1
    2cb8:	e3510201 	cmp	r1, #268435456	; 0x10000000
    2cbc:	31510000 	cmpcc	r1, r0
    2cc0:	31a01201 	lslcc	r1, r1, #4
    2cc4:	31a03203 	lslcc	r3, r3, #4
    2cc8:	3afffffa 	bcc	2cb8 <__aeabi_uidiv+0x2c>
    2ccc:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    2cd0:	31510000 	cmpcc	r1, r0
    2cd4:	31a01081 	lslcc	r1, r1, #1
    2cd8:	31a03083 	lslcc	r3, r3, #1
    2cdc:	3afffffa 	bcc	2ccc <__aeabi_uidiv+0x40>
    2ce0:	e3a02000 	mov	r2, #0
    2ce4:	e1500001 	cmp	r0, r1
    2ce8:	20400001 	subcs	r0, r0, r1
    2cec:	21822003 	orrcs	r2, r2, r3
    2cf0:	e15000a1 	cmp	r0, r1, lsr #1
    2cf4:	204000a1 	subcs	r0, r0, r1, lsr #1
    2cf8:	218220a3 	orrcs	r2, r2, r3, lsr #1
    2cfc:	e1500121 	cmp	r0, r1, lsr #2
    2d00:	20400121 	subcs	r0, r0, r1, lsr #2
    2d04:	21822123 	orrcs	r2, r2, r3, lsr #2
    2d08:	e15001a1 	cmp	r0, r1, lsr #3
    2d0c:	204001a1 	subcs	r0, r0, r1, lsr #3
    2d10:	218221a3 	orrcs	r2, r2, r3, lsr #3
    2d14:	e3500000 	cmp	r0, #0
    2d18:	11b03223 	lsrsne	r3, r3, #4
    2d1c:	11a01221 	lsrne	r1, r1, #4
    2d20:	1affffef 	bne	2ce4 <__aeabi_uidiv+0x58>
    2d24:	e1a00002 	mov	r0, r2
    2d28:	e12fff1e 	bx	lr
    2d2c:	03a00001 	moveq	r0, #1
    2d30:	13a00000 	movne	r0, #0
    2d34:	e12fff1e 	bx	lr
    2d38:	e3510801 	cmp	r1, #65536	; 0x10000
    2d3c:	21a01821 	lsrcs	r1, r1, #16
    2d40:	23a02010 	movcs	r2, #16
    2d44:	33a02000 	movcc	r2, #0
    2d48:	e3510c01 	cmp	r1, #256	; 0x100
    2d4c:	21a01421 	lsrcs	r1, r1, #8
    2d50:	22822008 	addcs	r2, r2, #8
    2d54:	e3510010 	cmp	r1, #16
    2d58:	21a01221 	lsrcs	r1, r1, #4
    2d5c:	22822004 	addcs	r2, r2, #4
    2d60:	e3510004 	cmp	r1, #4
    2d64:	82822003 	addhi	r2, r2, #3
    2d68:	908220a1 	addls	r2, r2, r1, lsr #1
    2d6c:	e1a00230 	lsr	r0, r0, r2
    2d70:	e12fff1e 	bx	lr
    2d74:	e3500000 	cmp	r0, #0
    2d78:	13e00000 	mvnne	r0, #0
    2d7c:	ea000059 	b	2ee8 <__aeabi_idiv0>

00002d80 <__aeabi_uidivmod>:
    2d80:	e3510000 	cmp	r1, #0
    2d84:	0afffffa 	beq	2d74 <__aeabi_uidiv+0xe8>
    2d88:	e92d4003 	push	{r0, r1, lr}
    2d8c:	ebffffbe 	bl	2c8c <__aeabi_uidiv>
    2d90:	e8bd4006 	pop	{r1, r2, lr}
    2d94:	e0030092 	mul	r3, r2, r0
    2d98:	e0411003 	sub	r1, r1, r3
    2d9c:	e12fff1e 	bx	lr

00002da0 <__aeabi_idiv>:
    2da0:	e3510000 	cmp	r1, #0
    2da4:	0a000043 	beq	2eb8 <.divsi3_skip_div0_test+0x110>

00002da8 <.divsi3_skip_div0_test>:
    2da8:	e020c001 	eor	ip, r0, r1
    2dac:	42611000 	rsbmi	r1, r1, #0
    2db0:	e2512001 	subs	r2, r1, #1
    2db4:	0a000027 	beq	2e58 <.divsi3_skip_div0_test+0xb0>
    2db8:	e1b03000 	movs	r3, r0
    2dbc:	42603000 	rsbmi	r3, r0, #0
    2dc0:	e1530001 	cmp	r3, r1
    2dc4:	9a000026 	bls	2e64 <.divsi3_skip_div0_test+0xbc>
    2dc8:	e1110002 	tst	r1, r2
    2dcc:	0a000028 	beq	2e74 <.divsi3_skip_div0_test+0xcc>
    2dd0:	e311020e 	tst	r1, #-536870912	; 0xe0000000
    2dd4:	01a01181 	lsleq	r1, r1, #3
    2dd8:	03a02008 	moveq	r2, #8
    2ddc:	13a02001 	movne	r2, #1
    2de0:	e3510201 	cmp	r1, #268435456	; 0x10000000
    2de4:	31510003 	cmpcc	r1, r3
    2de8:	31a01201 	lslcc	r1, r1, #4
    2dec:	31a02202 	lslcc	r2, r2, #4
    2df0:	3afffffa 	bcc	2de0 <.divsi3_skip_div0_test+0x38>
    2df4:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    2df8:	31510003 	cmpcc	r1, r3
    2dfc:	31a01081 	lslcc	r1, r1, #1
    2e00:	31a02082 	lslcc	r2, r2, #1
    2e04:	3afffffa 	bcc	2df4 <.divsi3_skip_div0_test+0x4c>
    2e08:	e3a00000 	mov	r0, #0
    2e0c:	e1530001 	cmp	r3, r1
    2e10:	20433001 	subcs	r3, r3, r1
    2e14:	21800002 	orrcs	r0, r0, r2
    2e18:	e15300a1 	cmp	r3, r1, lsr #1
    2e1c:	204330a1 	subcs	r3, r3, r1, lsr #1
    2e20:	218000a2 	orrcs	r0, r0, r2, lsr #1
    2e24:	e1530121 	cmp	r3, r1, lsr #2
    2e28:	20433121 	subcs	r3, r3, r1, lsr #2
    2e2c:	21800122 	orrcs	r0, r0, r2, lsr #2
    2e30:	e15301a1 	cmp	r3, r1, lsr #3
    2e34:	204331a1 	subcs	r3, r3, r1, lsr #3
    2e38:	218001a2 	orrcs	r0, r0, r2, lsr #3
    2e3c:	e3530000 	cmp	r3, #0
    2e40:	11b02222 	lsrsne	r2, r2, #4
    2e44:	11a01221 	lsrne	r1, r1, #4
    2e48:	1affffef 	bne	2e0c <.divsi3_skip_div0_test+0x64>
    2e4c:	e35c0000 	cmp	ip, #0
    2e50:	42600000 	rsbmi	r0, r0, #0
    2e54:	e12fff1e 	bx	lr
    2e58:	e13c0000 	teq	ip, r0
    2e5c:	42600000 	rsbmi	r0, r0, #0
    2e60:	e12fff1e 	bx	lr
    2e64:	33a00000 	movcc	r0, #0
    2e68:	01a00fcc 	asreq	r0, ip, #31
    2e6c:	03800001 	orreq	r0, r0, #1
    2e70:	e12fff1e 	bx	lr
    2e74:	e3510801 	cmp	r1, #65536	; 0x10000
    2e78:	21a01821 	lsrcs	r1, r1, #16
    2e7c:	23a02010 	movcs	r2, #16
    2e80:	33a02000 	movcc	r2, #0
    2e84:	e3510c01 	cmp	r1, #256	; 0x100
    2e88:	21a01421 	lsrcs	r1, r1, #8
    2e8c:	22822008 	addcs	r2, r2, #8
    2e90:	e3510010 	cmp	r1, #16
    2e94:	21a01221 	lsrcs	r1, r1, #4
    2e98:	22822004 	addcs	r2, r2, #4
    2e9c:	e3510004 	cmp	r1, #4
    2ea0:	82822003 	addhi	r2, r2, #3
    2ea4:	908220a1 	addls	r2, r2, r1, lsr #1
    2ea8:	e35c0000 	cmp	ip, #0
    2eac:	e1a00233 	lsr	r0, r3, r2
    2eb0:	42600000 	rsbmi	r0, r0, #0
    2eb4:	e12fff1e 	bx	lr
    2eb8:	e3500000 	cmp	r0, #0
    2ebc:	c3e00102 	mvngt	r0, #-2147483648	; 0x80000000
    2ec0:	b3a00102 	movlt	r0, #-2147483648	; 0x80000000
    2ec4:	ea000007 	b	2ee8 <__aeabi_idiv0>

00002ec8 <__aeabi_idivmod>:
    2ec8:	e3510000 	cmp	r1, #0
    2ecc:	0afffff9 	beq	2eb8 <.divsi3_skip_div0_test+0x110>
    2ed0:	e92d4003 	push	{r0, r1, lr}
    2ed4:	ebffffb3 	bl	2da8 <.divsi3_skip_div0_test>
    2ed8:	e8bd4006 	pop	{r1, r2, lr}
    2edc:	e0030092 	mul	r3, r2, r0
    2ee0:	e0411003 	sub	r1, r1, r3
    2ee4:	e12fff1e 	bx	lr

00002ee8 <__aeabi_idiv0>:
    2ee8:	e12fff1e 	bx	lr
    2eec:	6c756e28 	.word	0x6c756e28
    2ef0:	0000296c 	.word	0x0000296c

00002ef4 <abDescriptors>:
    2ef4:	02000112 40000000 000effff 02010100     .......@........
    2f04:	02090103 01010020 09328000 02000004     .... .....2.....
    2f14:	000000ff 02820507 07000040 40020505     ........@......@
    2f24:	03040000 030e0409 0050004c 00550043     ........L.P.C.U.
    2f34:	00420053 0047031a 00540046 00440020     S.B...G.F.T. .D.
    2f44:	00760065 00630069 00760065 03120031     e.v.i.c.e.v.1...
    2f54:	00450044 00440041 00300043 00450044     D.E.A.D.C.0.D.E.
    2f64:	00000000 442d0a0d 4552202d 203a4441     ......-D- READ: 
    2f74:	72646461 2c58253d 6e656c20 0a64253d     addr=%X, len=%d.
    2f84:	00000000 442d0a0d 5257202d 3a455449     ......-D- WRITE:
    2f94:	64646120 58253d72 656c202c 64253d6e      addr=%X, len=%d
    2fa4:	0000000a 442d0a0d 6e55202d 646e6168     ......-D- Unhand
    2fb4:	2064656c 73616c63 58252073 0000000a     led class %X....
    2fc4:	442d0a0d 6e49202d 61697469 6973696c     ..-D- Initialisi
    2fd4:	5520676e 73204253 6b636174 0000000a     ng USB stack....
    2fe4:	442d0a0d 7453202d 69747261 5520676e     ..-D- Starting U
    2ff4:	63204253 756d6d6f 6163696e 6e6f6974     SB communication
    3004:	0000000a 442d0a0d 6f4e202d 6e616820     ......-D- No han
    3014:	72656c64 726f6620 71657220 65707974     dler for reqtype
    3024:	0a642520 00000000 442d0a0d 5453202d      %d.......-D- ST
    3034:	204c4c41 5b206e6f 00000000 32302520     ALL on [.... %02
    3044:	00000078 442d0a0d 5d20202d 61747320     x.....-D-  ] sta
    3054:	78253d74 0000000a 442d0a0d 2553202d     t=%x......-D- S%
    3064:	00000078 442d0a0d 485f202d 6c646e61     x.....-D- _Handl
    3074:	71655265 74736575 61662031 64656c69     eRequest1 failed
    3084:	0000000a 6e61485f 52656c64 65757165     ...._HandleReque
    3094:	20327473 6c696166 000a6465 442d0a0d     st2 failed....-D
    30a4:	485f202d 6c646e61 71655265 74736575     - _HandleRequest
    30b4:	61662032 64656c69 0000000a 0000003f     2 failed....?...
    30c4:	00000000 442d0a0d 0a0d202d 00000000     ......-D- ......
    30d4:	7373410a 69747265 27206e6f 20277325     .Assertion '%s' 
    30e4:	6c696166 69206465 7325206e 2373253a     failed in %s:%s#
    30f4:	0d216425 0000000a 534c4146 00000045     %d!.....FALSE...
    3104:	752f2e2e 6f636273 6f72746e 00632e6c     ../usbcontrol.c.
    3114:	70795469 3d3e2065 00003020 70795469     iType >= 0..iTyp
    3124:	203c2065 00000034                       e < 4...

0000312c <__FUNCTION__.4056>:
    312c:	52425355 73696765 52726574 65757165     USBRegisterReque
    313c:	61487473 656c646e 00000072              stHandler...

00003148 <__FUNCTION__.4049>:
    3148:	48425355 6c646e61 6e6f4365 6c6f7274     USBHandleControl
    3158:	6e617254 72656673 00000000 7373410a     Transfer.....Ass
    3168:	69747265 27206e6f 20277325 6c696166     ertion '%s' fail
    3178:	69206465 7325206e 2373253a 0d216425     ed in %s:%s#%d!.
    3188:	0000000a 3c786469 00003233 752f2e2e     ....idx<32..../u
    3198:	77686273 63706c5f 0000632e 442d0a0d     sbhw_lpc.c....-D
    31a8:	6552202d 74736967 64657265 6e616820     - Registered han
    31b8:	72656c64 726f6620 20504520 78257830     dler for EP 0x%x
    31c8:	0000000a 442d0a0d 6552202d 74736967     ......-D- Regist
    31d8:	64657265 6e616820 72656c64 726f6620     ered handler for
    31e8:	76656420 20656369 74617473 000a7375      device status..
    31f8:	442d0a0d 6552202d 74736967 64657265     ..-D- Registered
    3208:	6e616820 72656c64 726f6620 61726620      handler for fra
    3218:	000a656d                                me..

0000321c <__FUNCTION__.4055>:
    321c:	48425355 67655277 65747369 49504572     USBHwRegisterEPI
    322c:	6148746e 656c646e 00000072 442d0a0d     ntHandler.....-D
    323c:	000a202d 7373410a 69747265 27206e6f     - ...Assertion '
    324c:	20277325 6c696166 69206465 7325206e     %s' failed in %s
    325c:	2373253a 0d216425 0000000a 44626170     :%s#%d!.....pabD
    326c:	72637365 21207069 554e203d 00004c4c     escrip != NULL..
    327c:	752f2e2e 74736273 71657264 0000632e     ../usbstdreq.c..
    328c:	442d0a0d 6544202d 25206373 6f6e2078     ..-D- Desc %x no
    329c:	6f662074 21646e75 0000000a 442d0a0d     t found!......-D
    32ac:	2544202d 00000078 53425355 6f437465     - D%x...USBSetCo
    32bc:	6769666e 74617275 206e6f69 6c696166     nfiguration fail
    32cc:	0a216465 00000000 442d0a0d 5355202d     ed!.......-D- US
    32dc:	74655342 666e6f43 72756769 6f697461     BSetConfiguratio
    32ec:	6166206e 64656c69 00000a21 442d0a0d     n failed!.....-D
    32fc:	6544202d 65636976 71657220 20642520     - Device req %d 
    330c:	20746f6e 6c706d69 6e656d65 0a646574     not implemented.
    331c:	00000000 442d0a0d 6c49202d 6167656c     ......-D- Illega
    332c:	6564206c 65636976 71657220 0a642520     l device req %d.
    333c:	00000000 442d0a0d 6c49202d 6167656c     ......-D- Illega
    334c:	6e69206c 66726574 20656361 20716572     l interface req 
    335c:	000a6425 442d0a0d 5045202d 71657220     %d....-D- EP req
    336c:	20642520 20746f6e 6c706d69 6e656d65      %d not implemen
    337c:	0a646574 00000000 442d0a0d 6c49202d     ted.......-D- Il
    338c:	6167656c 5045206c 71657220 0a642520     legal EP req %d.
    339c:	00000000                                ....

000033a0 <__FUNCTION__.4048>:
    33a0:	53425355 6f437465 6769666e 74617275     USBSetConfigurat
    33b0:	006e6f69                                ion.

000033b4 <__FUNCTION__.4034>:
    33b4:	47425355 65447465 69726373 726f7470     USBGetDescriptor
    33c4:	00000000                                ....
